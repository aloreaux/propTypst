<script>
  const form = document.getElementById("pdf-form");
  let jsonGenerated = false;
  let downloadTriggered = false;
  let currenntDragElement = null;

  const jsonBtn = document.getElementById("generate-json");
  const pdfBtn = document.getElementById("generate-pdf");
  const loadJSONbtn = document.getElementById("load-json");
  let cacheProposalId = null;

  const investmentContainer = document.getElementById("investment-container");

    // New: All categories to fetch. Adjust if you add/remove categories.
  const ALL_IMAGE_CATEGORIES = [
    'athletics',
    'business',
    'firedept',
    'grow',
    'healthcare',
    'higheredu',
    'industrial',
    'military',
    'museum',
    'publicsafety'
  ];
  
  let allThumbnails = [];

  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach((node) => {
          if (
            node.nodeType === Node.ELEMENT_NODE &&
            node.matches("input[name='investPrice']")
          ) {
            addCommas(node);
          } else if (
            node.nodeType === Node.ELEMENT_NODE &&
            node.querySelectorAll
          ) {
            // Check inside added subtree for matching inputs
            node
              .querySelectorAll("input[name='investPrice']")
              .forEach((input) => addCommas(input));
          }
        });
      }
    }
  });

  if (pdfBtn) {
    pdfBtn.disabled = true;
  }

  async function getOrCreateProposalId() {
    if (cacheProposalId) {return cacheProposalId;}
    const res = await fetch('/next-proposal-id');
    const data = await res.json();
    cacheProposalId = data.proposalId;
    return cacheProposalId;
  }

  // Function to remove the element
  function removeSection(element) {
    if (element) {
      element.remove(); // Remove the element from the DOM
    }
  }

  function addEquipSection() {
    const section = document.getElementById('equipment-section');
    const tmpl = document.getElementById('tmpl-equip-room');
    if (!tmpl) { return };

    const clone = tmpl.content.cloneNode(true);
    section.appendChild(clone);
    initializeDragAndDrop();
  }

  function addEquipItem(button) {
    const equipSection = button.closest('.equip-room');
    if (!equipSection) {
      console.error('Equip room not found!');
      return;
    }

    const equipItemsContainer = equipSection.querySelector('.equip-items');
    if (!equipItemsContainer) {
      console.error('Equip items container not found!');
      return;
    }

    const tmplItem = document.getElementById('tmpl-equip-item');
    const cloneItem = tmplItem.content.cloneNode(true);
    equipItemsContainer.appendChild(cloneItem);
    initializeDragAndDrop();
  }

  function addSummarySection() {
    const section = document.getElementById('summary-section');
    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'nested-section summary-section';
    summaryDiv.innerHTML = `
      <div class="col-md-6">
        <label class="form-label">Summary Name: <input type="text" name="summarySectionName" placeholder="Summary Name" class="form-control" required /></label>
        <div class="summary-items"></div>
        <button type="button" class="btn btn-primary btn-sm me-2" onclick="addSummaryItem(this)">Add Item</button>
        <button type="button" class="btn btn-danger btn-sm" onclick="this.parentNode.remove()">Remove Room</button>
      </div>`;
    section.appendChild(summaryDiv);
  }

  function addSummaryItem(button) {
    const container = button.previousElementSibling;
    const itemDiv = document.createElement('div');
    itemDiv.innerHTML = `
        <label class="form-label">Item:<input type="text" name="summaryItem" size="175" class="form-control" required /></label>
        <button type="button" class="btn btn-danger btn-sm" onclick="this.parentNode.remove()">Remove Item</button>
      `;
    container.appendChild(itemDiv);
  }

  /** ==========================
  * Add New Investment Section
  ========================== **/
  function addInvestSection(name = "", items = [], price = "") {
    const container = document.getElementById("investment-container");
    if (!container) {
      console.error("Investment container not found!");
      return;
    }

    const tmplInvestSection = document.getElementById("tmpl-invest-section");
    if (!tmplInvestSection) {
      console.error("Template #tmpl-invest-section not found!");
      return;
    }

    const clone = tmplInvestSection.content.cloneNode(true);
    const investDiv = clone.querySelector(".invest-section");
    if(!investDiv) {
      console.error("Clone did not yield .invest-section");
      return;
    }
    investDiv.querySelector('input[name="investSectionName"]').value = name;
    investDiv.querySelector('input[name="investPrice"]').value = price;

    const itemsContainer = investDiv.querySelector(".invest-items");
    items.forEach((text) => {
      const tmplItem = document.getElementById("tmpl-invest-item");
      const itemClone = tmplItem.content.cloneNode(true);
      const itemDiv = itemClone.querySelector(".input-group");

      if (itemDiv) {
        itemDiv.querySelector('textarea[name="investItem"]').textContent = text;
        //itemDiv.querySelector('input[name="investItem"]').value = text;
        itemsContainer.appendChild(itemDiv);
        initializeDragAndDrop();
      }
    });

    container.appendChild(investDiv);
    initializeDragAndDrop();
    // Find all price inputs
    const priceInputs = document.querySelectorAll('input[name="investPrice"]');

    // Attach comma formatting to each price input
    priceInputs.forEach(attachCommaFormatting);
  }

  /** ==========================
   * Add New Item to Investment Section
   ========================== **/
  function addInvestItem(button) {
    //const container = button.previousElementSibling;
    const investSection = button.closest('.invest-section');
    if (!investSection) {
      console.error('Invest section not found!');
      return;
    }

    const investItemsContainer = investSection.querySelector('.invest-items');
    if (!investItemsContainer) {
      console.error('Invest items container not found!');
      return;
    }

    const tmplItem = document.getElementById('tmpl-invest-item');
    const investItemClone = tmplItem.content.cloneNode(true);
    investItemsContainer.appendChild(investItemClone);
    initializeDragAndDrop();
  }

  /** Generate JSON */
  if (jsonBtn) {
    //document.getElementById("generate-json").addEventListener("click", (e) => {
    jsonBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      const data = await prepareFormData(form);

      try {
        const response = await fetch('/generate-json', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(data)
        });

        if (response.ok) {
          console.log("Value of data:", data)
          //const jsonBlob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
          const blob = await response.blob();
          const jsonUrl = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = jsonUrl;
          a.download = `${data.proposal}_${(data.title || "generated").replace(/[^a-zA-Z0-9-_]/g, "_").substring(0, 50)}.json`;
          console.log("Value of a.download:", a.download);
          document.body.appendChild(a);
          jsonGenerated = true;
          pdfBtn?.removeAttribute("disabled");
          a.click();
          document.body.removeChild(a);

          URL.revokeObjectURL(jsonUrl);
        } else {
          alert("Failed to generate JSON");
        }
      } catch (err) {
        console.error("Error generating JSON:", err);
        alert("An error occurred while generating the JSON file.");
      }
    });
  }

  /** ==========================
  * Form Submission
  ========================== **/
  if (pdfBtn) {
    //document.getElementById('generate-pdf').addEventListener("click", async (e) => {
    pdfBtn.addEventListener("click", async (e) => {
      if (!jsonGenerated) {
        e.preventDefault();
        alert("Please generate the JSON file before generating the PDF.");
      }
      const data = await prepareFormData(form);

      console.log('Final Data Before Sending:', JSON.stringify(data, null, 2));

      try {
        const response = await fetch('/generate-pdf', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(data)
        });

        if (response.ok) {
          const blob = await response.blob();
          const pdfUrl = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = pdfUrl;
          //a.download = 'generated.pdf';
          //a.download = `${data.proposal}_${(data.title || "generated").replace(/[^a-zA-Z0-9-_]/g, "_").substring(0, 50)}.pdf`;
          a.download = `${data.proposal}_${(data.title || "generated").replace(/[^a-zA-Z0-9-_]/g, "_").substring(0, 50)}.pdf`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          URL.revokeObjectURL(pdfUrl);
          //alert('PDF generated successfully!');
        } else {
          console.error('PDF generation failed:', await response.text());
          alert('Failed to generate PDF');
        }
      } catch (error) {
        console.error('Error submitting form:', error);
        alert('An error occurred while generating the PDF.');
      }
    });
  }

  if(loadJSONbtn) {
    //document.getElementById("load-json").addEventListener("click", async () => {
    loadJSONbtn.addEventListener("click", async () => {
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "application/json";

      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const jsonData = JSON.parse(e.target.result);
            populateForm(jsonData);
          } catch (error) {
            console.error("Invalid JSON file", error);
            alert("Failed to load JSON file. Please check its structure.");
          }
        };
        reader.readAsText(file);
      });

      fileInput.click();
    });
  }

  function populateSummarySections(summaryData = {}) {
    const sectionEls = [...document.querySelectorAll(".summary-section")];
    const summaryKeys = Object.keys(summaryData);
  
    sectionEls.forEach((sectionEl, idx) => {
      const titleInput = sectionEl.querySelector(".section-title");
      const defaultTitle = titleInput?.dataset?.originalTitle;
      const container = sectionEl.querySelector(".summary-items");
      const key = summaryKeys[idx]; // Match section by order
  
      // Reset section title and container
      titleInput.disabled = false;
      titleInput.value = key || defaultTitle || "";
      container.innerHTML = `
        <div class="input-group mb-2">
          <span class="input-group-text">Item</span>
          <input type="text" class="form-control summary-input" name="${defaultTitle}Text" required />
          <textarea class="form-control summary-textarea" name="${defaultTitle}Area" rows="3" style="display: none;" disabled></textarea>
        </div>
      `;
  
      if (!key || !(key in summaryData)) {
        toggleSection(sectionEl.dataset.section, false);
        return;
      }
  
      // Populate values
      const value = summaryData[key];
      container.innerHTML = ""; // Clear again
  
      if (typeof value === "string") {
        const textarea = document.createElement("textarea");
        textarea.className = "form-control summary-textarea";
        textarea.name = `${key}Area`;
        textarea.rows = 3;
        textarea.required = true;
        textarea.value = value;
        container.appendChild(textarea);
      } else if (Array.isArray(value)) {
        value.forEach(item => {
          const div = document.createElement("div");
          div.className = "input-group mb-2";
          div.innerHTML = `
            <span class="input-group-text">Item</span>
            <input type="text" class="form-control summary-input" name="${key}Text" value="${item}" required />
            <button class="btn btn-danger btn-sm" type="button" onclick="this.parentNode.remove()">
              <i class="bi bi-x-square-fill"></i>
            </button>
          `;
          container.appendChild(div);
        });
      }
  
      // Enable this section
      sectionEl.classList.remove("disabled-section");
      sectionEl.querySelectorAll("input, textarea, button").forEach(el => el.disabled = false);
      sectionEl.dataset.enabled = true;
    });
  }

  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  // Populate form with data
  async function populateForm(data) {
    const form = document.getElementById("pdf-form");

    // Populate basic fields
    Object.keys(data).forEach((key) => {
      const field = form.querySelector(`[name="${key}"]`);
      if (field) {
        if (field.type === "checkbox") {
          field.checked = data[key];
          // Dynamically update all checkboxes based on JSON data
          form.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
            const name = checkbox.name;

            // If the checkbox key exists in the JSON, use its value
            // If it doesn't exist, default to unchecked
            checkbox.checked = !!data[name];
          });
        } else {
          field.value = data[key];
        }
      }
    });

    const state = form.querySelector('[name="state"]')?.value;
    const city = form.querySelector('[name="city"]')?.value;
    const zipField = form.querySelector('[name="zip"]');

    if (state && city && zipField) {
      updateZipFromCity(state, city, zipField);

      if (data.zip) {
        const zipToSelect = String(data.zip).padStart(5, "0");
        const match = Array.from(zipField.options).find(opt => opt.value === zipToSelect);
        if (match) match.selected = true;
      }
    }
    
    // Handle equipment (dynamically create missing rooms and items)
    if (data.equip && Object.keys(data.equip).length > 0) {
      const equipSection = document.getElementById("equipment-section");
      equipSection.innerHTML = `<button type="button" class="btn btn-primary mb-3" onclick="addEquipSection()">Add Room</button>`; // Clear existing equipment
      Object.entries(data.equip).forEach(([roomName, items]) => {
        const roomDiv = document.createElement("div");
        roomDiv.className = "card nested-section equip-room mb-2";
        roomDiv.innerHTML = `
                <div class="col-md p-2">
                  <div class="input-group">
                    <span class="input-group-text">Room Name</span>
                    <input type="text" name="equipRoomName" placeholder="Room Name" class="form-control" value="${roomName}" required />
                    <button type="button" class="btn btn-primary" onclick="addEquipItem(this)">Add Item</button>
                    <button type="button" class="btn btn-danger" onclick="this.closest('.equip-room').remove()">Remove Room</button>
                  </div>
                  <div class="equip-items">
                ${items
            .map(
              (item) => `
                <div class="input-group mt-2">
                  <span class="input-group-text">Item</span>
                      <input type="text" name="equipItem" class="form-control" value="${escapeHtml(item)}" required />
                  <button type="button" class="btn btn-danger" onclick="this.parentNode.remove()"><i class="bi bi-x-square-fill"></i></button>
                </div>
                    `
            )
            .join("")}
                </div>
              </div>
            `;
        equipSection.appendChild(roomDiv);
      });
    } else {
      const equipSection = document.getElementById("equipment-section");
      equipSection.innerHTML = `
        <button type="button" class="btn btn-primary mb-3" onclick="addEquipSection()">Add Room</button>
        `;
    }

    // Handle investment sections (dynamically create missing sections and items)
    if (data.invest) {
      const investContainer = document.getElementById("investment-container");
      investContainer.innerHTML = ""; // Clear existing investment sections
      Object.entries(data.invest).forEach(([sectionName, {items, price}]) => {
        addInvestSection(sectionName, items || [], price || "");
      });
    }

    // Dynamically toggle all sections based on checkbox states
    document.querySelectorAll('input[type="checkbox"][id$="Bool"]').forEach(checkbox => {
      const idPrefix = checkbox.id.replace("Bool", "");
      const section = document.getElementById(`${idPrefix}-section`);
      if (!section) return;

      const isEnabled = checkbox.checked;
      section.querySelectorAll("input, textarea, button, select").forEach(field => {
        field.disabled = !isEnabled;
      });
    });

    document.querySelectorAll('input[type="checkbox"][id$="Bool"]').forEach(cb => {
      cb.dispatchEvent(new Event("change"));
    });

    console.log("Summary Section sent to function: ", data.summary);
    populateSummarySections(data.summary || {});

    await loadAllThumbnails();

    if (data.imgpath) {
      scrollToImage(data.imgpath);
      document.getElementById("imgpath").value = data.imgpath;
    }

    updateNextBtnState();
  }
 
  function initializeDragAndDrop() {
    // SECTION-LEVEL drag and drop
    document.querySelectorAll(".section-container").forEach(container => {
      container.querySelectorAll(".nested-section").forEach(section => {
        section.setAttribute("draggable", true);

        section.addEventListener("dragstart", (e) => {
          // Don't allow drag if starting inside an input-group (item)
          if (e.target.closest(".input-group")) {
            e.preventDefault();
            return;
          }

          currentDragElement = section;
          e.dataTransfer.setData("text/plain", "section");
          e.dataTransfer.effectAllowed = "move";
          section.classList.add("dragging");
        });

        section.addEventListener("dragend", () => {
          section.classList.remove("dragging");
          currentDragElement = null;
        });
      });

      container.addEventListener("dragover", (e) => {
        e.preventDefault();
        const dragging = currentDragElement;
        const target = e.target.closest(".nested-section");

        if (!dragging || !target || dragging === target || !dragging.classList.contains("nested-section")) return;

        const rect = target.getBoundingClientRect();
        const after = (e.clientY - rect.top) > rect.height / 2;
        container.insertBefore(dragging, after ? target.nextSibling : target);
      });
    });

    // ITEM-LEVEL drag and drop
    document.querySelectorAll(".nested-section").forEach(section => {
      const itemContainer = section.querySelector("[class$='-items']");
      if (!itemContainer) return;

      itemContainer.querySelectorAll(".input-group").forEach(item => {
        item.setAttribute("draggable", true);

        item.addEventListener("dragstart", (e) => {
          e.stopPropagation(); // prevent bubbling to section
          currentDragElement = item;
          e.dataTransfer.setData("text/plain", "item");
          e.dataTransfer.effectAllowed = "move";
          item.classList.add("dragging");
        });

        item.addEventListener("dragend", () => {
          item.classList.remove("dragging");
          currentDragElement = null;
        });
      });

      itemContainer.addEventListener("dragover", (e) => {
        e.preventDefault();
        const dragging = currentDragElement;
        const target = e.target.closest(".input-group");

        if (!dragging || !target || dragging === target || !dragging.classList.contains("input-group")) return;

        const rect = target.getBoundingClientRect();
        const after = (e.clientY - rect.top) > rect.height / 2;
        itemContainer.insertBefore(dragging, after ? target.nextSibling : target);
      });
    });
  }

  function addCommas(x) {
    return x.toString().replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
  }

  // Event listener to format price inputs with commas as the user types
  function attachCommaFormatting(input) {
    input.addEventListener("input", (e) => {
      const cursorPosition = input.selectionStart;
      const originalValue = input.value;
      const rawValue = removeCommas(originalValue);
      const formattedValue = addCommas(rawValue);

      input.value = formattedValue;

      // Adjust cursor position
      const newPosition = cursorPosition + (formattedValue.length - originalValue.length);
      input.setSelectionRange(newPosition, newPosition);
    });
  }

  // Helper function to remove commas from a number string
  function removeCommas(value) {
    return value.replace(/,/g, "");
  }

  /** ==========================
   * Utility Function: Prepare Form Data
   ========================== **/
  async function prepareFormData(form) {
    const formData = new FormData(form);
    const proposalId = await getOrCreateProposalId();
    console.log("Proposal ID from prepareFormData:", proposalId);
    // Filter out certain fields
    const filteredData = Array.from(formData.entries()).filter(([key, value]) => {
      // Exclude fields with specific names
      return !['investSectionName', 'investItem', 'investPrice'].includes(key);
    });
    const data = Object.fromEntries(filteredData);

    // Process numeric fields to remove commas for backend submission
    const numericFields = form.querySelectorAll('input[name="investPrice"]');
    numericFields.forEach((field) => {
      const rawValue = removeCommas(field.value);
      data[field.name] = rawValue; // Update data for submission
    });

    data.proposal = proposalId;
    console.log("data.proposal:", data.proposal);

    // Include dynamic sections (Equipment, Summary, Investment)
    data.equip = {};
    //data.summary = {Objectives: formData.get('summaryObjective'), Solutions: []};
    data.summary = {};
    data.invest = {};

    // Process Equipment Section
    const equipSections = document.querySelectorAll('.equip-room');
    equipSections.forEach((section) => {
      const roomName = section.querySelector('[name="equipRoomName"]').value.trim();
      if (roomName) {
        const items = Array.from(section.querySelectorAll('[name="equipItem"]'))
          .map((item) => item.value.trim())
          .filter((item) => item);
        if (items.length > 0) {
          data.equip[roomName] = items;
        }
      }
    });

    //// Select all dynamically added summary sections
    const summarySections = document.querySelectorAll(".summary-section");

    summarySections.forEach((section) => {
      const summaryName = section.querySelector("input.section-title")?.value.trim(); // ✅ Get section name
      if (!summaryName) return; // Skip if empty

      let textValue = ""; // Store textarea content
      let inputValues = []; // Store input values as an array

      // ✅ Find all input & textarea fields that are not disabled
      section.querySelectorAll(".summary-input, .summary-textarea").forEach((field) => {
        if (field.tagName === "TEXTAREA" && field.value.trim()) {
          textValue = field.value.trim(); // Store textarea content as string
        } else if (field.tagName === "INPUT" && field.value.trim()) {
          inputValues.push(field.value.trim()); // Store input values as array
        }
      });

      if (!data.summary) data.summary = {}; // ✅ Ensure summary object exists

      // ✅ Store textarea as string & inputs as array
      if (textValue) {
        data.summary[summaryName] = textValue; // Store textarea value as string
      } else if (inputValues.length > 0) {
        data.summary[summaryName] = inputValues; // Store inputs as an array
      }
    });

    // Process Investment Section
    const investSections = document.querySelectorAll('.invest-section');
    investSections.forEach((section) => {
      const sectionName = section.querySelector('[name="investSectionName"]').value.trim();
      if (sectionName) {
        const items = Array.from(section.querySelectorAll('[name="investItem"]'))
          .map((item) => item.value.trim())
          .filter((item) => item);

        const priceInput = section.querySelector('[name="investPrice"]');
        const price = priceInput && priceInput.value.trim() ? removeCommas(priceInput.value) : null;

        if (items.length > 0 || price) {
          data.invest[sectionName] = {
            items: items,
            ...(price ? {price} : {}) // Add price only if it's non-empty
          };
        }
      }
    });

    return data;
  }

  document.addEventListener("click", (event) => {
    if (event.target.classList.contains("contracts")) {
      const allContracts = document.querySelectorAll(".contracts");
      allContracts.forEach((contract) => {
        if (contract !== event.target) {
          contract.checked = false;
        }
      });
    }
  });

  var currentTab = 0; // Current tab is set to be the first tab (0)
  showTab(currentTab); // Display the current tab

  function updateNextBtnState() {
    // Only care when we're on tab 0 (Step 1)
    if (currentTab !== 0) return;

    const hasImage = document.getElementById("imgpath").value.trim() !== "";
    document.getElementById("nextBtn").disabled = !hasImage;
  }

  function showTab(n) {
    var tabs = document.getElementsByClassName("tab");

    for (var i = 0; i < tabs.length; i++) {
      tabs[i].style.display = "none";
    }

    tabs[n].style.display = "block";

    // Control visibility of Prev and Next buttons
    document.getElementById("prevBtn").style.display = (n === 0) ? "none" : "inline";
    document.getElementById("nextBtn").style.display = (n === tabs.length - 1) ? "none" : "inline";

    // Show Generate PDF button only on the last tab
    document.getElementById("generate-pdf").style.display = (n === tabs.length - 1) ? "inline" : "none";
    document.getElementById("generate-json").style.display = (n === tabs.length - 1) ? "inline" : "none";
  }

  function nextPrev(n) {
    var tabs = document.getElementsByClassName("tab");

    // Exit if validation fails
    if (n == 1 && !validateForm()) return false;

    // Hide the current tab
    tabs[currentTab].style.display = "none";

    // Change current tab index
    currentTab += n;

    // Ensure index doesn't go out of bounds
    if (currentTab < 0) currentTab = 0;
    if (currentTab >= tabs.length) currentTab = tabs.length - 1;

    // Show the updated tab
    showTab(currentTab);
  }

  /*function validateForm() {
    var tabs = document.getElementsByClassName("tab");
    var currentSection = tabs[currentTab]; // Get current section
    var valid = true;

    // 🟢 Select only enabled fields (either input or textarea)
    var fields = currentSection.querySelectorAll(".input-group");

    fields.forEach((group, index) => {
      // 🟢 Get the active (visible) input OR textarea inside the group
      var activeField = group.querySelector("input:not([disabled]), textarea:not([disabled])");

      if (activeField) {
        if (activeField.value.trim() === "") {
          activeField.classList.add("invalid"); // Add invalid styling
          valid = false;
          console.warn(`❌ Empty field detected: ${activeField.name || `Field #${index}`}`);
        } else {
          activeField.classList.remove("invalid"); // Remove invalid styling if corrected
        }
      } else {
        console.warn(`⚠️ No active input found in field group ${index}`);
      }
    });

    console.log(valid ? "✅ Validation Passed" : "⛔ Validation Failed");
    return valid;
  }*/

  function validateForm() {
    const tabs = document.getElementsByClassName("tab");
    const currentSection = tabs[currentTab];
    let valid = true;
  
    // Clear any existing inline alerts
    let existingAlert = document.getElementById("form-validation-alert");
    if (existingAlert) {
      existingAlert.remove();
    }
  
    // ✅ Find all enabled, visible, required inputs or textareas in the current tab
    const fields = currentSection.querySelectorAll("input[required]:not(:disabled), textarea[required]:not(:disabled)");
  
    fields.forEach((field) => {
      const style = window.getComputedStyle(field);
      if (style.display === "none" || style.visibility === "hidden") return;
  
      /*if (!field.value.trim()) {
        field.classList.add("is-invalid"); // Bootstrap red border
        valid = false;
      } else {
        field.classList.remove("is-invalid");
      }*/
      
    // ✅ Add listener to remove red border as user types
      field.addEventListener("input", () => {
        if (field.value.trim()) {
          field.classList.remove("is-invalid");
        }
      });

      // ✅ Check current value
      if (!field.value.trim()) {
        field.classList.add("is-invalid");
        valid = false;
      } else {
        field.classList.remove("is-invalid");
      }
    });
  
    if (!valid) {
      // Create inline Bootstrap alert
      const alertDiv = document.createElement("div");
      alertDiv.id = "form-validation-alert";
      alertDiv.className = "alert alert-danger alert-dismissible fade show";
      alertDiv.role = "alert";
      //alertDiv.innerText = "⚠️ Please fill out all required fields before continuing.";
      alertDiv.innerHTML = `
        <i class="bi bi-exclamation-triangle"></i>
        <strong>Please complete all required fields.</strong>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
      `;
      // Append the alert at the top of the current section (or wherever you prefer)
      currentSection.prepend(alertDiv);
    }
  
    return valid;
  }

  function addField(button, isParagraph) {
    const section = button.closest(".summary-section");
    const container = section.querySelector(".summary-items");

    if (!container) {
      console.error("Could not find the correct summary-items container.");
      return;
    }

    const sectionTitle = button.closest('.summary-section').querySelector('input.section-title').value.trim();
    const sectionKey = sectionTitle.toLowerCase().replace(/\s+/g, '_');

    if (isParagraph) {
      // Prevent adding multiple textareas
      if (container.querySelector(".summary-textarea")) {
        alert("Only one paragraph is allowed.");
        return;
      }

      const fieldDiv = document.createElement("div");
      fieldDiv.className = "input-group mb-2";
      fieldDiv.innerHTML = `
      <textarea class="form-control summary-textarea" name="${sectionKey}Area" rows="3" required></textarea>
    `;

      container.appendChild(fieldDiv);
    } else {
      const fieldDiv = document.createElement("div");
      fieldDiv.className = "input-group mb-2";
      fieldDiv.innerHTML = `
      <span class="input-group-text">Item</span>
      <input type="text" class="form-control summary-input" name="${sectionKey}Text" required />
      <button class="btn btn-danger" type="button" onclick="this.parentNode.remove()">
          <i class="bi bi-x-square-fill"></i>
      </button>
    `;

      container.appendChild(fieldDiv);
    }
  }

  // Allow users to edit section names
  function editSectionName(button) {
    var section = button.closest('.summary-section');
    var titleInput = section.querySelector('.section-title');

    titleInput.removeAttribute('disabled');
    button.style.display = 'none';
    section.querySelector('.btn-success').style.display = 'inline';
  }

  // Save section name after editing
  function saveSectionName(button) {
    var section = button.closest('.summary-section');
    var titleInput = section.querySelector('.section-title');

    titleInput.setAttribute('disabled', 'true');
    button.style.display = 'none';
    section.querySelector('.btn-secondary').style.display = 'inline';
  }

  // Toggle input/textarea fields dynamically
  function togglePar(section, isPar) {
    const sectionContainer = document.querySelector(`.summary-section input[value="${section}"]`)?.closest('.summary-section');

    if (!sectionContainer) {
      console.error("Section not found:", section);
      return;
    }

    const fieldsContainer = sectionContainer.querySelector(".summary-items");
    const addButton = sectionContainer.querySelector(".add-item-btn");

    if (!fieldsContainer) {
      console.error("Fields container not found for:", section);
      return;
    }

    fieldsContainer.innerHTML = ""; // Clear all existing inputs


    const fieldDiv = document.createElement("div");
    fieldDiv.className = "input-group mb-2";

    if (isPar) {
      // Ensure only one textarea is allowed
      fieldDiv.innerHTML = `
      <textarea class="form-control summary-textarea" name="${section.toLowerCase()}Area" rows="3" required></textarea>
    `;
      addButton.disabled = true;
    } else {
      fieldDiv.innerHTML = `
      <span class="input-group-text">Item</span>
      <input type="text" class="form-control summary-input" name="${section.toLowerCase()}Text" required />
    `;
      addButton.disabled = false;
    }

    fieldsContainer.appendChild(fieldDiv);
  }

  function toggleSection(section, isEnabled) {
    console.log(`🔹 Toggling section: ${section} -> ${isEnabled ? "Enabled" : "Disabled"}`);

    // Find the correct section container dynamically
    const sectionContainer = document.querySelector(`[data-section="${section}"]`);

    if (!sectionContainer) {
      console.error(`❌ Section container not found for: ${section}`);
      return; // Exit to prevent further errors
    }

    // Get all inputs, textareas, and buttons within the section
    const inputs = sectionContainer.querySelectorAll("input, textarea, button");
    const addButton = sectionContainer.querySelector(".add-item-btn");
    const titleInput = sectionContainer.querySelector(".section-title"); // Title should remain disabled

    // Enable or disable all fields inside the section (except the title)
    inputs.forEach((el) => {
      //if (!el.classList.contains("section-title") && !el.classList.contains("dropdown-toggle")) {
      if (!el.classList.contains("dropdown-toggle")) {
        el.disabled = !isEnabled;
      }
    });

    // Ensure "Add Item" button is properly disabled when the section is disabled
    if (addButton) {
      addButton.disabled = !isEnabled;
    }

    // Update dropdown items visibility
    const dropdownItems = sectionContainer.querySelectorAll(".enable-toggle");
    dropdownItems.forEach((item) => {
      const isEnableOption = item.textContent.includes("Enable");
      if (isEnableOption === isEnabled) {
        item.classList.add("disabled");
        item.setAttribute("aria-disabled", "true");
        item.style.pointerEvents = "none"; // Prevent click events
      } else {
        item.classList.remove("disabled");
        item.removeAttribute("aria-disabled");
        item.style.pointerEvents = "auto"; // Allow click events
      }
    });

    // Store enabled state for JSON processing
    sectionContainer.dataset.enabled = isEnabled;
  }

  document.getElementById("summaryBool").addEventListener("change", function () {
    const isEnabled = this.checked;
    console.log("isEnabled value: ", isEnabled);

    // Update every summary card so its inputs *and* dropdown reflect the new state
    document
      .querySelectorAll("#summary-section .summary-section")
      .forEach((card) => {
        const sectionName = card.dataset.section;  // e.g. "Objective"
        toggleSection(sectionName, isEnabled);     // updates fields + menu items
      });
  });

  document.getElementById("equipBool").addEventListener("change", function () {
    const equipSection = document.getElementById("equipment-section");
    const isEnabled = this.checked;

    const fields = equipSection.querySelectorAll("input, textarea, button");
    fields.forEach(field => {field.disabled = !isEnabled;});
  });

  document.getElementById("serviceBool").addEventListener("change", function () {
    const serviceSection = document.getElementById("service-section");
    const isEnabled = this.checked;

    const fields = serviceSection.querySelectorAll("input, textarea, button");
    fields.forEach(field => {field.disabled = !isEnabled;});
  });

  // ─────────────────────────────────────────────────────────────────
  // 4) Given allThumbnails[], split into chunks of four and
  //    generate a <div class="carousel-item"> … </div> for each chunk.
  //    Append those items into #carousel-inner.
  // ─────────────────────────────────────────────────────────────────

  function buildCarousel() {
    const inner = document.getElementById('carousel-inner');
    inner.innerHTML = ''; // clear any previous slides

    // 1) Break allThumbnails into groups of 4
    const chunked = [];
    for (let i = 0; i < allThumbnails.length; i += 4) {
      chunked.push(allThumbnails.slice(i, i + 4));
    }

    // 2) For each group of 4, create a <div class="carousel-item"> with a 2×2 grid
    chunked.forEach((imgs, idx) => {
      // Create the slide container; mark the first one active
      const slide = document.createElement('div');
      slide.className = 'carousel-item' + (idx === 0 ? ' active' : '');

      // Inside each slide, use a <div class="row"> so that
      // four <div class="col-6"> elements automatically wrap into two rows.
      const row = document.createElement('div');
      row.className = 'row pe-2 justify-content-center';
      row.id = "thumb-col"

      // 3) For each of the (up to) four thumbnails in this chunk:
      imgs.forEach(({ thumb, full }) => {
        // Create a half‐width column (col-6) so two images per row:
        const col = document.createElement('div');
        col.className = 'col-6';

        const img = document.createElement('img');
        img.src = thumb;
        img.alt = full;
        img.className = 'thumbnail';
        // The <img> naturally stays at 285×380 (no override in CSS)

        img.addEventListener('click', () => {
          // When clicked, record the “full” path and highlight it:
          document.getElementById('imgpath').value = full;
          inner
            .querySelectorAll('img.thumbnail')
            .forEach(i => i.classList.remove('selected'));
          img.classList.add('selected');
          updateNextBtnState();
        });

        col.appendChild(img);
        row.appendChild(col);
      });

      // 4) If this chunk has fewer than 4 images (e.g. last slide),
      //    fill empty spots so Bootstrap still reserves the right layout:
      for (let j = imgs.length; j < 4; j++) {
        const emptyCol = document.createElement('div');
        emptyCol.className = 'col-6';
        row.appendChild(emptyCol);
      }

      slide.appendChild(row);
      inner.appendChild(slide);
    });

    // 5) If there are no thumbnails at all, hide the carousel controls:
    if (allThumbnails.length === 0) {
      document
        .querySelector('#thumbnail-carousel .carousel-control-prev')
        .style.display = 'none';
      document
        .querySelector('#thumbnail-carousel .carousel-control-next')
        .style.display = 'none';
    }
  }

  function scrollToImage(fullPath) {
    // 1) Find the index of fullPath in allThumbnails[]
    const idx = allThumbnails.findIndex(obj => obj.full === fullPath);
    if (idx === -1) return; // nothing to do

    // 2) Compute which slide (0-based) holds this thumbnail
    const slideIndex = Math.floor(idx / 4);

    // 3) Get or create the Bootstrap Carousel instance
    const carouselEl = document.getElementById('thumbnail-carousel');
    let carouselInstance = bootstrap.Carousel.getInstance(carouselEl);
    if (!carouselInstance) {
      carouselInstance = new bootstrap.Carousel(carouselEl, { interval: false, wrap: true });
    }

    // Helper: highlight the correct <img> and clear others
    const applySelection = () => {
      carouselEl.querySelectorAll('img.thumbnail').forEach(img => {
        img.classList.remove('selected');
      });
      const target = carouselEl.querySelector(`img.thumbnail[alt="${fullPath}"]`);
      if (target) target.classList.add('selected');
      updateNextBtnState(); // if you need to re-enable Next/Prev buttons
    };

    // 4) Determine the current active slide index
    const items = Array.from(carouselEl.querySelectorAll('.carousel-item'));
    const currentIndex = items.findIndex(item => item.classList.contains('active'));

    if (currentIndex === slideIndex) {
      // Already on the right slide → just highlight
      applySelection();
    } else {
      // Not on the right slide → wait for it to finish sliding, then highlight
      const onSlid = () => {
        carouselEl.removeEventListener('slid.bs.carousel', onSlid);
        applySelection();
      };
      carouselEl.addEventListener('slid.bs.carousel', onSlid);
      carouselInstance.to(slideIndex);
    }
  }

  async function initStateCityZipForm() {
    const stateSelect = document.getElementById("state");
    const citySelect = document.getElementById("city");
    const zipSelect = document.getElementById("zip");

    try {
      stateCityZipData = await loadStateCityZipData('/assets/states.min.json');

      populateStateOptions(stateSelect, Object.keys(stateCityZipData));
      stateSelect.value = "MA";
      populateCitiesAndZip("MA", citySelect, zipSelect);

      // Events
      stateSelect.addEventListener("change", () => {
        populateCitiesAndZip(stateSelect.value, citySelect, zipSelect);
      });

      citySelect.addEventListener("change", () => {
        updateZipFromCity(stateSelect.value, citySelect.value, zipSelect);
      });

    } catch (err) {
      console.error("Failed to initialize form:", err);
    }
  }

  async function loadAllThumbnails() {
    allThumbnails = [];
    document.getElementById('imgpath').value = '';
    updateNextBtnState();

    try {
      // Otherwise, loop categories one by one:
      for (const category of ALL_IMAGE_CATEGORIES) {
        const res = await fetch(`/api/images?category=${category}`);
        if (!res.ok) throw new Error(`Failed to load ${category}`);
        const images = await res.json(); // expected: array of { thumb, full }
        images.forEach(imgObj => allThumbnails.push(imgObj));
      }
      buildCarousel(); // now that allThumbnails[] is filled, build slides
    } catch (err) {
      console.error('Error loading thumbnails:', err);
    }
  }

  // Loads the JSON data
  async function loadStateCityZipData(path) {
    const response = await fetch(path);
    if (!response.ok) throw new Error("Failed to load state/city data");
    return response.json();
  }

  // Populates state dropdown
  function populateStateOptions(select, states) {
    states.forEach(state => {
      const option = document.createElement("option");
      option.value = state;
      option.textContent = state;
      select.appendChild(option);
    });
  }

  // Populates city dropdown and sets ZIP
  function populateCitiesAndZip(state, citySelect, zipSelect) {
    const cities = Object.keys(stateCityZipData[state]?.cities || {});
    citySelect.innerHTML = "";

    if (cities.length === 0) {
      citySelect.disabled = true;
      zipSelect.value = "";
      return;
    }

    cities.forEach(city => {
      const option = document.createElement("option");
      option.value = city;
      option.textContent = city;
      citySelect.appendChild(option);
    });

    citySelect.disabled = false;
    citySelect.selectedIndex = 0;
    updateZipFromCity(state, citySelect.value, zipSelect);
  }

  // Updates ZIP based on selected city
  function updateZipFromCity(state, city, zipSelect) {
    const zipList = stateCityZipData[state]?.cities[city] || [];
    zipSelect.innerHTML = "";

    if (zipList.length === 0) {
      zipSelect.disabled = true;
      return;
    }

    zipList.forEach(zip => {
      const option = document.createElement("option");
      const paddedZip = String(zip).padStart(5, "0");
      option.value = paddedZip;
      option.textContent = paddedZip;
      zipSelect.appendChild(option);
    });

    zipSelect.disabled = false;
    zipSelect.selectedIndex = 0;
  }

  document.addEventListener("DOMContentLoaded", () => {
    loadAllThumbnails();
    //const defaultCategory = "business";

    //document.getElementById("img-category").value = defaultCategory;

    // Add default "Freight" section
    addInvestSection("Freight", ["SHIPPER PREPAYS FREIGHT – ADDS TO CUSTOMER INVOICE", "Due to volatility in freight charges, the shipping cost provided on this quote is an ESTIMATE only. Freight costs and the number of truckloads may change. The actual freight cost will be charged at the time of shipment OR on the final invoice."], ""); // Predefined items and empty price
    
    showTab(currentTab); // Ensure first tab is visible
    initStateCityZipForm();
    initializeDragAndDrop();

    const checkboxState = [
      {id: "summaryBool", sectionId: "summary-section"},
      {id: "serviceBool", sectionId: "service-section"}
    ];

    checkboxState.forEach(({id, sectionId}) => {
      const checkbox = document.getElementById(id);
      const section = document.getElementById(sectionId);
      if (checkbox && section) {
        const fields = section.querySelectorAll("input, textarea, button");
        fields.forEach(field => {
          field.disabled = !checkbox.checked;
        })
      }
    });

    updateNextBtnState();

    observer.observe(investmentContainer, {
      childList: true,
      subtree: true, // capture inputs added deeper in the tree
    });
  });
</script>
