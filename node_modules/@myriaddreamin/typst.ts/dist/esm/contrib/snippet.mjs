import { withPackageRegistry, withAccessModel, } from '../options.init.mjs';
import { MemoryAccessModel } from '../fs/index.mjs';
import { FetchPackageRegistry } from '../fs/package.mjs';
import { randstr } from '../utils.mjs';
const isNode = 
// @ts-ignore
typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
/**
 * Convenient util class for compiling documents, which is a wrapper of the
 * {@link TypstCompiler} and {@link TypstRenderer}.
 *
 * Note: the interface of this class is less stable than {@link TypstCompiler}
 * and {@link TypstRenderer}.
 *
 * @example
 * Use the *global shared* compiler instance:
 *
 * ```typescript
 * import { $typst } from '@myriaddreamin/typst.ts/dist/esm/contrib/snippet.mjs';
 * ```
 *
 * Note: if you want to compile multiple documents, you should create a new
 * instance for each compilation work or maintain the shared state on the
 * utility instance `$typst` carefully, because the compilation process will
 * change the state of that.
 *
 * @example
 * Create an instance of utility:
 *
 * ```typescript
 * const $typst = new TypstSnippet({
 *   // optional renderer instance
 *   renderer: enableRendering ?? (() => {
 *     return createGlobalRenderer(createTypstRenderer,
 *       undefined, initOptions);
 *   }),
 *   compiler() => {
 *     return createGlobalCompiler(createTypstCompiler,
 *       initOptions);
 *   }
 * });
 * ```
 */
export class TypstSnippet {
    /** @internal */
    mainFilePath;
    /** @internal */
    cc;
    /** @internal */
    ex;
    /**
     * Create a new instance of {@link TypstSnippet}.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     *
     * @example
     *
     * Passes a global shared compiler instance that get initialized lazily:
     * ```typescript
     * const $typst = new TypstSnippet(() => {
     *  return createGlobalCompiler(createTypstCompiler, initOptions);
     * });
     *
     */
    constructor(options) {
        this.cc = options?.compiler;
        this.ex = options?.renderer;
        this.mainFilePath = '/main.typ';
        this.providers = [];
    }
    /**
     * Set lazy initialized compiler instance for the utility instance.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     */
    setCompiler(cc) {
        this.cc = cc;
    }
    /**
     * Get an initialized compiler instance from the utility instance.
     */
    async getCompiler() {
        return (typeof this.cc === 'function' ? (this.cc = await this.cc()) : this.cc);
    }
    /**
     * Set lazy initialized renderer instance for the utility instance.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     */
    setRenderer(ex) {
        this.ex = ex;
    }
    /**
     * Get an initialized renderer instance from the utility instance.
     */
    async getRenderer() {
        return typeof this.ex === 'function' ? (this.ex = await this.ex()) : this.ex;
    }
    providers;
    /**
     * add providers for bullding the compiler or renderer component.
     */
    use(...providers) {
        if (!this.providers) {
            throw new Error('already prepare uses for instances');
        }
        this.providers.push(...providers);
    }
    /**
     * Set accessl model for the compiler instance
     * @example
     *
     * use memory access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m));
     * ```
     */
    static withAccessModel(accessModel) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [withAccessModel(accessModel)],
        };
    }
    /**
     * Set package registry for the compiler instance
     * @example
     *
     * use a customized package registry
     *
     * ```typescript
     * const n = new NodeFetchPackageRegistry();
     * $typst.use(TypstSnippet.withPackageRegistry(n));
     * ```
     */
    static withPackageRegistry(registry) {
        return {
            key: 'package-registry',
            forRoles: ['compiler'],
            provides: [withPackageRegistry(registry)],
        };
    }
    /**
     * Retrieve an access model to store the data of fetched files.
     * Provide a PackageRegistry instance for the compiler instance.
     *
     * @example
     *
     * use default (memory) access model
     *
     * ```typescript
     * $typst.use(await TypstSnippet.fetchPackageRegistry());
     * ```
     *
     * @example
     *
     * use external access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
     * ```
     */
    static fetchPackageRegistry(accessModel) {
        const m = accessModel || new MemoryAccessModel();
        const provides = [
            ...(accessModel ? [] : [withAccessModel(m)]),
            withPackageRegistry(new FetchPackageRegistry(m)),
        ];
        return {
            key: 'package-registry$fetch',
            forRoles: ['compiler'],
            provides,
        };
    }
    /**
     * Retrieve a fetcher for fetching package data.
     * Provide a PackageRegistry instance for the compiler instance.
     * @example
     *
     * use a customized fetcher
     *
     * ```typescript
     * import request from 'sync-request-curl';
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
     *   const response = request('GET', this.resolvePath(path), {
     *     insecure: true,
     *   });
     *
     *   if (response.statusCode === 200) {
     *     return response.getBody(undefined);
     *   }
     *   return undefined;
     * }));
     * ```
     */
    static fetchPackageBy(accessModel, fetcher) {
        class HttpPackageRegistry extends FetchPackageRegistry {
            pullPackageData(path) {
                return fetcher(path, this.resolvePath(path));
            }
        }
        return {
            key: 'package-registry$lambda',
            forRoles: ['compiler'],
            provides: [withPackageRegistry(new HttpPackageRegistry(accessModel))],
        };
    }
    /** @internal */
    ccOptions;
    /**
     * Set compiler init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setCompilerInitOptions(options) {
        this.requireIsUninitialized('compiler', this.cc, TypstSnippet.$buildC);
        this.ccOptions = options;
    }
    /** @internal */
    exOptions;
    /**
     * Set renderer init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setRendererInitOptions(options) {
        this.requireIsUninitialized('renderer', this.ex, TypstSnippet.$buildR);
        this.exOptions = options;
    }
    /**
     * Set shared main file path.
     */
    setMainFilePath(path) {
        this.mainFilePath = path;
    }
    /**
     * Get shared main file path.
     */
    getMainFilePath() {
        return this.mainFilePath;
    }
    removeTmp(opts) {
        if (opts.mainFilePath.startsWith('/tmp/')) {
            return this.unmapShadow(opts.mainFilePath);
        }
        return Promise.resolve();
    }
    /**
     * Add a source file to the compiler.
     * See {@link TypstCompiler#addSource}.
     */
    async addSource(path, content) {
        (await this.getCompiler()).addSource(path, content);
    }
    /**
     * Reset the shadow files.
     * Note: this function is independent to the {@link reset} function.
     * See {@link TypstCompiler#resetShadow}.
     */
    async resetShadow() {
        (await this.getCompiler()).resetShadow();
    }
    /**
     * Add a shadow file to the compiler.
     * See {@link TypstCompiler#mapShadow}.
     */
    async mapShadow(path, content) {
        (await this.getCompiler()).mapShadow(path, content);
    }
    /**
     * Remove a shadow file from the compiler.
     * See {@link TypstCompiler#unmapShadow}.
     */
    async unmapShadow(path) {
        (await this.getCompiler()).unmapShadow(path);
    }
    /**
     * Compile the document to vector (IR) format.
     * See {@link SweetCompileOptions}.
     */
    async vector(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to PDF format.
     * See {@link SweetCompileOptions}.
     */
    async pdf(o) {
        const opts = await this.getCompileOptions(o);
        opts.format = 'pdf';
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to SVG format.
     * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
     */
    async svg(o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderSvg({
            ...o,
            renderSession,
        }));
    }
    /**
     * Compile the document to canvas operations.
     * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
     */
    async canvas(container, o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderToCanvas({
            container,
            ...o,
            renderSession,
        }));
    }
    /**
     * Get semantic tokens for the document.
     */
    async query(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .query({
            ...o,
            ...opts,
        })
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Get token legend for semantic tokens.
     */
    async getSemanticTokenLegend() {
        return (await this.getCompiler()).getSemanticTokenLegend();
    }
    /**
     * Get semantic tokens for the document.
     * See {@link SweetCompileOptions}.
     * See {@link TypstCompiler#getSemanticTokens}.
     */
    async getSemanticTokens(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .getSemanticTokens({
            mainFilePath: opts.mainFilePath,
            resultId: o.resultId,
        })
            .finally(() => this.removeTmp(opts));
    }
    async getCompileOptions(opts) {
        if (opts === undefined) {
            return { mainFilePath: this.mainFilePath, diagnostics: 'none' };
        }
        else if (typeof opts === 'string') {
            throw new Error(`please specify opts as {mainContent: '...'} or {mainFilePath: '...'}`);
        }
        else if ('mainFilePath' in opts) {
            return { ...opts, diagnostics: 'none' };
        }
        else {
            const destFile = `/tmp/${randstr()}.typ`;
            await this.addSource(destFile, opts.mainContent);
            return { mainFilePath: destFile, inputs: opts.inputs, diagnostics: 'none' };
        }
    }
    async getVector(o) {
        if (o && 'vectorData' in o) {
            return o.vectorData;
        }
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    async transientRender(opts, f) {
        const rr = await this.getRenderer();
        if (!rr) {
            throw new Error('does not provide renderer instance');
        }
        const data = await this.getVector(opts);
        return await rr.runWithSession(async (session) => {
            rr.manipulateData({
                renderSession: session,
                action: 'reset',
                data,
            });
            return f(rr, session);
        });
    }
    async prepareUse() {
        if (!this.providers) {
            return;
        }
        const providers = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        this.providers = [];
        if ($typst == this &&
            !providers.some(p => p.key.includes('package-registry') || p.key.includes('access-model'))) {
            // Note: the default fetch backend always adds a withAccessModel(mem)
            if (isNode) {
                const escapeImport = new Function('m', 'return import(m)');
                try {
                    const m = new MemoryAccessModel();
                    const { default: request } = await escapeImport('sync-request');
                    $typst.use(TypstSnippet.withAccessModel(m), TypstSnippet.fetchPackageBy(m, (_, path) => {
                        const response = request('GET', path);
                        if (response.statusCode === 200) {
                            return response.getBody(undefined);
                        }
                        return undefined;
                    }));
                }
                catch (e) { }
            }
            else {
                $typst.use(TypstSnippet.fetchPackageRegistry());
            }
        }
        const providers2 = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        const ccOptions = (this.ccOptions ||= {});
        const ccBeforeBuild = (ccOptions.beforeBuild ||= []);
        const exOptions = (this.exOptions ||= {});
        const exBeforeBuild = (exOptions.beforeBuild ||= []);
        for (const provider of [...providers, ...providers2]) {
            if (provider.forRoles.includes('compiler')) {
                this.requireIsUninitialized('compiler', this.cc, TypstSnippet.$buildC);
                ccBeforeBuild.push(...provider.provides);
            }
            if (provider.forRoles.includes('renderer')) {
                this.requireIsUninitialized('renderer', this.ex, TypstSnippet.$buildR);
                exBeforeBuild.push(...provider.provides);
            }
        }
        this.providers = undefined;
    }
    requireIsUninitialized(role, c, e) {
        if (typeof c !== 'function') {
            throw new Error(`${role} has been initialized: ${c}`);
        }
        if (e && c != e) {
            throw new Error(`${role} instance is set to non default value`);
        }
    }
    /** @internal */
    static async $buildC() {
        // lazy import compile module
        const { createGlobalCompiler } = (await import('@myriaddreamin/typst.ts/dist/esm/contrib/global-compiler.mjs'));
        const { createTypstCompiler } = (await import('@myriaddreamin/typst.ts/dist/esm/compiler.mjs'));
        await this.prepareUse();
        return createGlobalCompiler(createTypstCompiler, this.ccOptions);
    }
    /** @internal */
    static async $buildR() {
        // lazy import renderer module
        const { createGlobalRenderer } = (await import('@myriaddreamin/typst.ts/dist/esm/contrib/global-renderer.mjs'));
        const { createTypstRenderer } = (await import('@myriaddreamin/typst.ts/dist/esm/renderer.mjs'));
        await this.prepareUse();
        return createGlobalRenderer(createTypstRenderer, this.exOptions);
    }
}
/**
 * The lazy initialized global shared instance of {@link TypstSnippet}. See
 * {@link TypstSnippet} for more details.
 */
export const $typst = new TypstSnippet({
    compiler: TypstSnippet.$buildC,
    renderer: TypstSnippet.$buildR,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25pcHBldC5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJpYi9zbmlwcGV0Lm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLGVBQWUsR0FJaEIsTUFBTSxxQkFBcUIsQ0FBQztBQUc3QixPQUFPLEVBQUUsaUJBQWlCLEVBQTRCLE1BQU0saUJBQWlCLENBQUM7QUFDOUUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFPekQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQStEdkMsTUFBTSxNQUFNO0FBQ1YsYUFBYTtBQUNiLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxPQUFPLENBQUMsUUFBUSxJQUFJLElBQUksSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUM7QUFFOUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUNHO0FBQ0gsTUFBTSxPQUFPLFlBQVk7SUFDdkIsZ0JBQWdCO0lBQ1IsWUFBWSxDQUFTO0lBQzdCLGdCQUFnQjtJQUNSLEVBQUUsQ0FBOEI7SUFDeEMsZ0JBQWdCO0lBQ1IsRUFBRSxDQUE4QjtJQUV4Qzs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFBWSxPQUdYO1FBQ0MsSUFBSSxDQUFDLEVBQUUsR0FBRyxPQUFPLEVBQUUsUUFBUSxDQUFDO1FBQzVCLElBQUksQ0FBQyxFQUFFLEdBQUcsT0FBTyxFQUFFLFFBQVEsQ0FBQztRQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsV0FBVyxDQUFDLEVBQThCO1FBQ3hDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFdBQVc7UUFDZixPQUFPLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUUsQ0FBQztJQUNsRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsV0FBVyxDQUFDLEVBQThCO1FBQ3hDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFdBQVc7UUFDZixPQUFPLE9BQU8sSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQy9FLENBQUM7SUFFTyxTQUFTLENBQXVDO0lBQ3hEOztPQUVHO0lBQ0gsR0FBRyxDQUFDLEdBQUcsU0FBOEM7UUFDbkQsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1NBQ3ZEO1FBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILE1BQU0sQ0FBQyxlQUFlLENBQUMsV0FBZ0M7UUFDckQsT0FBTztZQUNMLEdBQUcsRUFBRSxjQUFjO1lBQ25CLFFBQVEsRUFBRSxDQUFDLFVBQVUsQ0FBQztZQUN0QixRQUFRLEVBQUUsQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDekMsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFFBQXlCO1FBQ2xELE9BQU87WUFDTCxHQUFHLEVBQUUsa0JBQWtCO1lBQ3ZCLFFBQVEsRUFBRSxDQUFDLFVBQVUsQ0FBQztZQUN0QixRQUFRLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMxQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9CRztJQUNILE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxXQUFpQztRQUMzRCxNQUFNLENBQUMsR0FBRyxXQUFXLElBQUksSUFBSSxpQkFBaUIsRUFBRSxDQUFDO1FBQ2pELE1BQU0sUUFBUSxHQUFHO1lBQ2YsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVDLG1CQUFtQixDQUFDLElBQUksb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQsQ0FBQztRQUNGLE9BQU87WUFDTCxHQUFHLEVBQUUsd0JBQXdCO1lBQzdCLFFBQVEsRUFBRSxDQUFDLFVBQVUsQ0FBQztZQUN0QixRQUFRO1NBQ1QsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJHO0lBQ0gsTUFBTSxDQUFDLGNBQWMsQ0FDbkIsV0FBZ0MsRUFDaEMsT0FBOEU7UUFFOUUsTUFBTSxtQkFBb0IsU0FBUSxvQkFBb0I7WUFDcEQsZUFBZSxDQUFDLElBQWlCO2dCQUMvQixPQUFPLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQy9DLENBQUM7U0FDRjtRQUNELE9BQU87WUFDTCxHQUFHLEVBQUUseUJBQXlCO1lBQzlCLFFBQVEsRUFBRSxDQUFDLFVBQVUsQ0FBQztZQUN0QixRQUFRLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7U0FDdEUsQ0FBQztJQUNKLENBQUM7SUFFRCxnQkFBZ0I7SUFDaEIsU0FBUyxDQUF1QjtJQUNoQzs7O09BR0c7SUFDSCxzQkFBc0IsQ0FBQyxPQUE2QjtRQUNsRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO0lBQzNCLENBQUM7SUFFRCxnQkFBZ0I7SUFDaEIsU0FBUyxDQUF1QjtJQUNoQzs7O09BR0c7SUFDSCxzQkFBc0IsQ0FBQyxPQUE2QjtRQUNsRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNILGVBQWUsQ0FBQyxJQUFZO1FBQzFCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNILGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUVELFNBQVMsQ0FBQyxJQUFvQjtRQUM1QixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3pDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDNUM7UUFFRCxPQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFZLEVBQUUsT0FBZTtRQUMzQyxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxXQUFXO1FBQ2YsQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFDLElBQVksRUFBRSxPQUFtQjtRQUMvQyxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFZO1FBQzVCLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBdUI7UUFDbEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUM7YUFDYixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO2FBQ3ZCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBdUI7UUFDL0IsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUM7YUFDYixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO2FBQ3ZCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBeUM7UUFDakQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxhQUFhLEVBQUUsRUFBRSxDQUN6RCxRQUFRLENBQUMsU0FBUyxDQUFDO1lBQ2pCLEdBQUcsQ0FBQztZQUNKLGFBQWE7U0FDZCxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsTUFBTSxDQUNWLFNBQXNCLEVBQ3RCLENBQWlFO1FBRWpFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsYUFBYSxFQUFFLEVBQUUsQ0FDekQsUUFBUSxDQUFDLGNBQWMsQ0FBQztZQUN0QixTQUFTO1lBQ1QsR0FBRyxDQUFDO1lBQ0osYUFBYTtTQUNkLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLEtBQUssQ0FBSSxDQUE2RDtRQUMxRSxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QyxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDOUIsS0FBSyxDQUFJO1lBQ1IsR0FBRyxDQUFDO1lBQ0osR0FBRyxJQUFJO1NBQ1IsQ0FBQzthQUNELE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLHNCQUFzQjtRQUMxQixPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQzdELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQThDO1FBQ3BFLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUM5QixpQkFBaUIsQ0FBQztZQUNqQixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDL0IsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRO1NBQ3JCLENBQUM7YUFDRCxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFTyxLQUFLLENBQUMsaUJBQWlCLENBQzdCLElBQTBCO1FBRTFCLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUN0QixPQUFPLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxDQUFDO1NBQ2pFO2FBQU0sSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO1NBQ3pGO2FBQU0sSUFBSSxjQUFjLElBQUksSUFBSSxFQUFFO1lBQ2pDLE9BQU8sRUFBRSxHQUFHLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLENBQUM7U0FDekM7YUFBTTtZQUNMLE1BQU0sUUFBUSxHQUFHLFFBQVEsT0FBTyxFQUFFLE1BQU0sQ0FBQztZQUN6QyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNqRCxPQUFPLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLENBQUM7U0FDN0U7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFzQjtRQUM1QyxJQUFJLENBQUMsSUFBSSxZQUFZLElBQUksQ0FBQyxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQztTQUNyQjtRQUVELE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUM5QixPQUFPLENBQUMsSUFBSSxDQUFDO2FBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU8sQ0FBQzthQUN4QixPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFTyxLQUFLLENBQUMsZUFBZSxDQUMzQixJQUFvQyxFQUNwQyxDQUFtRDtRQUVuRCxNQUFNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNwQyxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ1AsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1NBQ3ZEO1FBQ0QsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBQyxPQUFPLEVBQUMsRUFBRTtZQUM3QyxFQUFFLENBQUMsY0FBYyxDQUFDO2dCQUNoQixhQUFhLEVBQUUsT0FBTztnQkFDdEIsTUFBTSxFQUFFLE9BQU87Z0JBQ2YsSUFBSTthQUNMLENBQUMsQ0FBQztZQUNILE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN4QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxLQUFLLENBQUMsVUFBVTtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNuQixPQUFPO1NBQ1I7UUFFRCxNQUFNLFNBQVMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUM3RCxDQUFDO1FBQ0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFFcEIsSUFDRSxNQUFNLElBQUksSUFBSTtZQUNkLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsRUFDMUY7WUFDQSxxRUFBcUU7WUFDckUsSUFBSSxNQUFNLEVBQUU7Z0JBQ1YsTUFBTSxZQUFZLEdBQUcsSUFBSSxRQUFRLENBQUMsR0FBRyxFQUFFLGtCQUFrQixDQUFDLENBQUM7Z0JBQzNELElBQUk7b0JBQ0YsTUFBTSxDQUFDLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO29CQUNsQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxHQUFHLE1BQU0sWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDO29CQUVoRSxNQUFNLENBQUMsR0FBRyxDQUNSLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEVBQy9CLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBVSxFQUFFLElBQVksRUFBRSxFQUFFO3dCQUMxRCxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO3dCQUV0QyxJQUFJLFFBQVEsQ0FBQyxVQUFVLEtBQUssR0FBRyxFQUFFOzRCQUMvQixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7eUJBQ3BDO3dCQUNELE9BQU8sU0FBUyxDQUFDO29CQUNuQixDQUFDLENBQUMsQ0FDSCxDQUFDO2lCQUNIO2dCQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUU7YUFDZjtpQkFBTTtnQkFDTCxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUM7YUFDakQ7U0FDRjtRQUVELE1BQU0sVUFBVSxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzdELENBQUM7UUFFRixNQUFNLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDMUMsTUFBTSxhQUFhLEdBQUcsQ0FBQyxTQUFTLENBQUMsV0FBVyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBRXJELE1BQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUMxQyxNQUFNLGFBQWEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFckQsS0FBSyxNQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxFQUFFLEdBQUcsVUFBVSxDQUFDLEVBQUU7WUFDcEQsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDMUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDdkUsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMxQztZQUNELElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3ZFLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUM7U0FDRjtRQUNELElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzdCLENBQUM7SUFFTyxzQkFBc0IsQ0FBSSxJQUFZLEVBQUUsQ0FBaUIsRUFBRSxDQUFrQjtRQUNuRixJQUFJLE9BQU8sQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSwwQkFBMEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN2RDtRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSx1Q0FBdUMsQ0FBQyxDQUFDO1NBQ2pFO0lBQ0gsQ0FBQztJQUVELGdCQUFnQjtJQUNoQixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU87UUFDbEIsNkJBQTZCO1FBQzdCLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQzVDLDhEQUE4RCxDQUMvRCxDQUFrRCxDQUFDO1FBQ3BELE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQzNDLCtDQUErQyxDQUNoRCxDQUE0QyxDQUFDO1FBRTlDLE1BQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sb0JBQW9CLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxnQkFBZ0I7SUFDaEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPO1FBQ2xCLDhCQUE4QjtRQUM5QixNQUFNLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxDQUFDLE1BQU0sTUFBTSxDQUM1Qyw4REFBOEQsQ0FDL0QsQ0FBa0QsQ0FBQztRQUNwRCxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxDQUFDLE1BQU0sTUFBTSxDQUMzQywrQ0FBK0MsQ0FDaEQsQ0FBNEMsQ0FBQztRQUU5QyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN4QixPQUFPLG9CQUFvQixDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUM7SUFDckMsUUFBUSxFQUFFLFlBQVksQ0FBQyxPQUFPO0lBQzlCLFFBQVEsRUFBRSxZQUFZLENBQUMsT0FBTztDQUMvQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENvbXBpbGVPcHRpb25zLCBUeXBzdENvbXBpbGVyIH0gZnJvbSAnLi4vY29tcGlsZXIubWpzJztcclxuaW1wb3J0IHtcclxuICB3aXRoUGFja2FnZVJlZ2lzdHJ5LFxyXG4gIHdpdGhBY2Nlc3NNb2RlbCxcclxuICB0eXBlIEJlZm9yZUJ1aWxkRm4sXHJcbiAgdHlwZSBJbml0T3B0aW9ucyxcclxuICBwcmVsb2FkRm9udEFzc2V0cyxcclxufSBmcm9tICcuLi9vcHRpb25zLmluaXQubWpzJztcclxuaW1wb3J0IHR5cGUgeyBUeXBzdFJlbmRlcmVyLCBSZW5kZXJTZXNzaW9uIH0gZnJvbSAnLi4vcmVuZGVyZXIubWpzJztcclxuaW1wb3J0IHR5cGUgeyBSZW5kZXJUb0NhbnZhc09wdGlvbnMsIFJlbmRlclN2Z09wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zLnJlbmRlci5tanMnO1xyXG5pbXBvcnQgeyBNZW1vcnlBY2Nlc3NNb2RlbCwgdHlwZSBXcml0YWJsZUFjY2Vzc01vZGVsIH0gZnJvbSAnLi4vZnMvaW5kZXgubWpzJztcclxuaW1wb3J0IHsgRmV0Y2hQYWNrYWdlUmVnaXN0cnkgfSBmcm9tICcuLi9mcy9wYWNrYWdlLm1qcyc7XHJcbmltcG9ydCB7XHJcbiAgUGFja2FnZVJlZ2lzdHJ5LFxyXG4gIFBhY2thZ2VTcGVjLFxyXG4gIFNlbWFudGljVG9rZW5zLFxyXG4gIFNlbWFudGljVG9rZW5zTGVnZW5kLFxyXG59IGZyb20gJy4uL2ludGVybmFsLnR5cGVzLm1qcyc7XHJcbmltcG9ydCB7IHJhbmRzdHIgfSBmcm9tICcuLi91dGlscy5tanMnO1xyXG5cclxuLyoqXHJcbiAqIFNvbWUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSBvZiB2YWx1ZSBvciBqdXN0IHRoYXQgdmFsdWUuXHJcbiAqL1xyXG50eXBlIFByb21pc2VKdXN0PFQ+ID0gKCgpID0+IFByb21pc2U8VD4pIHwgVDtcclxuXHJcbmludGVyZmFjZSBDb21waWxlT3B0aW9uc0NvbW1vbiB7XHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHN0cmluZyBrZXktdmFsdWUgcGFpciB2aXNpYmxlIHRocm91Z2ggYHN5cy5pbnB1dHNgXHJcbiAgICpcclxuICAgKiBOb3RlOiBwYXNzIGB7fWAgdG8gY2xlYXIgYHN5cy5pbnB1dHNgXHJcbiAgICpcclxuICAgKiBOb3RlOiBXaGVuIHBhc3NpbmcgYHVuZGVmaW5lZGAsIGNvbXBpbGVyIHdpbGwgdXNlIGxhc3Qgc2V0IGBzeXMuaW5wdXRzYC5cclxuICAgKlxyXG4gICAqIE5vdGU6IFRoaXMgbWVhbnMgeW91IHNob3VsZCBhbHdheXMgc3BlY2lmeSBpbnB1dHMgd2hlbiB1c2luZyBjb21waWxlciBmb3IgY29uY3VycmVudCB0YXNrcy5cclxuICAgKi9cclxuICBpbnB1dHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIHN3ZWV0IG9wdGlvbnMgZm9yIGNvbXBpbGluZyBhbmQgcmVuZGVyaW5nIHRoZSBkb2N1bWVudC5cclxuICovXHJcbmV4cG9ydCB0eXBlIFN3ZWV0Q29tcGlsZU9wdGlvbnMgPSAoXHJcbiAgfCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgcGF0aCBvZiB0aGUgbWFpbiBmaWxlLlxyXG4gICAgICAgKi9cclxuICAgICAgbWFpbkZpbGVQYXRoOiBzdHJpbmc7XHJcbiAgICB9XHJcbiAgfCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgc291cmNlIGNvbnRlbnQgb2YgdGhlIG1haW4gZmlsZS5cclxuICAgICAgICovXHJcbiAgICAgIG1haW5Db250ZW50OiBzdHJpbmc7XHJcbiAgICB9XHJcbikgJlxyXG4gIENvbXBpbGVPcHRpb25zQ29tbW9uO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzd2VldCBvcHRpb25zIGZvciBjb21waWxpbmcgYW5kIHJlbmRlcmluZyB0aGUgZG9jdW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTd2VldFJlbmRlck9wdGlvbnMgPVxyXG4gIHwgU3dlZXRDb21waWxlT3B0aW9uc1xyXG4gIHwge1xyXG4gICAgICAvKipcclxuICAgICAgICogVGhlIGFydGlmYWN0IGRhdGEgaW4gdmVjdG9yIGZvcm1hdC5cclxuICAgICAgICovXHJcbiAgICAgIHZlY3RvckRhdGE6IFVpbnQ4QXJyYXk7XHJcbiAgICB9O1xyXG5cclxudHlwZSBSb2xlID0gJ2NvbXBpbGVyJyB8ICdyZW5kZXJlcic7XHJcblxyXG4vKipcclxuICogVGhlIHN3ZWV0IHNuaXBwZXQgcHJvdmlkZXIgZm9yIGJ1bGxkaW5nIHRoZSBjb21waWxlciBvciByZW5kZXJlciBjb21wb25lbnQuXHJcbiAqIFNlZSB7QGxpbmsgVHlwc3RTbmlwcGV0I3VzZX0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gIGtleTogc3RyaW5nO1xyXG4gIGZvclJvbGVzOiBSb2xlW107XHJcbiAgcHJvdmlkZXM6IEJlZm9yZUJ1aWxkRm5bXTtcclxufVxyXG5cclxuY29uc3QgaXNOb2RlID1cclxuICAvLyBAdHMtaWdub3JlXHJcbiAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZW5pZW50IHV0aWwgY2xhc3MgZm9yIGNvbXBpbGluZyBkb2N1bWVudHMsIHdoaWNoIGlzIGEgd3JhcHBlciBvZiB0aGVcclxuICoge0BsaW5rIFR5cHN0Q29tcGlsZXJ9IGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAqXHJcbiAqIE5vdGU6IHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBjbGFzcyBpcyBsZXNzIHN0YWJsZSB0aGFuIHtAbGluayBUeXBzdENvbXBpbGVyfVxyXG4gKiBhbmQge0BsaW5rIFR5cHN0UmVuZGVyZXJ9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBVc2UgdGhlICpnbG9iYWwgc2hhcmVkKiBjb21waWxlciBpbnN0YW5jZTpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQgeyAkdHlwc3QgfSBmcm9tICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9kaXN0L2VzbS9jb250cmliL3NuaXBwZXQubWpzJztcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGU6IGlmIHlvdSB3YW50IHRvIGNvbXBpbGUgbXVsdGlwbGUgZG9jdW1lbnRzLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG5ld1xyXG4gKiBpbnN0YW5jZSBmb3IgZWFjaCBjb21waWxhdGlvbiB3b3JrIG9yIG1haW50YWluIHRoZSBzaGFyZWQgc3RhdGUgb24gdGhlXHJcbiAqIHV0aWxpdHkgaW5zdGFuY2UgYCR0eXBzdGAgY2FyZWZ1bGx5LCBiZWNhdXNlIHRoZSBjb21waWxhdGlvbiBwcm9jZXNzIHdpbGxcclxuICogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGF0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdXRpbGl0eTpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCAkdHlwc3QgPSBuZXcgVHlwc3RTbmlwcGV0KHtcclxuICogICAvLyBvcHRpb25hbCByZW5kZXJlciBpbnN0YW5jZVxyXG4gKiAgIHJlbmRlcmVyOiBlbmFibGVSZW5kZXJpbmcgPz8gKCgpID0+IHtcclxuICogICAgIHJldHVybiBjcmVhdGVHbG9iYWxSZW5kZXJlcihjcmVhdGVUeXBzdFJlbmRlcmVyLFxyXG4gKiAgICAgICB1bmRlZmluZWQsIGluaXRPcHRpb25zKTtcclxuICogICB9KSxcclxuICogICBjb21waWxlcigpID0+IHtcclxuICogICAgIHJldHVybiBjcmVhdGVHbG9iYWxDb21waWxlcihjcmVhdGVUeXBzdENvbXBpbGVyLFxyXG4gKiAgICAgICBpbml0T3B0aW9ucyk7XHJcbiAqICAgfVxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHlwc3RTbmlwcGV0IHtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHJpdmF0ZSBtYWluRmlsZVBhdGg6IHN0cmluZztcclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHJpdmF0ZSBjYz86IFByb21pc2VKdXN0PFR5cHN0Q29tcGlsZXI+O1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwcml2YXRlIGV4PzogUHJvbWlzZUp1c3Q8VHlwc3RSZW5kZXJlcj47XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHlwc3RTbmlwcGV0fS5cclxuICAgKiBAcGFyYW0gY2MgdGhlIGNvbXBpbGVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0Q29tcGlsZXJ9LlxyXG4gICAqIEBwYXJhbSBleCB0aGUgcmVuZGVyZXIgaW5zdGFuY2UsIHNlZSB7QGxpbmsgUHJvbWlzZUp1c3R9IGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogUGFzc2VzIGEgZ2xvYmFsIHNoYXJlZCBjb21waWxlciBpbnN0YW5jZSB0aGF0IGdldCBpbml0aWFsaXplZCBsYXppbHk6XHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0ICR0eXBzdCA9IG5ldyBUeXBzdFNuaXBwZXQoKCkgPT4ge1xyXG4gICAqICByZXR1cm4gY3JlYXRlR2xvYmFsQ29tcGlsZXIoY3JlYXRlVHlwc3RDb21waWxlciwgaW5pdE9wdGlvbnMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IHtcclxuICAgIGNvbXBpbGVyPzogUHJvbWlzZUp1c3Q8VHlwc3RDb21waWxlcj47XHJcbiAgICByZW5kZXJlcj86IFByb21pc2VKdXN0PFR5cHN0UmVuZGVyZXI+O1xyXG4gIH0pIHtcclxuICAgIHRoaXMuY2MgPSBvcHRpb25zPy5jb21waWxlcjtcclxuICAgIHRoaXMuZXggPSBvcHRpb25zPy5yZW5kZXJlcjtcclxuICAgIHRoaXMubWFpbkZpbGVQYXRoID0gJy9tYWluLnR5cCc7XHJcbiAgICB0aGlzLnByb3ZpZGVycyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGxhenkgaW5pdGlhbGl6ZWQgY29tcGlsZXIgaW5zdGFuY2UgZm9yIHRoZSB1dGlsaXR5IGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSBjYyB0aGUgY29tcGlsZXIgaW5zdGFuY2UsIHNlZSB7QGxpbmsgUHJvbWlzZUp1c3R9IGFuZCB7QGxpbmsgVHlwc3RDb21waWxlcn0uXHJcbiAgICovXHJcbiAgc2V0Q29tcGlsZXIoY2M6IFByb21pc2VKdXN0PFR5cHN0Q29tcGlsZXI+KSB7XHJcbiAgICB0aGlzLmNjID0gY2M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYW4gaW5pdGlhbGl6ZWQgY29tcGlsZXIgaW5zdGFuY2UgZnJvbSB0aGUgdXRpbGl0eSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBhc3luYyBnZXRDb21waWxlcigpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHRoaXMuY2MgPT09ICdmdW5jdGlvbicgPyAodGhpcy5jYyA9IGF3YWl0IHRoaXMuY2MoKSkgOiB0aGlzLmNjKSE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgbGF6eSBpbml0aWFsaXplZCByZW5kZXJlciBpbnN0YW5jZSBmb3IgdGhlIHV0aWxpdHkgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIGV4IHRoZSByZW5kZXJlciBpbnN0YW5jZSwgc2VlIHtAbGluayBQcm9taXNlSnVzdH0gYW5kIHtAbGluayBUeXBzdFJlbmRlcmVyfS5cclxuICAgKi9cclxuICBzZXRSZW5kZXJlcihleDogUHJvbWlzZUp1c3Q8VHlwc3RSZW5kZXJlcj4pIHtcclxuICAgIHRoaXMuZXggPSBleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBpbml0aWFsaXplZCByZW5kZXJlciBpbnN0YW5jZSBmcm9tIHRoZSB1dGlsaXR5IGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFJlbmRlcmVyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmV4ID09PSAnZnVuY3Rpb24nID8gKHRoaXMuZXggPSBhd2FpdCB0aGlzLmV4KCkpIDogdGhpcy5leDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcHJvdmlkZXJzPzogUHJvbWlzZUp1c3Q8VHlwc3RTbmlwcGV0UHJvdmlkZXI+W107XHJcbiAgLyoqXHJcbiAgICogYWRkIHByb3ZpZGVycyBmb3IgYnVsbGRpbmcgdGhlIGNvbXBpbGVyIG9yIHJlbmRlcmVyIGNvbXBvbmVudC5cclxuICAgKi9cclxuICB1c2UoLi4ucHJvdmlkZXJzOiBQcm9taXNlSnVzdDxUeXBzdFNuaXBwZXRQcm92aWRlcj5bXSkge1xyXG4gICAgaWYgKCF0aGlzLnByb3ZpZGVycykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgcHJlcGFyZSB1c2VzIGZvciBpbnN0YW5jZXMnKTtcclxuICAgIH1cclxuICAgIHRoaXMucHJvdmlkZXJzLnB1c2goLi4ucHJvdmlkZXJzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhY2Nlc3NsIG1vZGVsIGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2VcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIG1lbW9yeSBhY2Nlc3MgbW9kZWxcclxuICAgKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBtID0gbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBzdGF0aWMgd2l0aEFjY2Vzc01vZGVsKGFjY2Vzc01vZGVsOiBXcml0YWJsZUFjY2Vzc01vZGVsKTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiAnYWNjZXNzLW1vZGVsJyxcclxuICAgICAgZm9yUm9sZXM6IFsnY29tcGlsZXInXSxcclxuICAgICAgcHJvdmlkZXM6IFt3aXRoQWNjZXNzTW9kZWwoYWNjZXNzTW9kZWwpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcGFja2FnZSByZWdpc3RyeSBmb3IgdGhlIGNvbXBpbGVyIGluc3RhbmNlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBhIGN1c3RvbWl6ZWQgcGFja2FnZSByZWdpc3RyeVxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IG4gPSBuZXcgTm9kZUZldGNoUGFja2FnZVJlZ2lzdHJ5KCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aFBhY2thZ2VSZWdpc3RyeShuKSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgc3RhdGljIHdpdGhQYWNrYWdlUmVnaXN0cnkocmVnaXN0cnk6IFBhY2thZ2VSZWdpc3RyeSk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ3BhY2thZ2UtcmVnaXN0cnknLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3dpdGhQYWNrYWdlUmVnaXN0cnkocmVnaXN0cnkpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBhbiBhY2Nlc3MgbW9kZWwgdG8gc3RvcmUgdGhlIGRhdGEgb2YgZmV0Y2hlZCBmaWxlcy5cclxuICAgKiBQcm92aWRlIGEgUGFja2FnZVJlZ2lzdHJ5IGluc3RhbmNlIGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIGRlZmF1bHQgKG1lbW9yeSkgYWNjZXNzIG1vZGVsXHJcbiAgICpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogJHR5cHN0LnVzZShhd2FpdCBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlUmVnaXN0cnkoKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIGV4dGVybmFsIGFjY2VzcyBtb2RlbFxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IG0gPSBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgKiAkdHlwc3QudXNlKFR5cHN0U25pcHBldC53aXRoQWNjZXNzTW9kZWwobSksIGF3YWl0IFR5cHN0U25pcHBldC5mZXRjaFBhY2thZ2VSZWdpc3RyeShtKSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgc3RhdGljIGZldGNoUGFja2FnZVJlZ2lzdHJ5KGFjY2Vzc01vZGVsPzogV3JpdGFibGVBY2Nlc3NNb2RlbCk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIGNvbnN0IG0gPSBhY2Nlc3NNb2RlbCB8fCBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgIGNvbnN0IHByb3ZpZGVzID0gW1xyXG4gICAgICAuLi4oYWNjZXNzTW9kZWwgPyBbXSA6IFt3aXRoQWNjZXNzTW9kZWwobSldKSxcclxuICAgICAgd2l0aFBhY2thZ2VSZWdpc3RyeShuZXcgRmV0Y2hQYWNrYWdlUmVnaXN0cnkobSkpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ3BhY2thZ2UtcmVnaXN0cnkkZmV0Y2gnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlcyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBhIGZldGNoZXIgZm9yIGZldGNoaW5nIHBhY2thZ2UgZGF0YS5cclxuICAgKiBQcm92aWRlIGEgUGFja2FnZVJlZ2lzdHJ5IGluc3RhbmNlIGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2UuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBhIGN1c3RvbWl6ZWQgZmV0Y2hlclxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGltcG9ydCByZXF1ZXN0IGZyb20gJ3N5bmMtcmVxdWVzdC1jdXJsJztcclxuICAgKiBjb25zdCBtID0gbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pLCBhd2FpdCBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlQnkobSwgKF8sIGh0dHBVcmwpID0+IHtcclxuICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdCgnR0VUJywgdGhpcy5yZXNvbHZlUGF0aChwYXRoKSwge1xyXG4gICAqICAgICBpbnNlY3VyZTogdHJ1ZSxcclxuICAgKiAgIH0pO1xyXG4gICAqXHJcbiAgICogICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XHJcbiAgICogICAgIHJldHVybiByZXNwb25zZS5nZXRCb2R5KHVuZGVmaW5lZCk7XHJcbiAgICogICB9XHJcbiAgICogICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAqIH0pKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBzdGF0aWMgZmV0Y2hQYWNrYWdlQnkoXHJcbiAgICBhY2Nlc3NNb2RlbDogV3JpdGFibGVBY2Nlc3NNb2RlbCxcclxuICAgIGZldGNoZXI6IChwYXRoOiBQYWNrYWdlU3BlYywgZGVmYXVsdEh0dHBVcmw6IHN0cmluZykgPT4gVWludDhBcnJheSB8IHVuZGVmaW5lZCxcclxuICApOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICBjbGFzcyBIdHRwUGFja2FnZVJlZ2lzdHJ5IGV4dGVuZHMgRmV0Y2hQYWNrYWdlUmVnaXN0cnkge1xyXG4gICAgICBwdWxsUGFja2FnZURhdGEocGF0aDogUGFja2FnZVNwZWMpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICByZXR1cm4gZmV0Y2hlcihwYXRoLCB0aGlzLnJlc29sdmVQYXRoKHBhdGgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiAncGFja2FnZS1yZWdpc3RyeSRsYW1iZGEnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3dpdGhQYWNrYWdlUmVnaXN0cnkobmV3IEh0dHBQYWNrYWdlUmVnaXN0cnkoYWNjZXNzTW9kZWwpKV0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGNjT3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz47XHJcbiAgLyoqXHJcbiAgICogU2V0IGNvbXBpbGVyIGluaXQgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIGdsb2JhbCBpbnN0YW5jZSB7QGxpbmsgJHR5cHN0fS5cclxuICAgKiBTZWUge0BsaW5rIEluaXRPcHRpb25zfS5cclxuICAgKi9cclxuICBzZXRDb21waWxlckluaXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8SW5pdE9wdGlvbnM+KSB7XHJcbiAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ2NvbXBpbGVyJywgdGhpcy5jYywgVHlwc3RTbmlwcGV0LiRidWlsZEMpO1xyXG4gICAgdGhpcy5jY09wdGlvbnMgPSBvcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGV4T3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz47XHJcbiAgLyoqXHJcbiAgICogU2V0IHJlbmRlcmVyIGluaXQgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIGdsb2JhbCBpbnN0YW5jZSB7QGxpbmsgJHR5cHN0fS5cclxuICAgKiBTZWUge0BsaW5rIEluaXRPcHRpb25zfS5cclxuICAgKi9cclxuICBzZXRSZW5kZXJlckluaXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8SW5pdE9wdGlvbnM+KSB7XHJcbiAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ3JlbmRlcmVyJywgdGhpcy5leCwgVHlwc3RTbmlwcGV0LiRidWlsZFIpO1xyXG4gICAgdGhpcy5leE9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHNoYXJlZCBtYWluIGZpbGUgcGF0aC5cclxuICAgKi9cclxuICBzZXRNYWluRmlsZVBhdGgocGF0aDogc3RyaW5nKSB7XHJcbiAgICB0aGlzLm1haW5GaWxlUGF0aCA9IHBhdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc2hhcmVkIG1haW4gZmlsZSBwYXRoLlxyXG4gICAqL1xyXG4gIGdldE1haW5GaWxlUGF0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1haW5GaWxlUGF0aDtcclxuICB9XHJcblxyXG4gIHJlbW92ZVRtcChvcHRzOiBDb21waWxlT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKG9wdHMubWFpbkZpbGVQYXRoLnN0YXJ0c1dpdGgoJy90bXAvJykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudW5tYXBTaGFkb3cob3B0cy5tYWluRmlsZVBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNvdXJjZSBmaWxlIHRvIHRoZSBjb21waWxlci5cclxuICAgKiBTZWUge0BsaW5rIFR5cHN0Q29tcGlsZXIjYWRkU291cmNlfS5cclxuICAgKi9cclxuICBhc3luYyBhZGRTb3VyY2UocGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpIHtcclxuICAgIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpLmFkZFNvdXJjZShwYXRoLCBjb250ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBzaGFkb3cgZmlsZXMuXHJcbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBpcyBpbmRlcGVuZGVudCB0byB0aGUge0BsaW5rIHJlc2V0fSBmdW5jdGlvbi5cclxuICAgKiBTZWUge0BsaW5rIFR5cHN0Q29tcGlsZXIjcmVzZXRTaGFkb3d9LlxyXG4gICAqL1xyXG4gIGFzeW5jIHJlc2V0U2hhZG93KCkge1xyXG4gICAgKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSkucmVzZXRTaGFkb3coKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNoYWRvdyBmaWxlIHRvIHRoZSBjb21waWxlci5cclxuICAgKiBTZWUge0BsaW5rIFR5cHN0Q29tcGlsZXIjbWFwU2hhZG93fS5cclxuICAgKi9cclxuICBhc3luYyBtYXBTaGFkb3cocGF0aDogc3RyaW5nLCBjb250ZW50OiBVaW50OEFycmF5KSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS5tYXBTaGFkb3cocGF0aCwgY29udGVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSBzaGFkb3cgZmlsZSBmcm9tIHRoZSBjb21waWxlci5cclxuICAgKiBTZWUge0BsaW5rIFR5cHN0Q29tcGlsZXIjdW5tYXBTaGFkb3d9LlxyXG4gICAqL1xyXG4gIGFzeW5jIHVubWFwU2hhZG93KHBhdGg6IHN0cmluZykge1xyXG4gICAgKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSkudW5tYXBTaGFkb3cocGF0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlIHRoZSBkb2N1bWVudCB0byB2ZWN0b3IgKElSKSBmb3JtYXQuXHJcbiAgICogU2VlIHtAbGluayBTd2VldENvbXBpbGVPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyB2ZWN0b3Iobz86IFN3ZWV0Q29tcGlsZU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpXHJcbiAgICAgIC5jb21waWxlKG9wdHMpXHJcbiAgICAgIC50aGVuKHJlcyA9PiByZXMucmVzdWx0KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZVRtcChvcHRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlIHRoZSBkb2N1bWVudCB0byBQREYgZm9ybWF0LlxyXG4gICAqIFNlZSB7QGxpbmsgU3dlZXRDb21waWxlT3B0aW9uc30uXHJcbiAgICovXHJcbiAgYXN5bmMgcGRmKG8/OiBTd2VldENvbXBpbGVPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRDb21waWxlT3B0aW9ucyhvKTtcclxuICAgIG9wdHMuZm9ybWF0ID0gJ3BkZic7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLmNvbXBpbGUob3B0cylcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5yZXN1bHQpXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgdGhlIGRvY3VtZW50IHRvIFNWRyBmb3JtYXQuXHJcbiAgICogU2VlIHtAbGluayBTd2VldFJlbmRlck9wdGlvbnN9IGFuZCB7QGxpbmsgUmVuZGVyU3ZnT3B0aW9uc30uXHJcbiAgICovXHJcbiAgYXN5bmMgc3ZnKG8/OiBTd2VldFJlbmRlck9wdGlvbnMgJiBSZW5kZXJTdmdPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2llbnRSZW5kZXIobywgKHJlbmRlcmVyLCByZW5kZXJTZXNzaW9uKSA9PlxyXG4gICAgICByZW5kZXJlci5yZW5kZXJTdmcoe1xyXG4gICAgICAgIC4uLm8sXHJcbiAgICAgICAgcmVuZGVyU2Vzc2lvbixcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZSB0aGUgZG9jdW1lbnQgdG8gY2FudmFzIG9wZXJhdGlvbnMuXHJcbiAgICogU2VlIHtAbGluayBTd2VldFJlbmRlck9wdGlvbnN9IGFuZCB7QGxpbmsgUmVuZGVyVG9DYW52YXNPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyBjYW52YXMoXHJcbiAgICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxyXG4gICAgbz86IFN3ZWV0UmVuZGVyT3B0aW9ucyAmIE9taXQ8UmVuZGVyVG9DYW52YXNPcHRpb25zLCAnY29udGFpbmVyJz4sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2llbnRSZW5kZXIobywgKHJlbmRlcmVyLCByZW5kZXJTZXNzaW9uKSA9PlxyXG4gICAgICByZW5kZXJlci5yZW5kZXJUb0NhbnZhcyh7XHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIC4uLm8sXHJcbiAgICAgICAgcmVuZGVyU2Vzc2lvbixcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHNlbWFudGljIHRva2VucyBmb3IgdGhlIGRvY3VtZW50LlxyXG4gICAqL1xyXG4gIGFzeW5jIHF1ZXJ5PFQ+KG86IFN3ZWV0Q29tcGlsZU9wdGlvbnMgJiB7IHNlbGVjdG9yOiBzdHJpbmc7IGZpZWxkPzogc3RyaW5nIH0pOiBQcm9taXNlPFQ+IHtcclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpXHJcbiAgICAgIC5xdWVyeTxUPih7XHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICAuLi5vcHRzLFxyXG4gICAgICB9KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZVRtcChvcHRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdG9rZW4gbGVnZW5kIGZvciBzZW1hbnRpYyB0b2tlbnMuXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U2VtYW50aWNUb2tlbkxlZ2VuZCgpOiBQcm9taXNlPFNlbWFudGljVG9rZW5zTGVnZW5kPiB7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSkuZ2V0U2VtYW50aWNUb2tlbkxlZ2VuZCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHNlbWFudGljIHRva2VucyBmb3IgdGhlIGRvY3VtZW50LlxyXG4gICAqIFNlZSB7QGxpbmsgU3dlZXRDb21waWxlT3B0aW9uc30uXHJcbiAgICogU2VlIHtAbGluayBUeXBzdENvbXBpbGVyI2dldFNlbWFudGljVG9rZW5zfS5cclxuICAgKi9cclxuICBhc3luYyBnZXRTZW1hbnRpY1Rva2VucyhvOiBTd2VldENvbXBpbGVPcHRpb25zICYgeyByZXN1bHRJZD86IHN0cmluZyB9KTogUHJvbWlzZTxTZW1hbnRpY1Rva2Vucz4ge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLmdldFNlbWFudGljVG9rZW5zKHtcclxuICAgICAgICBtYWluRmlsZVBhdGg6IG9wdHMubWFpbkZpbGVQYXRoLFxyXG4gICAgICAgIHJlc3VsdElkOiBvLnJlc3VsdElkLFxyXG4gICAgICB9KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZVRtcChvcHRzKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldENvbXBpbGVPcHRpb25zKFxyXG4gICAgb3B0cz86IFN3ZWV0Q29tcGlsZU9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxDb21waWxlT3B0aW9uczxhbnksICdub25lJz4+IHtcclxuICAgIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHsgbWFpbkZpbGVQYXRoOiB0aGlzLm1haW5GaWxlUGF0aCwgZGlhZ25vc3RpY3M6ICdub25lJyB9O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwbGVhc2Ugc3BlY2lmeSBvcHRzIGFzIHttYWluQ29udGVudDogJy4uLid9IG9yIHttYWluRmlsZVBhdGg6ICcuLi4nfWApO1xyXG4gICAgfSBlbHNlIGlmICgnbWFpbkZpbGVQYXRoJyBpbiBvcHRzKSB7XHJcbiAgICAgIHJldHVybiB7IC4uLm9wdHMsIGRpYWdub3N0aWNzOiAnbm9uZScgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGRlc3RGaWxlID0gYC90bXAvJHtyYW5kc3RyKCl9LnR5cGA7XHJcbiAgICAgIGF3YWl0IHRoaXMuYWRkU291cmNlKGRlc3RGaWxlLCBvcHRzLm1haW5Db250ZW50KTtcclxuICAgICAgcmV0dXJuIHsgbWFpbkZpbGVQYXRoOiBkZXN0RmlsZSwgaW5wdXRzOiBvcHRzLmlucHV0cywgZGlhZ25vc3RpY3M6ICdub25lJyB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRWZWN0b3Iobz86IFN3ZWV0UmVuZGVyT3B0aW9ucyk6IFByb21pc2U8VWludDhBcnJheT4ge1xyXG4gICAgaWYgKG8gJiYgJ3ZlY3RvckRhdGEnIGluIG8pIHtcclxuICAgICAgcmV0dXJuIG8udmVjdG9yRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRDb21waWxlT3B0aW9ucyhvKTtcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKVxyXG4gICAgICAuY29tcGlsZShvcHRzKVxyXG4gICAgICAudGhlbihyZXMgPT4gcmVzLnJlc3VsdCEpXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgdHJhbnNpZW50UmVuZGVyPFQ+KFxyXG4gICAgb3B0czogU3dlZXRSZW5kZXJPcHRpb25zIHwgdW5kZWZpbmVkLFxyXG4gICAgZjogKHJyOiBUeXBzdFJlbmRlcmVyLCBzZXNzaW9uOiBSZW5kZXJTZXNzaW9uKSA9PiBULFxyXG4gICk6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3QgcnIgPSBhd2FpdCB0aGlzLmdldFJlbmRlcmVyKCk7XHJcbiAgICBpZiAoIXJyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignZG9lcyBub3QgcHJvdmlkZSByZW5kZXJlciBpbnN0YW5jZScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0VmVjdG9yKG9wdHMpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJyLnJ1bldpdGhTZXNzaW9uKGFzeW5jIHNlc3Npb24gPT4ge1xyXG4gICAgICByci5tYW5pcHVsYXRlRGF0YSh7XHJcbiAgICAgICAgcmVuZGVyU2Vzc2lvbjogc2Vzc2lvbixcclxuICAgICAgICBhY3Rpb246ICdyZXNldCcsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBmKHJyLCBzZXNzaW9uKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBwcmVwYXJlVXNlKCkge1xyXG4gICAgaWYgKCF0aGlzLnByb3ZpZGVycykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvdmlkZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIHRoaXMucHJvdmlkZXJzLm1hcChwID0+ICh0eXBlb2YgcCA9PT0gJ2Z1bmN0aW9uJyA/IHAoKSA6IHApKSxcclxuICAgICk7XHJcbiAgICB0aGlzLnByb3ZpZGVycyA9IFtdO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgJHR5cHN0ID09IHRoaXMgJiZcclxuICAgICAgIXByb3ZpZGVycy5zb21lKHAgPT4gcC5rZXkuaW5jbHVkZXMoJ3BhY2thZ2UtcmVnaXN0cnknKSB8fCBwLmtleS5pbmNsdWRlcygnYWNjZXNzLW1vZGVsJykpXHJcbiAgICApIHtcclxuICAgICAgLy8gTm90ZTogdGhlIGRlZmF1bHQgZmV0Y2ggYmFja2VuZCBhbHdheXMgYWRkcyBhIHdpdGhBY2Nlc3NNb2RlbChtZW0pXHJcbiAgICAgIGlmIChpc05vZGUpIHtcclxuICAgICAgICBjb25zdCBlc2NhcGVJbXBvcnQgPSBuZXcgRnVuY3Rpb24oJ20nLCAncmV0dXJuIGltcG9ydChtKScpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBtID0gbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IHJlcXVlc3QgfSA9IGF3YWl0IGVzY2FwZUltcG9ydCgnc3luYy1yZXF1ZXN0Jyk7XHJcblxyXG4gICAgICAgICAgJHR5cHN0LnVzZShcclxuICAgICAgICAgICAgVHlwc3RTbmlwcGV0LndpdGhBY2Nlc3NNb2RlbChtKSxcclxuICAgICAgICAgICAgVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZUJ5KG0sIChfOiB1bmtub3duLCBwYXRoOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QoJ0dFVCcsIHBhdGgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZ2V0Qm9keSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkdHlwc3QudXNlKFR5cHN0U25pcHBldC5mZXRjaFBhY2thZ2VSZWdpc3RyeSgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByb3ZpZGVyczIgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgdGhpcy5wcm92aWRlcnMubWFwKHAgPT4gKHR5cGVvZiBwID09PSAnZnVuY3Rpb24nID8gcCgpIDogcCkpLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjY09wdGlvbnMgPSAodGhpcy5jY09wdGlvbnMgfHw9IHt9KTtcclxuICAgIGNvbnN0IGNjQmVmb3JlQnVpbGQgPSAoY2NPcHRpb25zLmJlZm9yZUJ1aWxkIHx8PSBbXSk7XHJcblxyXG4gICAgY29uc3QgZXhPcHRpb25zID0gKHRoaXMuZXhPcHRpb25zIHx8PSB7fSk7XHJcbiAgICBjb25zdCBleEJlZm9yZUJ1aWxkID0gKGV4T3B0aW9ucy5iZWZvcmVCdWlsZCB8fD0gW10pO1xyXG5cclxuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgWy4uLnByb3ZpZGVycywgLi4ucHJvdmlkZXJzMl0pIHtcclxuICAgICAgaWYgKHByb3ZpZGVyLmZvclJvbGVzLmluY2x1ZGVzKCdjb21waWxlcicpKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1aXJlSXNVbmluaXRpYWxpemVkKCdjb21waWxlcicsIHRoaXMuY2MsIFR5cHN0U25pcHBldC4kYnVpbGRDKTtcclxuICAgICAgICBjY0JlZm9yZUJ1aWxkLnB1c2goLi4ucHJvdmlkZXIucHJvdmlkZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm92aWRlci5mb3JSb2xlcy5pbmNsdWRlcygncmVuZGVyZXInKSkge1xyXG4gICAgICAgIHRoaXMucmVxdWlyZUlzVW5pbml0aWFsaXplZCgncmVuZGVyZXInLCB0aGlzLmV4LCBUeXBzdFNuaXBwZXQuJGJ1aWxkUik7XHJcbiAgICAgICAgZXhCZWZvcmVCdWlsZC5wdXNoKC4uLnByb3ZpZGVyLnByb3ZpZGVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5wcm92aWRlcnMgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQ8VD4ocm9sZTogc3RyaW5nLCBjOiBQcm9taXNlSnVzdDxUPiwgZT86IFByb21pc2VKdXN0PFQ+KSB7XHJcbiAgICBpZiAodHlwZW9mIGMgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3JvbGV9IGhhcyBiZWVuIGluaXRpYWxpemVkOiAke2N9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZSAmJiBjICE9IGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3JvbGV9IGluc3RhbmNlIGlzIHNldCB0byBub24gZGVmYXVsdCB2YWx1ZWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBhc3luYyAkYnVpbGRDKHRoaXM6IFR5cHN0U25pcHBldCkge1xyXG4gICAgLy8gbGF6eSBpbXBvcnQgY29tcGlsZSBtb2R1bGVcclxuICAgIGNvbnN0IHsgY3JlYXRlR2xvYmFsQ29tcGlsZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9kaXN0L2VzbS9jb250cmliL2dsb2JhbC1jb21waWxlci5tanMnXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi9nbG9iYWwtY29tcGlsZXIubWpzJyk7XHJcbiAgICBjb25zdCB7IGNyZWF0ZVR5cHN0Q29tcGlsZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9kaXN0L2VzbS9jb21waWxlci5tanMnXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi4vY29tcGlsZXIubWpzJyk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlVXNlKCk7XHJcbiAgICByZXR1cm4gY3JlYXRlR2xvYmFsQ29tcGlsZXIoY3JlYXRlVHlwc3RDb21waWxlciwgdGhpcy5jY09wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBhc3luYyAkYnVpbGRSKHRoaXM6IFR5cHN0U25pcHBldCkge1xyXG4gICAgLy8gbGF6eSBpbXBvcnQgcmVuZGVyZXIgbW9kdWxlXHJcbiAgICBjb25zdCB7IGNyZWF0ZUdsb2JhbFJlbmRlcmVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAnQG15cmlhZGRyZWFtaW4vdHlwc3QudHMvZGlzdC9lc20vY29udHJpYi9nbG9iYWwtcmVuZGVyZXIubWpzJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4vZ2xvYmFsLXJlbmRlcmVyLm1qcycpO1xyXG4gICAgY29uc3QgeyBjcmVhdGVUeXBzdFJlbmRlcmVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAnQG15cmlhZGRyZWFtaW4vdHlwc3QudHMvZGlzdC9lc20vcmVuZGVyZXIubWpzJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlbmRlcmVyLm1qcycpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVVzZSgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUdsb2JhbFJlbmRlcmVyKGNyZWF0ZVR5cHN0UmVuZGVyZXIsIHRoaXMuZXhPcHRpb25zKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGF6eSBpbml0aWFsaXplZCBnbG9iYWwgc2hhcmVkIGluc3RhbmNlIG9mIHtAbGluayBUeXBzdFNuaXBwZXR9LiBTZWVcclxuICoge0BsaW5rIFR5cHN0U25pcHBldH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbmV4cG9ydCBjb25zdCAkdHlwc3QgPSBuZXcgVHlwc3RTbmlwcGV0KHtcclxuICBjb21waWxlcjogVHlwc3RTbmlwcGV0LiRidWlsZEMsXHJcbiAgcmVuZGVyZXI6IFR5cHN0U25pcHBldC4kYnVpbGRSLFxyXG59KTtcclxuIl19