export class FetchPackageRegistry {
    am;
    cache = new Map();
    constructor(am) {
        this.am = am;
    }
    resolvePath(path) {
        return `https://packages.typst.org/preview/${path.name}-${path.version}.tar.gz`;
    }
    pullPackageData(path) {
        const request = new XMLHttpRequest();
        request.overrideMimeType('text/plain; charset=x-user-defined');
        request.open('GET', this.resolvePath(path), false);
        request.send(null);
        if (request.status === 200 &&
            (request.response instanceof String || typeof request.response === 'string')) {
            return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
        }
        return undefined;
    }
    resolve(spec, context) {
        if (spec.namespace !== 'preview') {
            return undefined;
        }
        /// Check cache
        const path = this.resolvePath(spec);
        if (this.cache.has(path)) {
            return this.cache.get(path)();
        }
        /// Fetch data
        const data = this.pullPackageData(spec);
        if (!data) {
            return undefined;
        }
        /// Extract package bundle to the underlying access model `this.am`
        const previewDir = `/@memory/fetch/packages/preview/${spec.namespace}/${spec.name}/${spec.version}`;
        const entries = [];
        context.untar(data, (path, data, mtime) => {
            entries.push([previewDir + '/' + path, data, new Date(mtime)]);
        });
        const cacheClosure = () => {
            for (const [path, data, mtime] of entries) {
                this.am.insertFile(path, data, mtime);
            }
            /// Return the resolved directory to the package
            /// It is then used to access the package data by the access model `this.am`
            return previewDir;
        };
        this.cache.set(path, cacheClosure);
        /// Trigger write out
        return cacheClosure();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZS5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZnMvcGFja2FnZS5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsTUFBTSxPQUFPLG9CQUFvQjtJQUdYO0lBRnBCLEtBQUssR0FBMEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUV6RCxZQUFvQixFQUF1QjtRQUF2QixPQUFFLEdBQUYsRUFBRSxDQUFxQjtJQUFHLENBQUM7SUFFL0MsV0FBVyxDQUFDLElBQWlCO1FBQzNCLE9BQU8sc0NBQXNDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sU0FBUyxDQUFDO0lBQ2xGLENBQUM7SUFFRCxlQUFlLENBQUMsSUFBaUI7UUFDL0IsTUFBTSxPQUFPLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNyQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsb0NBQW9DLENBQUMsQ0FBQztRQUMvRCxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ25ELE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbkIsSUFDRSxPQUFPLENBQUMsTUFBTSxLQUFLLEdBQUc7WUFDdEIsQ0FBQyxPQUFPLENBQUMsUUFBUSxZQUFZLE1BQU0sSUFBSSxPQUFPLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLEVBQzVFO1lBQ0EsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxRTtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxPQUFPLENBQUMsSUFBaUIsRUFBRSxPQUE4QjtRQUN2RCxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQ2hDLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsZUFBZTtRQUNmLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN4QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBRSxFQUFFLENBQUM7U0FDaEM7UUFFRCxjQUFjO1FBQ2QsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFFRCxtRUFBbUU7UUFDbkUsTUFBTSxVQUFVLEdBQUcsbUNBQW1DLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEcsTUFBTSxPQUFPLEdBQWlDLEVBQUUsQ0FBQztRQUNqRCxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLElBQVksRUFBRSxJQUFnQixFQUFFLEtBQWEsRUFBRSxFQUFFO1lBQ3BFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxZQUFZLEdBQUcsR0FBRyxFQUFFO1lBQ3hCLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksT0FBTyxFQUFFO2dCQUN6QyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3ZDO1lBRUQsZ0RBQWdEO1lBQ2hELDRFQUE0RTtZQUM1RSxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDLENBQUM7UUFDRixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFbkMscUJBQXFCO1FBQ3JCLE9BQU8sWUFBWSxFQUFFLENBQUM7SUFDeEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFja2FnZVJlZ2lzdHJ5LCBQYWNrYWdlUmVzb2x2ZUNvbnRleHQsIFBhY2thZ2VTcGVjIH0gZnJvbSAnLi4vaW50ZXJuYWwudHlwZXMubWpzJztcclxuaW1wb3J0IHsgV3JpdGFibGVBY2Nlc3NNb2RlbCB9IGZyb20gJy4vaW5kZXgubWpzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBGZXRjaFBhY2thZ2VSZWdpc3RyeSBpbXBsZW1lbnRzIFBhY2thZ2VSZWdpc3RyeSB7XHJcbiAgY2FjaGU6IE1hcDxzdHJpbmcsICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZD4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYW06IFdyaXRhYmxlQWNjZXNzTW9kZWwpIHt9XHJcblxyXG4gIHJlc29sdmVQYXRoKHBhdGg6IFBhY2thZ2VTcGVjKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgaHR0cHM6Ly9wYWNrYWdlcy50eXBzdC5vcmcvcHJldmlldy8ke3BhdGgubmFtZX0tJHtwYXRoLnZlcnNpb259LnRhci5nemA7XHJcbiAgfVxyXG5cclxuICBwdWxsUGFja2FnZURhdGEocGF0aDogUGFja2FnZVNwZWMpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xyXG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLnJlc29sdmVQYXRoKHBhdGgpLCBmYWxzZSk7XHJcbiAgICByZXF1ZXN0LnNlbmQobnVsbCk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICByZXF1ZXN0LnN0YXR1cyA9PT0gMjAwICYmXHJcbiAgICAgIChyZXF1ZXN0LnJlc3BvbnNlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiByZXF1ZXN0LnJlc3BvbnNlID09PSAnc3RyaW5nJylcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcXVlc3QucmVzcG9uc2UsIChjOiBzdHJpbmcpID0+IGMuY2hhckNvZGVBdCgwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgcmVzb2x2ZShzcGVjOiBQYWNrYWdlU3BlYywgY29udGV4dDogUGFja2FnZVJlc29sdmVDb250ZXh0KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIGlmIChzcGVjLm5hbWVzcGFjZSAhPT0gJ3ByZXZpZXcnKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIENoZWNrIGNhY2hlXHJcbiAgICBjb25zdCBwYXRoID0gdGhpcy5yZXNvbHZlUGF0aChzcGVjKTtcclxuICAgIGlmICh0aGlzLmNhY2hlLmhhcyhwYXRoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQocGF0aCkhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIEZldGNoIGRhdGFcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnB1bGxQYWNrYWdlRGF0YShzcGVjKTtcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyBFeHRyYWN0IHBhY2thZ2UgYnVuZGxlIHRvIHRoZSB1bmRlcmx5aW5nIGFjY2VzcyBtb2RlbCBgdGhpcy5hbWBcclxuICAgIGNvbnN0IHByZXZpZXdEaXIgPSBgL0BtZW1vcnkvZmV0Y2gvcGFja2FnZXMvcHJldmlldy8ke3NwZWMubmFtZXNwYWNlfS8ke3NwZWMubmFtZX0vJHtzcGVjLnZlcnNpb259YDtcclxuICAgIGNvbnN0IGVudHJpZXM6IFtzdHJpbmcsIFVpbnQ4QXJyYXksIERhdGVdW10gPSBbXTtcclxuICAgIGNvbnRleHQudW50YXIoZGF0YSwgKHBhdGg6IHN0cmluZywgZGF0YTogVWludDhBcnJheSwgbXRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgICBlbnRyaWVzLnB1c2goW3ByZXZpZXdEaXIgKyAnLycgKyBwYXRoLCBkYXRhLCBuZXcgRGF0ZShtdGltZSldKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgY2FjaGVDbG9zdXJlID0gKCkgPT4ge1xyXG4gICAgICBmb3IgKGNvbnN0IFtwYXRoLCBkYXRhLCBtdGltZV0gb2YgZW50cmllcykge1xyXG4gICAgICAgIHRoaXMuYW0uaW5zZXJ0RmlsZShwYXRoLCBkYXRhLCBtdGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vLyBSZXR1cm4gdGhlIHJlc29sdmVkIGRpcmVjdG9yeSB0byB0aGUgcGFja2FnZVxyXG4gICAgICAvLy8gSXQgaXMgdGhlbiB1c2VkIHRvIGFjY2VzcyB0aGUgcGFja2FnZSBkYXRhIGJ5IHRoZSBhY2Nlc3MgbW9kZWwgYHRoaXMuYW1gXHJcbiAgICAgIHJldHVybiBwcmV2aWV3RGlyO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2FjaGUuc2V0KHBhdGgsIGNhY2hlQ2xvc3VyZSk7XHJcblxyXG4gICAgLy8vIFRyaWdnZXIgd3JpdGUgb3V0XHJcbiAgICByZXR1cm4gY2FjaGVDbG9zdXJlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==