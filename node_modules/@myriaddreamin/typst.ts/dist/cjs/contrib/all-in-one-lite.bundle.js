/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository https://github.com/Myriad-Dreamin/typst.ts/blob/main/packages/typst.ts
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/esm/contrib/global-compiler.mjs
var global_compiler_exports = {};
__export(global_compiler_exports, {
  createGlobalCompiler: () => createGlobalCompiler,
  getGlobalCompiler: () => getGlobalCompiler,
  withGlobalCompiler: () => withGlobalCompiler
});
function getGlobalCompiler() {
  return isReady ? globalCompiler : void 0;
}
function createGlobalCompiler(creator, initOptions) {
  const compiler = globalCompiler || creator();
  if (globalCompilerInitReady !== void 0) {
    return globalCompilerInitReady;
  }
  return globalCompilerInitReady = (async () => {
    isReady = true;
    await compiler.init(initOptions);
    return globalCompiler = compiler;
  })();
}
function withGlobalCompiler(creator, initOptions, resolve, reject) {
  const compiler = getGlobalCompiler();
  if (compiler) {
    resolve(compiler);
    return;
  }
  createGlobalCompiler(creator, initOptions).then(resolve).catch(reject);
}
var globalCompiler, globalCompilerInitReady, isReady;
var init_global_compiler = __esm({
  "dist/esm/contrib/global-compiler.mjs"() {
    globalCompiler = void 0;
    isReady = false;
  }
});

// ../../node_modules/idb/build/wrap-idb-value.js
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, cursorRequestMap, transactionDoneMap, transactionStoreNamesMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap;
var init_wrap_idb_value = __esm({
  "../../node_modules/idb/build/wrap-idb-value.js"() {
    instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
    cursorRequestMap = /* @__PURE__ */ new WeakMap();
    transactionDoneMap = /* @__PURE__ */ new WeakMap();
    transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
    transformCache = /* @__PURE__ */ new WeakMap();
    reverseTransformCache = /* @__PURE__ */ new WeakMap();
    idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          if (prop === "done")
            return transactionDoneMap.get(target);
          if (prop === "objectStoreNames") {
            return target.objectStoreNames || transactionStoreNamesMap.get(target);
          }
          if (prop === "store") {
            return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        return wrap(target[prop]);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
          return true;
        }
        return prop in target;
      }
    };
    unwrap = (value) => reverseTransformCache.get(value);
  }
});

// ../../node_modules/idb/build/index.js
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
var readMethods, writeMethods, cachedMethods;
var init_build = __esm({
  "../../node_modules/idb/build/index.js"() {
    init_wrap_idb_value();
    init_wrap_idb_value();
    readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
    writeMethods = ["put", "add", "delete", "clear"];
    cachedMethods = /* @__PURE__ */ new Map();
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
  }
});

// dist/esm/init.mjs
async function buildComponent(options, gModule, Builder, hooks) {
  await gModule.init(options?.getModule?.());
  return await new ComponentBuilder().build(options, new Builder(), hooks);
}
var ComponentBuilder;
var init_init = __esm({
  "dist/esm/init.mjs"() {
    init_build();
    ComponentBuilder = class {
      constructor() {
        this.loadedFonts = /* @__PURE__ */ new Set();
        this.fetcher = fetch;
      }
      setFetcher(fetcher) {
        this.fetcher = fetcher;
      }
      async loadFonts(builder, fonts) {
        const escapeImport = new Function("m", "return import(m)");
        const fetcher = this.fetcher || (this.fetcher = await async function() {
          const { fetchBuilder, FileSystemCache } = await escapeImport("node-fetch-cache");
          const cache = new FileSystemCache({
            /// By default, we don't have a complicated cache policy.
            cacheDirectory: ".cache/typst/fonts"
          });
          const cachedFetcher = fetchBuilder.withCache(cache);
          return function(input, init) {
            const timeout = setTimeout(() => {
              console.warn("font fetching is stucking:", input);
            }, 15e3);
            return cachedFetcher(input, init).finally(() => {
              clearTimeout(timeout);
            });
          };
        }());
        const fontsToLoad = fonts.filter((font) => {
          if (font instanceof Uint8Array) {
            return true;
          }
          if (this.loadedFonts.has(font)) {
            return false;
          }
          this.loadedFonts.add(font);
          return true;
        });
        const fontLists = await Promise.all(fontsToLoad.map(async (font) => {
          if (font instanceof Uint8Array) {
            await builder.add_raw_font(font);
            return;
          }
          return new Uint8Array(await (await fetcher(font)).arrayBuffer());
        }));
        for (const font of fontLists) {
          if (!font) {
            continue;
          }
          await builder.add_raw_font(font);
        }
      }
      async build(options, builder, hooks) {
        const buildCtx = { ref: this, builder, hooks };
        for (const fn of options?.beforeBuild ?? []) {
          await fn(void 0, buildCtx);
        }
        if (hooks.latelyBuild) {
          hooks.latelyBuild(buildCtx);
        }
        const component = await builder.build();
        return component;
      }
    };
  }
});

// dist/esm/internal.types.mjs
var kObject, TypstDefaultParams;
var init_internal_types = __esm({
  "dist/esm/internal.types.mjs"() {
    kObject = Symbol.for("reflexo-obj");
    (function(TypstDefaultParams3) {
      TypstDefaultParams3[TypstDefaultParams3["PIXEL_PER_PT"] = 3] = "PIXEL_PER_PT";
    })(TypstDefaultParams = TypstDefaultParams || (TypstDefaultParams = {}));
  }
});

// dist/esm/options.init.mjs
function preloadRemoteFonts2(userFonts, options) {
  const fonts = [...userFonts];
  if (options && options?.assets !== false && options?.assets?.length && options?.assets?.length > 0) {
    let assetUrlPrefix = options.assetUrlPrefix ?? "https://raw.githubusercontent.com/Myriad-Dreamin/typst/assets-fonts";
    if (assetUrlPrefix[assetUrlPrefix.length - 1] !== "/") {
      assetUrlPrefix += "/";
    }
    const prefix = (f) => f.map((font) => assetUrlPrefix + font);
    for (const asset of options.assets) {
      switch (asset) {
        case "text":
          fonts.push(...prefix(_textFonts2));
          break;
        case "cjk":
          fonts.push(...prefix(_cjkFonts2));
          break;
        case "emoji":
          fonts.push(...prefix(_emojiFonts2));
          break;
      }
    }
  }
  const loader = async (_, { ref, builder }) => {
    if (options?.fetcher) {
      ref.setFetcher(options.fetcher);
    }
    await ref.loadFonts(builder, fonts);
  };
  loader._preloadRemoteFontOptions = options;
  return loader;
}
var BeforeBuildSymbol2, _textFonts2, _cjkFonts2, _emojiFonts2;
var init_options_init = __esm({
  "dist/esm/options.init.mjs"() {
    BeforeBuildSymbol2 = Symbol("beforeBuild");
    _textFonts2 = [
      "LinLibertine_R.ttf",
      "LinLibertine_RB.ttf",
      "LinLibertine_RBI.ttf",
      "LinLibertine_RI.ttf",
      "NewCMMath-Book.otf",
      "NewCMMath-Regular.otf",
      "NewCM10-Regular.otf",
      "NewCM10-Bold.otf",
      "NewCM10-Italic.otf",
      "NewCM10-BoldItalic.otf",
      "DejaVuSansMono.ttf",
      "DejaVuSansMono-Bold.ttf",
      "DejaVuSansMono-Oblique.ttf",
      "DejaVuSansMono-BoldOblique.ttf"
    ];
    _cjkFonts2 = [
      "InriaSerif-Bold.ttf",
      "InriaSerif-BoldItalic.ttf",
      "InriaSerif-Italic.ttf",
      "InriaSerif-Regular.ttf",
      "Roboto-Regular.ttf",
      "NotoSerifCJKsc-Regular.otf"
    ];
    _emojiFonts2 = ["TwitterColorEmoji.ttf", "NotoColorEmoji.ttf"];
  }
});

// dist/esm/wasm.mjs
var once, LazyWasmModule;
var init_wasm = __esm({
  "dist/esm/wasm.mjs"() {
    once = (fn) => {
      let called = false;
      let res;
      return () => {
        if (called) {
          return res;
        }
        called = true;
        return res = fn();
      };
    };
    LazyWasmModule = class {
      constructor(initFn) {
        if (typeof initFn !== "function") {
          throw new Error("initFn is not a function");
        }
        this.initOnce = once(async () => {
          await initFn(this.wasmBin);
        });
      }
      async init(module2) {
        this.wasmBin = module2;
        await this.initOnce();
      }
    };
  }
});

// ../compiler/pkg/typst_ts_web_compiler.mjs
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function getFloat64Memory0() {
  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
  }
  return cachedFloat64Memory0;
}
function getBigInt64Memory0() {
  if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {
    cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);
  }
  return cachedBigInt64Memory0;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
        CLOSURE_DTORS.unregister(state);
      } else {
        state.a = a;
      }
    }
  };
  real.original = state;
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
function __wbg_adapter_50(arg0, arg1, arg2) {
  wasm.__wbindgen_export_3(arg0, arg1, addHeapObject(arg2));
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_export_5(addHeapObject(e));
  }
}
function __wbg_adapter_105(arg0, arg1, arg2, arg3) {
  wasm.__wbindgen_export_6(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function get_font_info(buffer) {
  const ret = wasm.get_font_info(addHeapObject(buffer));
  return takeObject(ret);
}
function getUint32Memory0() {
  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32Memory0;
}
function getArrayJsValueFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  const mem = getUint32Memory0();
  const slice = mem.subarray(ptr / 4, ptr / 4 + len);
  const result = [];
  for (let i = 0; i < slice.length; i++) {
    result.push(takeObject(slice[i]));
  }
  return result;
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_export_4(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbg_iterator_2cee6dadfd956dfa = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_e3c254076557e348 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_call_27c0f87801dedf93 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbg_next_40fc327bfc8770e6 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_c20a40f15020d68a = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() {
    return handleError(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_c6fb939a7f436783 = function() {
    return handleError(function() {
      const ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() {
    return handleError(function() {
      const ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_207b558942527489 = function() {
    return handleError(function() {
      const ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_28c511d9baebfa89 = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_instanceof_Object_71ca3c0a59266746 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Object;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_entries_95cc2c823b285a09 = function(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_cd7af8117672b8b8 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_get_bd8e338fbd5f5cc8 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getwithrefkey_edc2c8960f0f1191 = function(arg0, arg1) {
    const ret = getObject(arg0)[getObject(arg1)];
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_in = function(arg0, arg1) {
    const ret = getObject(arg0) in getObject(arg1);
    return ret;
  };
  imports.wbg.__wbg_isArray_2ab64d95e09ea0ae = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_next_196c84450b364254 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_298b57d23c0fc80c = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_value_d93c65011f51a456 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_log_411c0994e7c648bf = function(arg0, arg1, arg2) {
    console.log(getObject(arg0), getObject(arg1), getObject(arg2));
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_836825be07d4c9d2 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_isSafeInteger_f7b04ef02296c4d2 = function(arg0) {
    const ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbindgen_as_number = function(arg0) {
    const ret = +getObject(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_is_bigint = function(arg0) {
    const ret = typeof getObject(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbg_instanceof_Map_87917e0a7aaf4012 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Map;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
    const v = getObject(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? BigInt(0) : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject(arg0) === getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_938992c832f74314 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_Uint8Array_2b3bbecd033d19f6 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_new_72fb9a18b5ae2624 = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_f975102236d3c502 = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_d4638f722068f043 = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  };
  imports.wbg.__wbg_now_3014639a94423537 = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_3125852e5a7fbcff = function(arg0, arg1, arg2) {
    const ret = new Uint32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_2afb9348997957e9 = function(arg0) {
    const ret = new Uint32Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_1f9b04f170055d33 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_push_a5b05aedc7234f9f = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_error_74e3211912fcadb6 = function(arg0, arg1, arg2) {
    console.error(getObject(arg0), getObject(arg1), getObject(arg2));
  };
  imports.wbg.__wbg_proxycontext_new = function(arg0) {
    const ret = ProxyContext.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithargs_33d0ffcb48344669 = function(arg0, arg1, arg2, arg3) {
    const ret = new Function(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_81740750da40724f = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_105(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_typstcompiler_new = function(arg0) {
    const ret = TypstCompiler.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_queueMicrotask_3cbae2ec6b6cd3d6 = function(arg0) {
    const ret = getObject(arg0).queueMicrotask;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_resolve_b0083a7967828ec8 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbg_then_0c86a60e8fcfe9f6 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_queueMicrotask_481971b0d87f3dd4 = function(arg0) {
    queueMicrotask(getObject(arg0));
  };
  imports.wbg.__wbindgen_closure_wrapper13738 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1336, __wbg_adapter_50);
    return addHeapObject(ret);
  };
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedBigInt64Memory0 = null;
  cachedFloat64Memory0 = null;
  cachedInt32Memory0 = null;
  cachedUint32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm;
}
function initSync(module2) {
  if (wasm !== void 0)
    return wasm;
  const imports = __wbg_get_imports();
  __wbg_init_memory(imports);
  if (!(module2 instanceof WebAssembly.Module)) {
    module2 = new WebAssembly.Module(module2);
  }
  const instance = new WebAssembly.Instance(module2, imports);
  return __wbg_finalize_init(instance, module2);
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  if (typeof input === "undefined") {
    input = importWasmModule("typst_ts_web_compiler_bg.wasm", import_meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory(imports);
  const { instance, module: module2 } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module2);
}
function setImportWasmModule(importer) {
  importWasmModule = importer;
}
var import_meta, wasm, heap, heap_next, cachedTextDecoder, cachedUint8Memory0, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachedInt32Memory0, cachedFloat64Memory0, cachedBigInt64Memory0, CLOSURE_DTORS, cachedUint32Memory0, IncrServerFinalization, IncrServer, ProxyContextFinalization, ProxyContext, TypstCompilerFinalization, TypstCompiler, TypstCompilerBuilderFinalization, TypstCompilerBuilder, typst_ts_web_compiler_default, importWasmModule;
var init_typst_ts_web_compiler = __esm({
  "../compiler/pkg/typst_ts_web_compiler.mjs"() {
    import_meta = {};
    heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    heap_next = heap.length;
    cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
      throw Error("TextDecoder not available");
    } };
    if (typeof TextDecoder !== "undefined") {
      cachedTextDecoder.decode();
    }
    cachedUint8Memory0 = null;
    WASM_VECTOR_LEN = 0;
    cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
      throw Error("TextEncoder not available");
    } };
    encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    cachedInt32Memory0 = null;
    cachedFloat64Memory0 = null;
    cachedBigInt64Memory0 = null;
    CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((state) => {
      wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
    });
    cachedUint32Memory0 = null;
    IncrServerFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_incrserver_free(ptr >>> 0));
    IncrServer = class {
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IncrServer.prototype);
        obj.__wbg_ptr = ptr;
        IncrServerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IncrServerFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_incrserver_free(ptr);
      }
      /**
      * @param {boolean} attach
      */
      set_attach_debug_info(attach) {
        wasm.incrserver_set_attach_debug_info(this.__wbg_ptr, attach);
      }
      /**
      * @returns {Uint8Array | undefined}
      */
      current() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.incrserver_current(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          let v1;
          if (r0 !== 0) {
            v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      */
      reset() {
        wasm.incrserver_reset(this.__wbg_ptr);
      }
    };
    ProxyContextFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_proxycontext_free(ptr >>> 0));
    ProxyContext = class {
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProxyContext.prototype);
        obj.__wbg_ptr = ptr;
        ProxyContextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProxyContextFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proxycontext_free(ptr);
      }
      /**
      * @param {any} context
      */
      constructor(context) {
        const ret = wasm.proxycontext_new(addHeapObject(context));
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @returns {any}
      */
      get context() {
        const ret = wasm.proxycontext_context(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
      * @param {Uint8Array} data
      * @param {Function} cb
      */
      untar(data, cb) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);
          const len0 = WASM_VECTOR_LEN;
          wasm.proxycontext_untar(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(cb));
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    TypstCompilerFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_typstcompiler_free(ptr >>> 0));
    TypstCompiler = class {
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TypstCompiler.prototype);
        obj.__wbg_ptr = ptr;
        TypstCompilerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypstCompilerFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_typstcompiler_free(ptr);
      }
      /**
      */
      reset() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompiler_reset(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {any} inputs
      */
      set_inputs(inputs) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompiler_set_inputs(retptr, this.__wbg_ptr, addHeapObject(inputs));
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} path
      * @param {string} content
      * @returns {boolean}
      */
      add_source(path, content) {
        const ptr0 = passStringToWasm0(path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.typstcompiler_add_source(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret !== 0;
      }
      /**
      * @param {string} path
      * @param {Uint8Array} content
      * @returns {boolean}
      */
      map_shadow(path, content) {
        const ptr0 = passStringToWasm0(path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(content, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.typstcompiler_add_source(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret !== 0;
      }
      /**
      * @param {string} path
      * @returns {boolean}
      */
      unmap_shadow(path) {
        const ptr0 = passStringToWasm0(path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.typstcompiler_unmap_shadow(this.__wbg_ptr, ptr0, len0);
        return ret !== 0;
      }
      /**
      */
      reset_shadow() {
        wasm.typstcompiler_reset_shadow(this.__wbg_ptr);
      }
      /**
      * @returns {(string)[]}
      */
      get_loaded_fonts() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompiler_get_loaded_fonts(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_4(r0, r1 * 4, 4);
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} main_file_path
      * @returns {string}
      */
      get_ast(main_file_path) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(main_file_path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          wasm.typstcompiler_get_ast(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          var r3 = getInt32Memory0()[retptr / 4 + 3];
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm0(ptr2, len2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
        }
      }
      /**
      * @returns {any}
      */
      get_semantic_token_legend() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompiler_get_semantic_token_legend(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} offset_encoding
      * @param {string | undefined} [file_path]
      * @param {string | undefined} [result_id]
      * @returns {object}
      */
      get_semantic_tokens(offset_encoding, file_path, result_id) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(offset_encoding, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          var ptr1 = isLikeNone(file_path) ? 0 : passStringToWasm0(file_path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          var len1 = WASM_VECTOR_LEN;
          var ptr2 = isLikeNone(result_id) ? 0 : passStringToWasm0(result_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          var len2 = WASM_VECTOR_LEN;
          wasm.typstcompiler_get_semantic_tokens(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} fmt
      * @param {number} diagnostics_format
      * @returns {any}
      */
      get_artifact(fmt, diagnostics_format) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(fmt, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          wasm.typstcompiler_get_artifact(retptr, this.__wbg_ptr, ptr0, len0, diagnostics_format);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} main_file_path
      * @param {string} selector
      * @param {string | undefined} [field]
      * @returns {string}
      */
      query(main_file_path, selector, field) {
        let deferred5_0;
        let deferred5_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(main_file_path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          const ptr1 = passStringToWasm0(selector, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len1 = WASM_VECTOR_LEN;
          var ptr2 = isLikeNone(field) ? 0 : passStringToWasm0(field, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          var len2 = WASM_VECTOR_LEN;
          wasm.typstcompiler_query(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          var r3 = getInt32Memory0()[retptr / 4 + 3];
          var ptr4 = r0;
          var len4 = r1;
          if (r3) {
            ptr4 = 0;
            len4 = 0;
            throw takeObject(r2);
          }
          deferred5_0 = ptr4;
          deferred5_1 = len4;
          return getStringFromWasm0(ptr4, len4);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_4(deferred5_0, deferred5_1, 1);
        }
      }
      /**
      * @param {string} main_file_path
      * @param {string} fmt
      * @param {number} diagnostics_format
      * @returns {any}
      */
      compile(main_file_path, fmt, diagnostics_format) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(main_file_path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          const ptr1 = passStringToWasm0(fmt, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len1 = WASM_VECTOR_LEN;
          wasm.typstcompiler_compile(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, diagnostics_format);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @returns {IncrServer}
      */
      create_incr_server() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompiler_create_incr_server(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return IncrServer.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} main_file_path
      * @param {IncrServer} state
      * @param {number} diagnostics_format
      * @returns {any}
      */
      incr_compile(main_file_path, state, diagnostics_format) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(main_file_path, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          _assertClass(state, IncrServer);
          wasm.typstcompiler_incr_compile(retptr, this.__wbg_ptr, ptr0, len0, state.__wbg_ptr, diagnostics_format);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    TypstCompilerBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_typstcompilerbuilder_free(ptr >>> 0));
    TypstCompilerBuilder = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypstCompilerBuilderFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_typstcompilerbuilder_free(ptr);
      }
      /**
      */
      constructor() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompilerbuilder_new(retptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      */
      set_dummy_access_model() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.typstcompilerbuilder_set_dummy_access_model(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {any} context
      * @param {Function} mtime_fn
      * @param {Function} is_file_fn
      * @param {Function} real_path_fn
      * @param {Function} read_all_fn
      * @returns {Promise<void>}
      */
      set_access_model(context, mtime_fn, is_file_fn, real_path_fn, read_all_fn) {
        const ret = wasm.typstcompilerbuilder_set_access_model(this.__wbg_ptr, addHeapObject(context), addHeapObject(mtime_fn), addHeapObject(is_file_fn), addHeapObject(real_path_fn), addHeapObject(read_all_fn));
        return takeObject(ret);
      }
      /**
      * @param {any} context
      * @param {Function} real_resolve_fn
      * @returns {Promise<void>}
      */
      set_package_registry(context, real_resolve_fn) {
        const ret = wasm.typstcompilerbuilder_set_package_registry(this.__wbg_ptr, addHeapObject(context), addHeapObject(real_resolve_fn));
        return takeObject(ret);
      }
      /**
      * @param {Uint8Array} font_buffer
      * @returns {Promise<void>}
      */
      add_raw_font(font_buffer) {
        const ret = wasm.typstcompilerbuilder_add_raw_font(this.__wbg_ptr, addHeapObject(font_buffer));
        return takeObject(ret);
      }
      /**
      * @param {Array<any>} fonts
      * @returns {Promise<void>}
      */
      add_web_fonts(fonts) {
        const ret = wasm.typstcompilerbuilder_add_web_fonts(this.__wbg_ptr, addHeapObject(fonts));
        return takeObject(ret);
      }
      /**
      * @param {any} _pack
      * @returns {Promise<void>}
      */
      add_glyph_pack(_pack) {
        const ret = wasm.typstcompilerbuilder_add_glyph_pack(this.__wbg_ptr, addHeapObject(_pack));
        return takeObject(ret);
      }
      /**
      * @returns {Promise<TypstCompiler>}
      */
      build() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.typstcompilerbuilder_build(ptr);
        return takeObject(ret);
      }
    };
    typst_ts_web_compiler_default = __wbg_init;
    importWasmModule = async function(wasm_name, url) {
      throw new Error("Cannot import wasm module without importer: " + wasm_name + " " + url);
    };
  }
});

// ../compiler/pkg/wasm-pack-shim.mjs
var wasm_pack_shim_exports = {};
__export(wasm_pack_shim_exports, {
  IncrServer: () => IncrServer,
  ProxyContext: () => ProxyContext,
  TypstCompiler: () => TypstCompiler,
  TypstCompilerBuilder: () => TypstCompilerBuilder,
  default: () => wasm_pack_shim_default,
  get_font_info: () => get_font_info,
  initSync: () => initSync,
  setImportWasmModule: () => setImportWasmModule
});
var wasm_pack_shim_default, nodeJsImportWasmModule, isNode;
var init_wasm_pack_shim = __esm({
  "../compiler/pkg/wasm-pack-shim.mjs"() {
    init_typst_ts_web_compiler();
    init_typst_ts_web_compiler();
    init_typst_ts_web_compiler();
    wasm_pack_shim_default = typst_ts_web_compiler_default;
    nodeJsImportWasmModule = async function(wasm_name, url) {
      const escapeImport = new Function("m", "return import(m)");
      const path = await escapeImport("path");
      const { readFileSync } = await escapeImport("fs");
      const wasmPath = new URL(path.join(path.dirname(url), wasm_name));
      return await readFileSync(wasmPath).buffer;
    };
    isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
    if (isNode) {
      setImportWasmModule(nodeJsImportWasmModule);
    }
  }
});

// dist/esm/compiler.mjs
var compiler_exports = {};
__export(compiler_exports, {
  IncrementalServer: () => IncrementalServer,
  createTypstCompiler: () => createTypstCompiler
});
function createTypstCompiler() {
  return new TypstCompilerDriver();
}
function getDiagnosticsArg(diagnostics) {
  switch (diagnostics) {
    case "none":
      return 1;
    case "unix":
      return 2;
    case "full":
      return 3;
    default:
      return 0;
  }
}
var IncrementalServer, gCompilerModule, TypstCompilerDriver;
var init_compiler = __esm({
  "dist/esm/compiler.mjs"() {
    init_init();
    init_internal_types();
    init_options_init();
    init_wasm();
    IncrementalServer = class {
      /**
       * @internal
       */
      constructor(s) {
        this[kObject] = s;
      }
      /**
       * Reset the incremental server to the initial state.
       */
      reset() {
        this[kObject].reset();
      }
      /**
       * Return current result.
       */
      current() {
        return this[kObject].current();
      }
      /**
       * Also attach the debug info to the result.
       */
      setAttachDebugInfo(enable) {
        this[kObject].set_attach_debug_info(enable);
      }
    };
    gCompilerModule = new LazyWasmModule(async (bin) => {
      const module2 = await Promise.resolve().then(() => (init_wasm_pack_shim(), wasm_pack_shim_exports));
      return await module2.default(bin);
    });
    TypstCompilerDriver = class {
      constructor() {
      }
      async init(options) {
        this.compilerJs = await Promise.resolve().then(() => (init_wasm_pack_shim(), wasm_pack_shim_exports));
        const TypstCompilerBuilder2 = this.compilerJs.TypstCompilerBuilder;
        const compilerOptions = { ...options || {} };
        const hasPreloadRemoteFonts = compilerOptions.beforeBuild?.some((fn) => fn._preloadRemoteFontOptions !== void 0);
        const hasSpecifiedAssets = compilerOptions.beforeBuild?.some((fn) => fn._preloadRemoteFontOptions?.assets !== void 0);
        const hasDisableAssets = compilerOptions.beforeBuild?.some((fn) => fn._preloadRemoteFontOptions?.assets === false);
        if (!hasPreloadRemoteFonts || !hasSpecifiedAssets && !hasDisableAssets) {
          compilerOptions.beforeBuild?.push(preloadRemoteFonts2([], {
            assets: ["text"]
          }));
        }
        this.compiler = await buildComponent(options, gCompilerModule, TypstCompilerBuilder2, {});
      }
      compile(options) {
        return new Promise((resolve) => {
          if ("incrementalServer" in options) {
            resolve(this.compiler.incr_compile(options.mainFilePath, options.incrementalServer[kObject], getDiagnosticsArg(options.diagnostics)));
            return;
          }
          resolve(this.compiler.compile(options.mainFilePath, options.format || "vector", getDiagnosticsArg(options.diagnostics)));
        });
      }
      query(options) {
        return new Promise((resolve) => {
          resolve(JSON.parse(this.compiler.query(options.mainFilePath, options.selector, options.field)));
        });
      }
      getSemanticTokenLegend() {
        return new Promise((resolve) => {
          resolve(this.compiler.get_semantic_token_legend());
        });
      }
      getSemanticTokens(opts) {
        return new Promise((resolve) => {
          this.compiler.reset();
          resolve(this.compiler.get_semantic_tokens(opts.offsetEncoding || "utf-16", opts.mainFilePath, opts.resultId));
        });
      }
      async withIncrementalServer(f) {
        const srv = new IncrementalServer(this.compiler.create_incr_server());
        try {
          return await f(srv);
        } finally {
          srv[kObject].free();
        }
      }
      async getAst(mainFilePath) {
        return this.compiler.get_ast(mainFilePath);
      }
      async reset() {
        await new Promise((resolve) => {
          this.compiler.reset();
          resolve(void 0);
        });
      }
      addSource(path, source) {
        if (arguments.length > 2) {
          throw new Error("use of addSource(path, source, isMain) is deprecated, please use addSource(path, source) instead");
        }
        this.compiler.add_source(path, source);
      }
      mapShadow(path, content) {
        this.compiler.map_shadow(path, content);
      }
      unmapShadow(path) {
        this.compiler.unmap_shadow(path);
      }
      resetShadow() {
        this.compiler.reset_shadow();
      }
      renderPageToCanvas() {
        throw new Error("Please use the api TypstRenderer.renderToCanvas in v0.4.0");
      }
    };
  }
});

// dist/esm/contrib/global-renderer.mjs
var global_renderer_exports = {};
__export(global_renderer_exports, {
  createGlobalRenderer: () => createGlobalRenderer,
  getGlobalRenderer: () => getGlobalRenderer,
  withGlobalRenderer: () => withGlobalRenderer
});
function getGlobalRenderer() {
  return isReady2 ? globalRenderer : void 0;
}
function createGlobalRenderer(creator, initOptions) {
  const renderer = globalRenderer || creator();
  if (globalRendererInitReady !== void 0) {
    return globalRendererInitReady;
  }
  return globalRendererInitReady = (async () => {
    isReady2 = true;
    await renderer.init(initOptions);
    return globalRenderer = renderer;
  })();
}
function withGlobalRenderer(creator, initOptions, resolve, reject) {
  const renderer = getGlobalRenderer();
  if (renderer) {
    resolve(renderer);
    return;
  }
  createGlobalRenderer(creator, initOptions).then(resolve).catch(reject);
}
var globalRenderer, globalRendererInitReady, isReady2;
var init_global_renderer = __esm({
  "dist/esm/contrib/global-renderer.mjs"() {
    globalRenderer = void 0;
    isReady2 = false;
  }
});

// dist/esm/render/canvas/view.mjs
var RenderView;
var init_view = __esm({
  "dist/esm/render/canvas/view.mjs"() {
    init_internal_types();
    RenderView = class {
      constructor(pageInfos, container, options) {
        this.pageInfos = pageInfos;
        this.imageScaleFactor = options.pixelPerPt ?? TypstDefaultParams.PIXEL_PER_PT;
        container.innerHTML = "";
        container.style.width = "100%";
        this.container = container;
        this.canvasList = new Array(this.loadPageCount);
        this.textLayerList = new Array(this.loadPageCount);
        this.commonList = new Array(this.loadPageCount);
        this.textLayerParentList = new Array(this.loadPageCount);
        this.semanticLayerList = new Array(this.loadPageCount);
        const createOver = (i, pageAst, commonDiv) => {
          const width = Math.ceil(pageAst.width) * this.imageScaleFactor;
          const height = Math.ceil(pageAst.height) * this.imageScaleFactor;
          const canvas = this.canvasList[i] = document.createElement("canvas");
          const semanticLayer = this.semanticLayerList[i] = document.createElement("div");
          const textLayer = this.textLayerList[i] = document.createElement("div");
          const textLayerParent = this.textLayerParentList[i] = document.createElement("div");
          const ctx = canvas.getContext("2d");
          if (ctx) {
            const canvasDiv = document.createElement("div");
            canvas.width = width;
            canvas.height = height;
            canvasDiv.appendChild(canvas);
            commonDiv.appendChild(canvasDiv);
            canvasDiv.style.position = "absolute";
          }
          {
            textLayerParent.appendChild(textLayer);
            textLayerParent.className = "typst-html-semantics";
            const containerWidth = container.offsetWidth;
            const orignalScale = containerWidth / pageAst.width;
            textLayerParent.style.width = `${containerWidth}px`;
            textLayerParent.style.height = `${pageAst.height * orignalScale}px`;
            textLayerParent.style.setProperty("--data-text-width", `${orignalScale}px`);
            textLayerParent.style.setProperty("--data-text-height", `${orignalScale}px`);
            commonDiv.classList.add("typst-page");
            commonDiv.classList.add("canvas");
            commonDiv.style.width = `${containerWidth}px`;
            commonDiv.style.height = `${height * orignalScale}px`;
            commonDiv.style.position = "relative";
            semanticLayer.appendChild(textLayerParent);
            commonDiv.appendChild(semanticLayer);
          }
        };
        for (let i = 0; i < this.pageInfos.length; i++) {
          const pageAst = this.pageInfos[i];
          let commonDiv = void 0;
          commonDiv = this.commonList[i] = document.createElement("div");
          container.appendChild(commonDiv);
          createOver(i, pageAst, commonDiv);
        }
      }
      resetLayout() {
        for (let i = 0; i < this.pageInfos.length; i++) {
          const pageAst = this.pageInfos[i];
          const width = Math.ceil(pageAst.width) * this.imageScaleFactor;
          const height = Math.ceil(pageAst.height) * this.imageScaleFactor;
          const canvasDiv = this.canvasList[i].parentElement;
          if (!canvasDiv) {
            throw new Error(`canvasDiv is null for page ${i}, canvas list length ${this.canvasList.length}`);
          }
          const commonDiv = this.commonList[i];
          const textLayerParent = this.textLayerParentList[i];
          const containerWidth = this.container.offsetWidth;
          const orignalScale = containerWidth / width;
          textLayerParent.style.width = `${containerWidth}px`;
          textLayerParent.style.height = `${height * orignalScale}px`;
          commonDiv.style.width = `${containerWidth}px`;
          commonDiv.style.height = `${height * orignalScale}px`;
          const currentScale = this.container.offsetWidth / width;
          canvasDiv.style.transformOrigin = "0px 0px";
          canvasDiv.style.transform = `scale(${currentScale})`;
        }
      }
    };
  }
});

// dist/esm/contrib/dom/typst-doc.mjs
function provideDoc(Base) {
  return class TypstDocument {
    constructor(options) {
      if (options.isContentPreview) {
        options.renderMode = "canvas";
      }
      this.kModule = options.kModule;
      this.impl = new Base(options);
      if (!this.impl.r) {
        throw new Error(`mode is not supported, ${options?.renderMode}`);
      }
      if (options.isContentPreview) {
        this.impl.partialRendering = true;
        this.impl.pixelPerPt = 1;
        this.impl.isMixinOutline = true;
      }
    }
    dispose() {
      this.impl.dispose();
    }
    reset() {
      this.impl.reset();
    }
    addChangement(change) {
      this.impl.addChangement(change);
    }
    addViewportChange() {
      this.impl.addViewportChange();
    }
    setPageColor(color) {
      this.impl.pageColor = color;
      this.addViewportChange();
    }
    setPartialRendering(partialRendering) {
      this.impl.partialRendering = partialRendering;
    }
    setCursor(page, x, y) {
      this.impl.cursorPosition = [page, x, y];
    }
    setPartialPageNumber(page) {
      if (page <= 0 || page > this.kModule.retrievePagesInfo().length) {
        return false;
      }
      this.impl.partialRenderPage = page - 1;
      this.addViewportChange();
      return true;
    }
    getPartialPageNumber() {
      return this.impl.partialRenderPage + 1;
    }
    setOutineData(outline) {
      this.impl.outline = outline;
      this.addViewportChange();
    }
  };
}
function composeDoc(Base, ...mixins) {
  return mixins.reduce((acc, mixin) => mixin(acc), Base);
}
var PreviewMode, TypstDocumentContext;
var init_typst_doc = __esm({
  "dist/esm/contrib/dom/typst-doc.mjs"() {
    (function(PreviewMode2) {
      PreviewMode2[PreviewMode2["Doc"] = 0] = "Doc";
      PreviewMode2[PreviewMode2["Slide"] = 1] = "Slide";
    })(PreviewMode = PreviewMode || (PreviewMode = {}));
    TypstDocumentContext = class {
      constructor(opts) {
        this.modes = [];
        this.partialRendering = true;
        this.renderMode = "svg";
        this.r = void 0;
        this.previewMode = PreviewMode.Doc;
        this.isContentPreview = false;
        this.isMixinOutline = false;
        this.backgroundColor = "black";
        this.pageColor = "white";
        this.pixelPerPt = 3;
        this.isRendering = false;
        this.moduleInitialized = false;
        this.patchQueue = [];
        this.disposeList = [];
        this.currentRealScale = 1;
        this.currentScaleRatio = 1;
        this.vpTimeout = void 0;
        this.sampledRenderTime = 0;
        this.partialRenderPage = 0;
        this.outline = void 0;
        this.cursorPosition = void 0;
        this.cachedDOMState = {
          width: 0,
          height: 0,
          window: {
            innerWidth: 0,
            innerHeight: 0
          },
          boundingRect: {
            left: 0,
            top: 0,
            right: 0
          }
        };
        this.hookedElem = opts.hookedElem;
        this.kModule = opts.kModule;
        this.opts = opts || {};
        {
          const { renderMode, previewMode, isContentPreview, retrieveDOMState } = opts || {};
          this.partialRendering = false;
          this.renderMode = renderMode ?? this.renderMode;
          this.previewMode = previewMode ?? this.previewMode;
          this.isContentPreview = isContentPreview || false;
          this.retrieveDOMState = retrieveDOMState ?? (() => {
            return {
              width: this.hookedElem.offsetWidth,
              height: this.hookedElem.offsetHeight,
              window: {
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight
              },
              boundingRect: this.hookedElem.getBoundingClientRect()
            };
          });
          this.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue("--typst-preview-background-color");
        }
        this.hookedElem.classList.add("hide-scrollbar-x");
        this.hookedElem.parentElement?.classList.add("hide-scrollbar-x");
        if (this.previewMode === PreviewMode.Slide) {
          this.hookedElem.classList.add("hide-scrollbar-y");
          this.hookedElem.parentElement?.classList.add("hide-scrollbar-y");
        }
        this.installCtrlWheelHandler();
      }
      reset() {
        this.kModule.reset();
        this.moduleInitialized = false;
      }
      dispose() {
        const disposeList = this.disposeList;
        this.disposeList = [];
        disposeList.forEach((x) => x());
      }
      static derive(ctx, mode) {
        return ["rescale", "rerender", "postRender"].reduce((acc, x) => {
          acc[x] = ctx[`${x}$${mode}`].bind(ctx);
          console.assert(acc[x] !== void 0, `${x}$${mode} is undefined`);
          return acc;
        }, {});
      }
      registerMode(mode) {
        const facade = TypstDocumentContext.derive(this, mode);
        this.modes.push([mode, facade]);
        if (mode === this.renderMode) {
          this.r = facade;
        }
      }
      installCtrlWheelHandler() {
        const factors = [
          0.1,
          0.2,
          0.3,
          0.4,
          0.5,
          0.6,
          0.7,
          0.8,
          0.9,
          1,
          1.1,
          1.3,
          1.5,
          1.7,
          1.9,
          2.1,
          2.4,
          2.7,
          3,
          3.3,
          3.7,
          4.1,
          4.6,
          5.1,
          5.7,
          6.3,
          7,
          7.7,
          8.5,
          9.4,
          10
        ];
        const wheelEventHandler = (event) => {
          if (event.ctrlKey) {
            event.preventDefault();
            this.cachedDOMState = this.retrieveDOMState();
            if (window.onresize !== null) {
              window.onresize = null;
            }
            const prevScaleRatio = this.currentScaleRatio;
            if (event.deltaY < 0) {
              if (this.currentScaleRatio >= factors.at(-1)) {
                return;
              } else {
                this.currentScaleRatio = factors.filter((x) => x > this.currentScaleRatio).at(0);
              }
            } else if (event.deltaY > 0) {
              if (this.currentScaleRatio <= factors.at(0)) {
                return;
              } else {
                this.currentScaleRatio = factors.filter((x) => x < this.currentScaleRatio).at(-1);
              }
            } else {
              return;
            }
            const scrollFactor = this.currentScaleRatio / prevScaleRatio;
            const scrollX = event.pageX * (scrollFactor - 1);
            const scrollY = event.pageY * (scrollFactor - 1);
            if (Math.abs(this.currentScaleRatio - 1) < 1e-5) {
              this.hookedElem.classList.add("hide-scrollbar-x");
              this.hookedElem.parentElement?.classList.add("hide-scrollbar-x");
              if (this.previewMode === PreviewMode.Slide) {
                this.hookedElem.classList.add("hide-scrollbar-y");
                this.hookedElem.parentElement?.classList.add("hide-scrollbar-y");
              }
            } else {
              this.hookedElem.classList.remove("hide-scrollbar-x");
              this.hookedElem.parentElement?.classList.remove("hide-scrollbar-x");
              if (this.previewMode === PreviewMode.Slide) {
                this.hookedElem.classList.remove("hide-scrollbar-y");
                this.hookedElem.parentElement?.classList.remove("hide-scrollbar-y");
              }
            }
            const svg = this.hookedElem.firstElementChild;
            if (svg) {
              const scaleRatio = this.getSvgScaleRatio();
              const dataHeight = Number.parseFloat(svg.getAttribute("data-height"));
              const scaledHeight = Math.ceil(dataHeight * scaleRatio);
              this.hookedElem.style.height = `${scaledHeight * 2}px`;
            }
            window.scrollBy(scrollX, scrollY);
            this.addViewportChange();
            return false;
          }
        };
        if (this.renderMode !== "dom") {
          const vscodeAPI = typeof acquireVsCodeApi !== "undefined";
          if (vscodeAPI) {
            window.addEventListener("wheel", wheelEventHandler, {
              passive: false
            });
            this.disposeList.push(() => {
              window.removeEventListener("wheel", wheelEventHandler);
            });
          } else {
            document.body.addEventListener("wheel", wheelEventHandler, {
              passive: false
            });
            this.disposeList.push(() => {
              document.body.removeEventListener("wheel", wheelEventHandler);
            });
          }
        }
      }
      /// Get current scale from html to svg
      // Note: one should retrieve dom state before rescale
      getSvgScaleRatio() {
        const svg = this.hookedElem.firstElementChild;
        if (!svg) {
          return 0;
        }
        const container = this.cachedDOMState;
        const svgWidth = Number.parseFloat(svg.getAttribute("data-width") || svg.getAttribute("width") || "1");
        const svgHeight = Number.parseFloat(svg.getAttribute("data-height") || svg.getAttribute("height") || "1");
        this.currentRealScale = this.previewMode === PreviewMode.Slide ? Math.min(container.width / svgWidth, container.height / svgHeight) : container.width / svgWidth;
        return this.currentRealScale * this.currentScaleRatio;
      }
      processQueue(svgUpdateEvent) {
        const eventName = svgUpdateEvent[0];
        switch (eventName) {
          case "new":
          case "diff-v1": {
            if (eventName === "new") {
              this.reset();
            }
            this.kModule.manipulateData({
              action: "merge",
              data: svgUpdateEvent[1]
            });
            this.moduleInitialized = true;
            return true;
          }
          case "viewport-change": {
            if (!this.moduleInitialized) {
              console.log("viewport-change before initialization");
              return false;
            }
            return true;
          }
          default:
            console.log("svgUpdateEvent", svgUpdateEvent);
            return false;
        }
      }
      triggerUpdate() {
        if (this.isRendering) {
          return;
        }
        this.isRendering = true;
        const doUpdate = async () => {
          this.cachedDOMState = this.retrieveDOMState();
          if (this.patchQueue.length === 0) {
            this.isRendering = false;
            this.postprocessChanges();
            return;
          }
          try {
            let t0 = performance.now();
            const ctoken = this.canvasRenderCToken;
            if (ctoken) {
              await ctoken.cancel();
              await ctoken.wait();
              this.canvasRenderCToken = void 0;
              console.log("cancel canvas rendering");
            }
            let needRerender = false;
            while (this.patchQueue.length > 0) {
              needRerender = this.processQueue(this.patchQueue.shift()) || needRerender;
            }
            let t1 = performance.now();
            if (needRerender) {
              this.r.rescale();
              await this.r.rerender();
              this.r.rescale();
            }
            let t2 = performance.now();
            const d = (e, x, y) => `${e} ${(y - x).toFixed(2)} ms`;
            this.sampledRenderTime = t2 - t0;
            console.log([d("parse", t0, t1), d("rerender", t1, t2), d("total", t0, t2)].join(", "));
            requestAnimationFrame(doUpdate);
          } catch (e) {
            console.error(e);
            this.isRendering = false;
            this.postprocessChanges();
          }
        };
        requestAnimationFrame(doUpdate);
      }
      postprocessChanges() {
        this.r.postRender();
        if (this.previewMode === PreviewMode.Slide) {
          document.querySelectorAll(".typst-page-number-indicator").forEach((x) => {
            x.textContent = `${this.kModule.retrievePagesInfo().length}`;
          });
        }
      }
      addChangement(change) {
        if (change[0] === "new") {
          this.patchQueue.splice(0, this.patchQueue.length);
        }
        const pushChange = () => {
          this.vpTimeout = void 0;
          this.patchQueue.push(change);
          this.triggerUpdate();
        };
        if (this.vpTimeout !== void 0) {
          clearTimeout(this.vpTimeout);
        }
        if (change[0] === "viewport-change" && this.isRendering) {
          this.vpTimeout = setTimeout(pushChange, this.sampledRenderTime || 100);
        } else {
          pushChange();
        }
      }
      addViewportChange() {
        this.addChangement(["viewport-change", ""]);
      }
    };
  }
});

// dist/esm/contrib/dom/typst-cancel.mjs
var TypstCancellationToken;
var init_typst_cancel = __esm({
  "dist/esm/contrib/dom/typst-cancel.mjs"() {
    TypstCancellationToken = class {
      constructor() {
        this.isCancellationRequested = false;
        let resolveT = void 0;
        let resolveX = void 0;
        this._onCancelled = new Promise((resolve) => {
          resolveT = resolve;
          if (resolveX) {
            resolveX(resolve);
          }
        });
        this._onCancelledResolveResolved = new Promise((resolve) => {
          resolveX = resolve;
          if (resolveT) {
            resolve(resolveT);
          }
        });
      }
      async cancel() {
        await this._onCancelledResolveResolved;
        this.isCancellationRequested = true;
      }
      isCancelRequested() {
        return this.isCancellationRequested;
      }
      async consume() {
        (await this._onCancelledResolveResolved)();
      }
      wait() {
        return this._onCancelled;
      }
    };
  }
});

// dist/esm/dom.mjs
function provideDomDoc(Base) {
  return class DomDocument extends Base {
    constructor(...args) {
      super(...args);
      this.tmpl = document.createElement("template");
      this.stub = this.createElement("<stub></stub>");
      this.resourceHeader = void 0;
      this.pages = [];
      this.domScale = 1;
      this.track_mode = TrackMode.Doc;
      this.current_task = void 0;
      this.registerMode("dom");
      this.disposeList.push(() => {
        this.dispose();
      });
      this.plugin = this.opts.renderer;
      if (this.opts.domScale !== void 0) {
        if (this.opts.domScale <= 0) {
          throw new Error("domScale must be positive");
        }
        this.domScale = this.opts.domScale;
      }
    }
    dispose() {
      for (const page of this.pages) {
        page.dispose();
      }
      if (this.docKernel) {
        this.docKernel.free();
      }
    }
    createElement(tmpl) {
      this.tmpl.innerHTML = tmpl;
      return this.tmpl.content.firstElementChild;
    }
    async mountDom(pixelPerPt) {
      console.log("mountDom", pixelPerPt);
      if (this.docKernel) {
        throw new Error("already mounted");
      }
      this.hookedElem.innerHTML = `<svg class="typst-svg-resources" viewBox="0 0 0 0" width="0" height="0" style="opacity: 0; position: absolute;"></svg>`;
      this.resourceHeader = this.hookedElem.querySelector(".typst-svg-resources");
      this.docKernel = await this.plugin.renderer.mount_dom(this.kModule[kObject], this.hookedElem);
      this.docKernel.bind_functions({
        populateGlyphs: (data) => {
          let svg = this.createElement(data);
          console.log("populateGlyphs", svg);
          let content = svg.firstElementChild;
          this.resourceHeader.append(content);
        }
      });
    }
    async cancelAnyway$dom() {
      console.log("cancelAnyway$dom");
      if (this.current_task) {
        const task = this.current_task;
        this.current_task = void 0;
        await task.cancel();
      }
    }
    retrieveDOMPages() {
      return Array.from(this.hookedElem.querySelectorAll(".typst-dom-page"));
    }
    // doesn't need to postRender
    postRender$dom() {
    }
    // doesn't need to rescale
    rescale$dom() {
    }
    getDomViewport(cachedWindow, cachedBoundingRect) {
      const left = cachedBoundingRect.left;
      const top = -cachedBoundingRect.top;
      const right = cachedBoundingRect.right;
      const bottom = cachedWindow.innerHeight - cachedBoundingRect.top;
      const rect = {
        x: 0,
        y: top / this.domScale,
        width: Math.max(right - left, 0) / this.domScale,
        height: Math.max(bottom - top, 0) / this.domScale
      };
      if (rect.width <= 0 || rect.height <= 0) {
        rect.x = rect.y = rect.width = rect.height = 0;
      }
      return rect;
    }
    // fast mode
    async rerender$dom() {
      const domState = this.retrieveDOMState();
      const { x, y, width, height } = this.getDomViewport(domState.window, domState.boundingRect);
      let dirty = await this.docKernel.relayout(x, y, width, height);
      if (!dirty) {
        return;
      }
      const cancel = new TypstCancellationToken();
      this.doRender$dom(cancel);
      this.current_task = cancel;
    }
    async doRender$dom(ctx) {
      const condOrExit = (needFrame, cb) => {
        if (needFrame && !ctx.isCancelRequested() && cb) {
          return cb();
        }
      };
      const pages = this.retrieveDOMPages().map((page) => {
        const { innerWidth, innerHeight } = window;
        const browserBBox = page.getBoundingClientRect();
        return {
          inWindow: !(browserBBox.left > innerWidth || browserBBox.right < 0 || browserBBox.top > innerHeight || browserBBox.bottom < 0),
          page
        };
      });
      const renderPage = async (i) => {
        await animationFrame();
        if (ctx.isCancelRequested()) {
          console.log("cancel stage", RepaintStage.Layout, i);
          return void 0;
        }
        const page = pages[i].page;
        const browserBBox = page.getBoundingClientRect();
        const v = this.getDomViewport(window, browserBBox);
        const needCalc = (stage) => this.docKernel.need_repaint(i, v.x, v.y, v.width, v.height, stage);
        const repaint = (stage) => this.docKernel.repaint(i, v.x, v.y, v.width, v.height, stage);
        const calc = (stage) => {
          if (ctx.isCancelRequested()) {
            return void 0;
          }
          return condOrExit(needCalc(stage), () => repaint(stage));
        };
        await calc(RepaintStage.Layout);
        const wScale = (browserBBox.width ? Number.parseFloat(page.getAttribute("data-width")) / browserBBox.width : 1) * this.domScale;
        const hScale = (browserBBox.height ? Number.parseFloat(page.getAttribute("data-height")) / browserBBox.height : 1) * this.domScale;
        v.x *= wScale;
        v.y *= hScale;
        v.y -= 100;
        v.width *= wScale;
        v.height *= hScale;
        v.height += 200;
        await calc(RepaintStage.Svg);
        await calc(RepaintStage.Semantics);
        if (ctx.isCancelRequested()) {
          console.log("cancel stage", RepaintStage.Semantics, i);
          return void 0;
        }
        if (needCalc(RepaintStage.PrepareCanvas)) {
          const calcCanvasAfterPreparing = async () => {
            await repaint(RepaintStage.PrepareCanvas);
            if (ctx.isCancelRequested()) {
              return void 0;
            }
            return calc(RepaintStage.Canvas);
          };
          calcCanvasAfterPreparing();
        } else {
          await calc(RepaintStage.Canvas);
        }
      };
      const renderPages = async (inWindow) => {
        for (let idx = 0; idx < pages.length; ++idx) {
          if (ctx.isCancelRequested()) {
            console.log("cancel page", RepaintStage.Layout, idx);
            return;
          }
          if (pages[idx].inWindow === inWindow) {
            await renderPage(idx);
          }
        }
      };
      this.cancelAnyway$dom();
      await renderPages(true);
      await renderPages(false);
      if (ctx.isCancelRequested()) {
        return;
      }
      console.log("finished", RepaintStage.Layout);
    }
  };
}
var animationFrame, TrackMode, RepaintStage, TypstDomDocument;
var init_dom = __esm({
  "dist/esm/dom.mjs"() {
    init_internal_types();
    init_typst_doc();
    init_typst_cancel();
    animationFrame = () => new Promise((resolve) => requestAnimationFrame(resolve));
    (function(TrackMode2) {
      TrackMode2[TrackMode2["Doc"] = 0] = "Doc";
      TrackMode2[TrackMode2["Pages"] = 1] = "Pages";
    })(TrackMode || (TrackMode = {}));
    (function(RepaintStage2) {
      RepaintStage2[RepaintStage2["Layout"] = 0] = "Layout";
      RepaintStage2[RepaintStage2["Svg"] = 1] = "Svg";
      RepaintStage2[RepaintStage2["Semantics"] = 2] = "Semantics";
      RepaintStage2[RepaintStage2["PrepareCanvas"] = 3] = "PrepareCanvas";
      RepaintStage2[RepaintStage2["Canvas"] = 4] = "Canvas";
    })(RepaintStage || (RepaintStage = {}));
    TypstDomDocument = class extends provideDoc(composeDoc(TypstDocumentContext, provideDomDoc)) {
    };
  }
});

// ../renderer/pkg/typst_ts_renderer.mjs
function getUint8Memory02() {
  if (cachedUint8Memory02 === null || cachedUint8Memory02.byteLength === 0) {
    cachedUint8Memory02 = new Uint8Array(wasm2.memory.buffer);
  }
  return cachedUint8Memory02;
}
function getStringFromWasm02(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder2.decode(getUint8Memory02().subarray(ptr, ptr + len));
}
function addHeapObject2(obj) {
  if (heap_next2 === heap2.length)
    heap2.push(heap2.length + 1);
  const idx = heap_next2;
  heap_next2 = heap2[idx];
  if (typeof heap_next2 !== "number")
    throw new Error("corrupt heap");
  heap2[idx] = obj;
  return idx;
}
function getObject2(idx) {
  return heap2[idx];
}
function dropObject2(idx) {
  if (idx < 132)
    return;
  heap2[idx] = heap_next2;
  heap_next2 = idx;
}
function takeObject2(idx) {
  const ret = getObject2(idx);
  dropObject2(idx);
  return ret;
}
function _assertBoolean(n) {
  if (typeof n !== "boolean") {
    throw new Error(`expected a boolean argument, found ${typeof n}`);
  }
}
function passStringToWasm02(arg, malloc, realloc) {
  if (typeof arg !== "string")
    throw new Error(`expected a string argument, found ${typeof arg}`);
  if (realloc === void 0) {
    const buf = cachedTextEncoder2.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory02().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN2 = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory02();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory02().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    if (ret.read !== arg.length)
      throw new Error("failed to pass whole string");
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN2 = offset;
  return ptr;
}
function isLikeNone2(x) {
  return x === void 0 || x === null;
}
function getInt32Memory02() {
  if (cachedInt32Memory02 === null || cachedInt32Memory02.byteLength === 0) {
    cachedInt32Memory02 = new Int32Array(wasm2.memory.buffer);
  }
  return cachedInt32Memory02;
}
function debugString2(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString2(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString2(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function makeMutClosure2(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm2.__wbindgen_export_2.get(state.dtor)(a, state.b);
        CLOSURE_DTORS2.unregister(state);
      } else {
        state.a = a;
      }
    }
  };
  real.original = state;
  CLOSURE_DTORS2.register(real, state, state);
  return real;
}
function logError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    let error = function() {
      try {
        return e instanceof Error ? `${e.message}

Stack:
${e.stack}` : e.toString();
      } catch (_) {
        return "<failed to stringify thrown value>";
      }
    }();
    console.error("wasm-bindgen: imported JS function that was not marked as `catch` threw an error:", error);
    throw e;
  }
}
function _assertNum(n) {
  if (typeof n !== "number")
    throw new Error(`expected a number argument, found ${typeof n}`);
}
function __wbg_adapter_24(arg0, arg1, arg2) {
  _assertNum(arg0);
  _assertNum(arg1);
  wasm2.__wbindgen_export_3(arg0, arg1, addHeapObject2(arg2));
}
function makeClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    try {
      return f(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm2.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
        state.a = 0;
        CLOSURE_DTORS2.unregister(state);
      }
    }
  };
  real.original = state;
  CLOSURE_DTORS2.register(real, state, state);
  return real;
}
function __wbg_adapter_27(arg0, arg1) {
  _assertNum(arg0);
  _assertNum(arg1);
  wasm2.__wbindgen_export_4(arg0, arg1);
}
function __wbg_adapter_30(arg0, arg1, arg2) {
  _assertNum(arg0);
  _assertNum(arg1);
  wasm2.__wbindgen_export_5(arg0, arg1, addHeapObject2(arg2));
}
function _assertClass2(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
function getFloat32Memory0() {
  if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {
    cachedFloat32Memory0 = new Float32Array(wasm2.memory.buffer);
  }
  return cachedFloat32Memory0;
}
function passArray8ToWasm02(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory02().set(arg, ptr / 1);
  WASM_VECTOR_LEN2 = arg.length;
  return ptr;
}
function getUint32Memory02() {
  if (cachedUint32Memory02 === null || cachedUint32Memory02.byteLength === 0) {
    cachedUint32Memory02 = new Uint32Array(wasm2.memory.buffer);
  }
  return cachedUint32Memory02;
}
function passArray32ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 4, 4) >>> 0;
  getUint32Memory02().set(arg, ptr / 4);
  WASM_VECTOR_LEN2 = arg.length;
  return ptr;
}
function handleError2(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm2.__wbindgen_export_7(addHeapObject2(e));
  }
}
function __wbg_adapter_90(arg0, arg1, arg2, arg3) {
  _assertNum(arg0);
  _assertNum(arg1);
  wasm2.__wbindgen_export_8(arg0, arg1, addHeapObject2(arg2), addHeapObject2(arg3));
}
function renderer_build_info() {
  const ret = wasm2.renderer_build_info();
  return takeObject2(ret);
}
async function __wbg_load2(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports2() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_new_81740750da40724f = function() {
    return logError(function(arg0, arg1) {
      try {
        var state0 = { a: arg0, b: arg1 };
        var cb0 = (arg02, arg12) => {
          const a = state0.a;
          state0.a = 0;
          try {
            return __wbg_adapter_90(a, state0.b, arg02, arg12);
          } finally {
            state0.a = a;
          }
        };
        const ret = new Promise(cb0);
        return addHeapObject2(ret);
      } finally {
        state0.a = state0.b = 0;
      }
    }, arguments);
  };
  imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {
    return logError(function() {
      const ret = new Array();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm02(arg0, arg1);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm2.memory;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_buffer_12d079cc21e14bdb = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).buffer;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function() {
    return logError(function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject2(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject2(arg0);
  };
  imports.wbg.__wbg_new_63b92bc8671ed464 = function() {
    return logError(function(arg0) {
      const ret = new Uint8Array(getObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_push_a5b05aedc7234f9f = function() {
    return logError(function(arg0, arg1) {
      const ret = getObject2(arg0).push(getObject2(arg1));
      _assertNum(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_clientWidth_7ea3915573b64350 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).clientWidth;
      _assertNum(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_getAttribute_99bddb29274b29b9 = function() {
    return logError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg1).getAttribute(getStringFromWasm02(arg2, arg3));
      var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
      var len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_setinnerHTML_26d69b59e1af99c7 = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0).innerHTML = getStringFromWasm02(arg1, arg2);
    }, arguments);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject2(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_instanceof_Window_f401953a2cf86220 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof Window;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_get_e3c254076557e348 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = Reflect.get(getObject2(arg0), getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject2(arg0) === "function";
    _assertBoolean(ret);
    return ret;
  };
  imports.wbg.__wbg_firstElementChild_c78596cd0c9b16a7 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).firstElementChild;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).call(getObject2(arg1), getObject2(arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_setAttribute_3c9f6c303b696daa = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).setAttribute(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    return logError(function() {
      const ret = new Error();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function() {
    return logError(function(arg0, arg1) {
      const ret = getObject2(arg1).stack;
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
      const len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function() {
    return logError(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm02(arg0, arg1));
      } finally {
        wasm2.__wbindgen_export_6(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() {
    return handleError2(function() {
      const ret = self.self;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_c6fb939a7f436783 = function() {
    return handleError2(function() {
      const ret = window.window;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() {
    return handleError2(function() {
      const ret = globalThis.globalThis;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_207b558942527489 = function() {
    return handleError2(function() {
      const ret = global.global;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject2(arg0) === void 0;
    _assertBoolean(ret);
    return ret;
  };
  imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function() {
    return logError(function(arg0, arg1) {
      const ret = new Function(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_27c0f87801dedf93 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).call(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_28c511d9baebfa89 = function() {
    return logError(function(arg0, arg1) {
      const ret = new Error(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithlength_e9b4878cebadb3d3 = function() {
    return logError(function(arg0) {
      const ret = new Uint8Array(arg0 >>> 0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_length_c20a40f15020d68a = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).length;
      _assertNum(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_a47bac70306a19a7 = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0).set(getObject2(arg1), arg2 >>> 0);
    }, arguments);
  };
  imports.wbg.__wbg_new_72fb9a18b5ae2624 = function() {
    return logError(function() {
      const ret = new Object();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_1f9b04f170055d33 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject2(arg0), getObject2(arg1), getObject2(arg2));
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_newwithu8arraysequenceandoptions_366f462e1b363808 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new Blob(getObject2(arg0), getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectURL_ad8244759309f204 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = URL.createObjectURL(getObject2(arg1));
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
      const len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_then_a73caa9a87991566 = function() {
    return logError(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).then(getObject2(arg1), getObject2(arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject2(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    _assertBoolean(ret);
    return ret;
  };
  imports.wbg.__wbg_setsrc_681ceacdf6845f60 = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0).src = getStringFromWasm02(arg1, arg2);
    }, arguments);
  };
  imports.wbg.__wbg_setonload_4b2d1fd60416c2dd = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).onload = getObject2(arg1);
    }, arguments);
  };
  imports.wbg.__wbg_setonerror_4e3faee320602b64 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).onerror = getObject2(arg1);
    }, arguments);
  };
  imports.wbg.__wbg_restore_b0b630dcf5875c16 = function() {
    return logError(function(arg0) {
      getObject2(arg0).restore();
    }, arguments);
  };
  imports.wbg.__wbg_save_b2ec4f4afd250d50 = function() {
    return logError(function(arg0) {
      getObject2(arg0).save();
    }, arguments);
  };
  imports.wbg.__wbg_setTransform_73631293eb78bf95 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      getObject2(arg0).setTransform(arg1, arg2, arg3, arg4, arg5, arg6);
    }, arguments);
  };
  imports.wbg.__wbg_setfillStyle_4de94b275f5761f2 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).fillStyle = getObject2(arg1);
    }, arguments);
  };
  imports.wbg.__wbg_newwithpathstring_eaf93999895560bf = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new Path2D(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_fill_2a41be87d81e2fc6 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).fill(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_drawImage_14f72ed9b8430e9d = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4, arg5) {
      getObject2(arg0).drawImage(getObject2(arg1), arg2, arg3, arg4, arg5);
    }, arguments);
  };
  imports.wbg.__wbg_setlineCap_561c8efd4e48949c = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0).lineCap = getStringFromWasm02(arg1, arg2);
    }, arguments);
  };
  imports.wbg.__wbg_setlineJoin_c2f314b5744d240f = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0).lineJoin = getStringFromWasm02(arg1, arg2);
    }, arguments);
  };
  imports.wbg.__wbg_setmiterLimit_d1ca0274cb45b371 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).miterLimit = arg1;
    }, arguments);
  };
  imports.wbg.__wbg_setlineDashOffset_ee14f664955fb961 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).lineDashOffset = arg1;
    }, arguments);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_setLineDash_aed2919a1550112b = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).setLineDash(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setlineWidth_ea4c8cb72d8cdc31 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).lineWidth = arg1;
    }, arguments);
  };
  imports.wbg.__wbg_setstrokeStyle_c79ba6bc36a7f302 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).strokeStyle = getObject2(arg1);
    }, arguments);
  };
  imports.wbg.__wbg_stroke_98acc75a72e3ec2a = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).stroke(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_clip_2164a4dde3544fc7 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).clip(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_revokeObjectURL_16a2051ee9d99da9 = function() {
    return handleError2(function(arg0, arg1) {
      URL.revokeObjectURL(getStringFromWasm02(arg0, arg1));
    }, arguments);
  };
  imports.wbg.__wbg_stringify_8887fe74e1c50d81 = function() {
    return handleError2(function(arg0) {
      const ret = JSON.stringify(getObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_log_5bb5f88f245d7762 = function() {
    return logError(function(arg0) {
      console.log(getObject2(arg0));
    }, arguments);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject2(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
    var len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_document_5100775d18896c16 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).document;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createElement_8bae7856a4bb7411 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).createElement(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_HtmlImageElement_d823b10f99854a6b = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof HTMLImageElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_log_1746d5c75ec89963 = function() {
    return logError(function(arg0, arg1) {
      console.log(getObject2(arg0), getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_replaceWith_72e597a5990af8e0 = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).replaceWith(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_cloneNode_e19c313ea20d5d1d = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).cloneNode();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_Element_6945fc210db80ea9 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof Element;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_SvgGraphicsElement_a5b95d5bb634faf8 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof SVGGraphicsElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_nextElementSibling_72304aeb66624976 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).nextElementSibling;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_lastElementChild_d408eaa043927a37 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).lastElementChild;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_remove_49b0a5925a04b955 = function() {
    return logError(function(arg0) {
      getObject2(arg0).remove();
    }, arguments);
  };
  imports.wbg.__wbg_getContext_df50fa48a8876636 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).getContext(getStringFromWasm02(arg1, arg2));
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_CanvasRenderingContext2d_20bf99ccc051643b = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof CanvasRenderingContext2D;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_clearRect_05de681275dda635 = function() {
    return logError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).clearRect(arg1, arg2, arg3, arg4);
    }, arguments);
  };
  imports.wbg.__wbg_style_c3fc3dd146182a2d = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).style;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_removeProperty_fa6d48e2923dcfac = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg1).removeProperty(getStringFromWasm02(arg2, arg3));
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
      const len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_setProperty_ea7d15a2b591aa97 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).setProperty(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_content_e05939f111e5ff5a = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).content;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_firstElementChild_92c5a0bbdcb24796 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).firstElementChild;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_HtmlCanvasElement_46bdbf323b0b18d1 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof HTMLCanvasElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_SvgsvgElement_ab645292b5c30322 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof SVGSVGElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_HtmlDivElement_31d3273633f69d96 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof HTMLDivElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_call_938992c832f74314 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      const ret = getObject2(arg0).call(getObject2(arg1), getObject2(arg2), getObject2(arg3), getObject2(arg4));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_appendChild_580ccb11a660db68 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).appendChild(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_HtmlElement_3bcc4ff70cfdcba5 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof HTMLElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_setwidth_080107476e633963 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).width = arg1 >>> 0;
    }, arguments);
  };
  imports.wbg.__wbg_setheight_dc240617639f1f51 = function() {
    return logError(function(arg0, arg1) {
      getObject2(arg0).height = arg1 >>> 0;
    }, arguments);
  };
  imports.wbg.__wbg_call_8e7cb608789c2528 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg0).call(getObject2(arg1), getObject2(arg2), getObject2(arg3));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_HtmlTemplateElement_e8ad7d7a7fc9abc2 = function() {
    return logError(function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof HTMLTemplateElement;
      } catch (_) {
        result = false;
      }
      const ret = result;
      _assertBoolean(ret);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_setfont_a4d031cf2c94b4db = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0).font = getStringFromWasm02(arg1, arg2);
    }, arguments);
  };
  imports.wbg.__wbg_measureText_ea212ea07011bf71 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).measureText(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_width_e870de808b523851 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).width;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_d4638f722068f043 = function() {
    return logError(function(arg0, arg1, arg2) {
      getObject2(arg0)[arg1 >>> 0] = takeObject2(arg2);
    }, arguments);
  };
  imports.wbg.__wbg_fillRect_b5c8166281bac9df = function() {
    return logError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).fillRect(arg1, arg2, arg3, arg4);
    }, arguments);
  };
  imports.wbg.__wbg_typstrenderer_new = function() {
    return logError(function(arg0) {
      const ret = TypstRenderer.__wrap(arg0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_incrdomdocclient_new = function() {
    return logError(function(arg0) {
      const ret = IncrDomDocClient.__wrap(arg0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_warn_63bbae1730aead09 = function() {
    return logError(function(arg0) {
      console.warn(getObject2(arg0));
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString2(getObject2(arg1));
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm02(arg0, arg1));
  };
  imports.wbg.__wbg_queueMicrotask_3cbae2ec6b6cd3d6 = function() {
    return logError(function(arg0) {
      const ret = getObject2(arg0).queueMicrotask;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_resolve_b0083a7967828ec8 = function() {
    return logError(function(arg0) {
      const ret = Promise.resolve(getObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_then_0c86a60e8fcfe9f6 = function() {
    return logError(function(arg0, arg1) {
      const ret = getObject2(arg0).then(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_queueMicrotask_481971b0d87f3dd4 = function() {
    return logError(function(arg0) {
      queueMicrotask(getObject2(arg0));
    }, arguments);
  };
  imports.wbg.__wbindgen_closure_wrapper1576 = function() {
    return logError(function(arg0, arg1, arg2) {
      const ret = makeMutClosure2(arg0, arg1, 180, __wbg_adapter_24);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_closure_wrapper1580 = function() {
    return logError(function(arg0, arg1, arg2) {
      const ret = makeClosure(arg0, arg1, 180, __wbg_adapter_27);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_closure_wrapper1581 = function() {
    return logError(function(arg0, arg1, arg2) {
      const ret = makeClosure(arg0, arg1, 180, __wbg_adapter_30);
      return addHeapObject2(ret);
    }, arguments);
  };
  return imports;
}
function __wbg_init_memory2(imports, maybe_memory) {
}
function __wbg_finalize_init2(instance, module2) {
  wasm2 = instance.exports;
  __wbg_init2.__wbindgen_wasm_module = module2;
  cachedFloat32Memory0 = null;
  cachedInt32Memory02 = null;
  cachedUint32Memory02 = null;
  cachedUint8Memory02 = null;
  return wasm2;
}
function initSync2(module2) {
  if (wasm2 !== void 0)
    return wasm2;
  const imports = __wbg_get_imports2();
  __wbg_init_memory2(imports);
  if (!(module2 instanceof WebAssembly.Module)) {
    module2 = new WebAssembly.Module(module2);
  }
  const instance = new WebAssembly.Instance(module2, imports);
  return __wbg_finalize_init2(instance, module2);
}
async function __wbg_init2(input) {
  if (wasm2 !== void 0)
    return wasm2;
  if (typeof input === "undefined") {
    input = importWasmModule2("typst_ts_renderer_bg.wasm", import_meta2.url);
  }
  const imports = __wbg_get_imports2();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory2(imports);
  const { instance, module: module2 } = await __wbg_load2(await input, imports);
  return __wbg_finalize_init2(instance, module2);
}
function setImportWasmModule2(importer) {
  importWasmModule2 = importer;
}
var import_meta2, wasm2, cachedTextDecoder2, cachedUint8Memory02, heap2, heap_next2, WASM_VECTOR_LEN2, cachedTextEncoder2, encodeString2, cachedInt32Memory02, CLOSURE_DTORS2, cachedFloat32Memory0, cachedUint32Memory02, CreateSessionOptionsFinalization, CreateSessionOptions, IncrDomDocClientFinalization, IncrDomDocClient, PageInfoFinalization, PageInfo, PagesInfoFinalization, PagesInfo, RenderPageImageOptionsFinalization, RenderPageImageOptions, RenderSessionFinalization, RenderSession, RenderSessionOptionsFinalization, RenderSessionOptions, TypstRendererFinalization, TypstRenderer, TypstRendererBuilderFinalization, TypstRendererBuilder, typst_ts_renderer_default, importWasmModule2;
var init_typst_ts_renderer = __esm({
  "../renderer/pkg/typst_ts_renderer.mjs"() {
    import_meta2 = {};
    cachedTextDecoder2 = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
      throw Error("TextDecoder not available");
    } };
    if (typeof TextDecoder !== "undefined") {
      cachedTextDecoder2.decode();
    }
    cachedUint8Memory02 = null;
    heap2 = new Array(128).fill(void 0);
    heap2.push(void 0, null, true, false);
    heap_next2 = heap2.length;
    WASM_VECTOR_LEN2 = 0;
    cachedTextEncoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
      throw Error("TextEncoder not available");
    } };
    encodeString2 = typeof cachedTextEncoder2.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder2.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder2.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    cachedInt32Memory02 = null;
    CLOSURE_DTORS2 = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((state) => {
      wasm2.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
    });
    cachedFloat32Memory0 = null;
    cachedUint32Memory02 = null;
    CreateSessionOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_createsessionoptions_free(ptr >>> 0));
    CreateSessionOptions = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateSessionOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_createsessionoptions_free(ptr);
      }
      /**
      */
      constructor() {
        const ret = wasm2.createsessionoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @param {string} format
      */
      set format(format) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ptr0 = passStringToWasm02(format, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.createsessionoptions_set_format(this.__wbg_ptr, ptr0, len0);
      }
      /**
      * @param {Uint8Array} artifact_content
      */
      set artifact_content(artifact_content) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ptr0 = passArray8ToWasm02(artifact_content, wasm2.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.createsessionoptions_set_artifact_content(this.__wbg_ptr, ptr0, len0);
      }
    };
    IncrDomDocClientFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_incrdomdocclient_free(ptr >>> 0));
    IncrDomDocClient = class {
      constructor() {
        throw new Error("cannot invoke `new` directly");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IncrDomDocClient.prototype);
        obj.__wbg_ptr = ptr;
        IncrDomDocClientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IncrDomDocClientFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_incrdomdocclient_free(ptr);
      }
      /**
      * @param {any} functions
      */
      bind_functions(functions) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        wasm2.incrdomdocclient_bind_functions(this.__wbg_ptr, addHeapObject2(functions));
      }
      /**
      * Relayout the document in the given window.
      * @param {number} x
      * @param {number} y
      * @param {number} w
      * @param {number} h
      * @returns {Promise<boolean>}
      */
      relayout(x, y, w, h) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.incrdomdocclient_relayout(this.__wbg_ptr, x, y, w, h);
        return takeObject2(ret);
      }
      /**
      * @param {number} page_num
      * @param {number} x
      * @param {number} y
      * @param {number} w
      * @param {number} h
      * @param {number} stage
      * @returns {boolean}
      */
      need_repaint(page_num, x, y, w, h, stage) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertNum(page_num);
          _assertNum(stage);
          wasm2.incrdomdocclient_need_repaint(retptr, this.__wbg_ptr, page_num, x, y, w, h, stage);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          if (r2) {
            throw takeObject2(r1);
          }
          return r0 !== 0;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {number} page_num
      * @param {number} x
      * @param {number} y
      * @param {number} w
      * @param {number} h
      * @param {number} stage
      * @returns {any}
      */
      repaint(page_num, x, y, w, h, stage) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertNum(page_num);
          _assertNum(stage);
          wasm2.incrdomdocclient_repaint(retptr, this.__wbg_ptr, page_num, x, y, w, h, stage);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PageInfoFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_pageinfo_free(ptr >>> 0));
    PageInfo = class {
      constructor() {
        throw new Error("cannot invoke `new` directly");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PageInfo.prototype);
        obj.__wbg_ptr = ptr;
        PageInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PageInfoFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pageinfo_free(ptr);
      }
      /**
      * @returns {number}
      */
      get page_off() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.pageinfo_page_off(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
      * @returns {number}
      */
      get width_pt() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.pageinfo_width_pt(this.__wbg_ptr);
        return ret;
      }
      /**
      * @returns {number}
      */
      get height_pt() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.pageinfo_height_pt(this.__wbg_ptr);
        return ret;
      }
    };
    PagesInfoFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_pagesinfo_free(ptr >>> 0));
    PagesInfo = class {
      constructor() {
        throw new Error("cannot invoke `new` directly");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PagesInfo.prototype);
        obj.__wbg_ptr = ptr;
        PagesInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PagesInfoFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pagesinfo_free(ptr);
      }
      /**
      * @returns {number}
      */
      get page_count() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.pagesinfo_page_count(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
      * @param {number} num
      * @returns {PageInfo | undefined}
      */
      page_by_number(num) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        _assertNum(num);
        const ret = wasm2.pagesinfo_page_by_number(this.__wbg_ptr, num);
        return ret === 0 ? void 0 : PageInfo.__wrap(ret);
      }
      /**
      * @param {number} i
      * @returns {PageInfo}
      */
      page(i) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        _assertNum(i);
        const ret = wasm2.pagesinfo_page(this.__wbg_ptr, i);
        return PageInfo.__wrap(ret);
      }
      /**
      * @returns {number}
      */
      width() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.pagesinfo_width(this.__wbg_ptr);
        return ret;
      }
      /**
      * @returns {number}
      */
      height() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.pagesinfo_height(this.__wbg_ptr);
        return ret;
      }
    };
    RenderPageImageOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_renderpageimageoptions_free(ptr >>> 0));
    RenderPageImageOptions = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RenderPageImageOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_renderpageimageoptions_free(ptr);
      }
      /**
      */
      constructor() {
        const ret = wasm2.renderpageimageoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @returns {number | undefined}
      */
      get page_off() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.renderpageimageoptions_page_off(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          return r0 === 0 ? void 0 : r1 >>> 0;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {number | undefined} [page_off]
      */
      set page_off(page_off) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        if (!isLikeNone2(page_off)) {
          _assertNum(page_off);
        }
        wasm2.renderpageimageoptions_set_page_off(this.__wbg_ptr, !isLikeNone2(page_off), isLikeNone2(page_off) ? 0 : page_off);
      }
      /**
      * @returns {string | undefined}
      */
      get cache_key() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.renderpageimageoptions_cache_key(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_6(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string | undefined} [cache_key]
      */
      set cache_key(cache_key) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        var ptr0 = isLikeNone2(cache_key) ? 0 : passStringToWasm02(cache_key, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN2;
        wasm2.renderpageimageoptions_set_cache_key(this.__wbg_ptr, ptr0, len0);
      }
      /**
      * @returns {number | undefined}
      */
      get data_selection() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.renderpageimageoptions_data_selection(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          return r0 === 0 ? void 0 : r1 >>> 0;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {number | undefined} [data_selection]
      */
      set data_selection(data_selection) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        if (!isLikeNone2(data_selection)) {
          _assertNum(data_selection);
        }
        wasm2.renderpageimageoptions_set_data_selection(this.__wbg_ptr, !isLikeNone2(data_selection), isLikeNone2(data_selection) ? 0 : data_selection);
      }
    };
    RenderSessionFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_rendersession_free(ptr >>> 0));
    RenderSession = class {
      constructor() {
        throw new Error("cannot invoke `new` directly");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RenderSession.prototype);
        obj.__wbg_ptr = ptr;
        RenderSessionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RenderSessionFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_rendersession_free(ptr);
      }
      /**
      * @param {number} rect_lo_x
      * @param {number} rect_lo_y
      * @param {number} rect_hi_x
      * @param {number} rect_hi_y
      * @returns {string}
      */
      render_in_window(rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y) {
        let deferred1_0;
        let deferred1_1;
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.rendersession_render_in_window(retptr, this.__wbg_ptr, rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_6(deferred1_0, deferred1_1, 1);
        }
      }
      /**
      * @returns {number | undefined}
      */
      get pixel_per_pt() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.rendersession_pixel_per_pt(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getFloat32Memory0()[retptr / 4 + 1];
          return r0 === 0 ? void 0 : r1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {number} pixel_per_pt
      */
      set pixel_per_pt(pixel_per_pt) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        wasm2.rendersession_set_pixel_per_pt(this.__wbg_ptr, pixel_per_pt);
      }
      /**
      * @returns {string | undefined}
      */
      get background_color() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.rendersession_background_color(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_6(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} background_color
      */
      set background_color(background_color) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ptr0 = passStringToWasm02(background_color, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.rendersession_set_background_color(this.__wbg_ptr, ptr0, len0);
      }
      /**
      * @returns {PagesInfo}
      */
      get pages_info() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.rendersession_pages_info(this.__wbg_ptr);
        return PagesInfo.__wrap(ret);
      }
      /**
      * @returns {number}
      */
      get doc_width() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.rendersession_doc_width(this.__wbg_ptr);
        return ret;
      }
      /**
      * @returns {number}
      */
      get doc_height() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.rendersession_doc_height(this.__wbg_ptr);
        return ret;
      }
      /**
      * @param {Uint32Array} path
      * @returns {string | undefined}
      */
      source_span(path) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          const ptr0 = passArray32ToWasm0(path, wasm2.__wbindgen_export_0);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.rendersession_source_span(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          var r3 = getInt32Memory02()[retptr / 4 + 3];
          if (r3) {
            throw takeObject2(r2);
          }
          let v2;
          if (r0 !== 0) {
            v2 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_6(r0, r1 * 1, 1);
          }
          return v2;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    RenderSessionOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_rendersessionoptions_free(ptr >>> 0));
    RenderSessionOptions = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RenderSessionOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_rendersessionoptions_free(ptr);
      }
      /**
      */
      constructor() {
        const ret = wasm2.rendersessionoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @returns {number | undefined}
      */
      get pixel_per_pt() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.rendersession_pixel_per_pt(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getFloat32Memory0()[retptr / 4 + 1];
          return r0 === 0 ? void 0 : r1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {number} pixel_per_pt
      */
      set pixel_per_pt(pixel_per_pt) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        wasm2.rendersession_set_pixel_per_pt(this.__wbg_ptr, pixel_per_pt);
      }
      /**
      * @returns {string | undefined}
      */
      get background_color() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.rendersessionoptions_background_color(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_6(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} background_color
      */
      set background_color(background_color) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ptr0 = passStringToWasm02(background_color, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.rendersessionoptions_set_background_color(this.__wbg_ptr, ptr0, len0);
      }
      /**
      * @returns {string | undefined}
      */
      get format() {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.rendersession_background_color(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_6(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} format
      */
      set format(format) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ptr0 = passStringToWasm02(format, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.rendersession_set_background_color(this.__wbg_ptr, ptr0, len0);
      }
    };
    TypstRendererFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_typstrenderer_free(ptr >>> 0));
    TypstRenderer = class {
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TypstRenderer.prototype);
        obj.__wbg_ptr = ptr;
        TypstRendererFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypstRendererFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_typstrenderer_free(ptr);
      }
      /**
      * @param {RenderSession} ses
      * @param {CanvasRenderingContext2D | undefined} [canvas]
      * @param {RenderPageImageOptions | undefined} [options]
      * @returns {Promise<any>}
      */
      render_page_to_canvas(ses, canvas, options) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        _assertClass2(ses, RenderSession);
        if (ses.__wbg_ptr === 0) {
          throw new Error("Attempt to use a moved value");
        }
        let ptr0 = 0;
        if (!isLikeNone2(options)) {
          _assertClass2(options, RenderPageImageOptions);
          if (options.__wbg_ptr === 0) {
            throw new Error("Attempt to use a moved value");
          }
          ptr0 = options.__destroy_into_raw();
        }
        const ret = wasm2.typstrenderer_render_page_to_canvas(this.__wbg_ptr, ses.__wbg_ptr, isLikeNone2(canvas) ? 0 : addHeapObject2(canvas), ptr0);
        return takeObject2(ret);
      }
      /**
      * @param {RenderSession} session
      * @param {number} rect_lo_x
      * @param {number} rect_lo_y
      * @param {number} rect_hi_x
      * @param {number} rect_hi_y
      * @returns {string}
      */
      render_svg_diff(session, rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y) {
        let deferred1_0;
        let deferred1_1;
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertClass2(session, RenderSession);
          if (session.__wbg_ptr === 0) {
            throw new Error("Attempt to use a moved value");
          }
          wasm2.typstrenderer_render_svg_diff(retptr, this.__wbg_ptr, session.__wbg_ptr, rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_6(deferred1_0, deferred1_1, 1);
        }
      }
      /**
      * @param {RenderSession} session
      * @param {number | undefined} [parts]
      * @returns {string}
      */
      svg_data(session, parts) {
        let deferred2_0;
        let deferred2_1;
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertClass2(session, RenderSession);
          if (session.__wbg_ptr === 0) {
            throw new Error("Attempt to use a moved value");
          }
          if (!isLikeNone2(parts)) {
            _assertNum(parts);
          }
          wasm2.typstrenderer_svg_data(retptr, this.__wbg_ptr, session.__wbg_ptr, !isLikeNone2(parts), isLikeNone2(parts) ? 0 : parts);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          var r3 = getInt32Memory02()[retptr / 4 + 3];
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_6(deferred2_0, deferred2_1, 1);
        }
      }
      /**
      * @param {RenderSession} session
      * @returns {Array<any> | undefined}
      */
      get_customs(session) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        _assertClass2(session, RenderSession);
        if (session.__wbg_ptr === 0) {
          throw new Error("Attempt to use a moved value");
        }
        const ret = wasm2.typstrenderer_get_customs(this.__wbg_ptr, session.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
      * @param {RenderSession} session
      * @param {HTMLElement} root
      * @returns {boolean}
      */
      render_svg(session, root) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertClass2(session, RenderSession);
          if (session.__wbg_ptr === 0) {
            throw new Error("Attempt to use a moved value");
          }
          wasm2.typstrenderer_render_svg(retptr, this.__wbg_ptr, session.__wbg_ptr, addHeapObject2(root));
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          if (r2) {
            throw takeObject2(r1);
          }
          return r0 !== 0;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {RenderSession} ses
      * @param {HTMLElement} elem
      * @returns {Promise<IncrDomDocClient>}
      */
      mount_dom(ses, elem) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        _assertClass2(ses, RenderSession);
        if (ses.__wbg_ptr === 0) {
          throw new Error("Attempt to use a moved value");
        }
        const ret = wasm2.typstrenderer_mount_dom(this.__wbg_ptr, ses.__wbg_ptr, addHeapObject2(elem));
        return takeObject2(ret);
      }
      /**
      * @param {any} _v
      */
      load_glyph_pack(_v) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          wasm2.typstrenderer_load_glyph_pack(retptr, this.__wbg_ptr, addHeapObject2(_v));
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      */
      constructor() {
        const ret = wasm2.typstrenderer_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @param {CreateSessionOptions | undefined} [options]
      * @returns {RenderSession}
      */
      create_session(options) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          let ptr0 = 0;
          if (!isLikeNone2(options)) {
            _assertClass2(options, CreateSessionOptions);
            if (options.__wbg_ptr === 0) {
              throw new Error("Attempt to use a moved value");
            }
            ptr0 = options.__destroy_into_raw();
          }
          wasm2.typstrenderer_create_session(retptr, this.__wbg_ptr, ptr0);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          if (r2) {
            throw takeObject2(r1);
          }
          return RenderSession.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {RenderSession} session
      */
      reset(session) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertClass2(session, RenderSession);
          if (session.__wbg_ptr === 0) {
            throw new Error("Attempt to use a moved value");
          }
          wasm2.typstrenderer_reset(retptr, this.__wbg_ptr, session.__wbg_ptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {RenderSession} session
      * @param {string} action
      * @param {Uint8Array} data
      */
      manipulate_data(session, action, data) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          _assertClass2(session, RenderSession);
          if (session.__wbg_ptr === 0) {
            throw new Error("Attempt to use a moved value");
          }
          const ptr0 = passStringToWasm02(action, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN2;
          const ptr1 = passArray8ToWasm02(data, wasm2.__wbindgen_export_0);
          const len1 = WASM_VECTOR_LEN2;
          wasm2.typstrenderer_manipulate_data(retptr, this.__wbg_ptr, session.__wbg_ptr, ptr0, len0, ptr1, len1);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {Uint8Array} artifact_content
      * @param {string} decoder
      * @returns {RenderSession}
      */
      session_from_artifact(artifact_content, decoder) {
        try {
          if (this.__wbg_ptr == 0)
            throw new Error("Attempt to use a moved value");
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertNum(this.__wbg_ptr);
          const ptr0 = passArray8ToWasm02(artifact_content, wasm2.__wbindgen_export_0);
          const len0 = WASM_VECTOR_LEN2;
          const ptr1 = passStringToWasm02(decoder, wasm2.__wbindgen_export_0, wasm2.__wbindgen_export_1);
          const len1 = WASM_VECTOR_LEN2;
          wasm2.typstrenderer_session_from_artifact(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          if (r2) {
            throw takeObject2(r1);
          }
          return RenderSession.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    TypstRendererBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm2.__wbg_typstrendererbuilder_free(ptr >>> 0));
    TypstRendererBuilder = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypstRendererBuilderFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_typstrendererbuilder_free(ptr);
      }
      /**
      * @param {any} _pack
      * @returns {Promise<void>}
      */
      add_glyph_pack(_pack) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.typstrendererbuilder_add_glyph_pack(this.__wbg_ptr, addHeapObject2(_pack));
        return takeObject2(ret);
      }
      /**
      * @param {Uint8Array} _font_buffer
      * @returns {Promise<void>}
      */
      add_raw_font(_font_buffer) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.typstrendererbuilder_add_raw_font(this.__wbg_ptr, addHeapObject2(_font_buffer));
        return takeObject2(ret);
      }
      /**
      * @param {Array<any>} _fonts
      * @returns {Promise<void>}
      */
      add_web_fonts(_fonts) {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        _assertNum(this.__wbg_ptr);
        const ret = wasm2.typstrendererbuilder_add_web_fonts(this.__wbg_ptr, addHeapObject2(_fonts));
        return takeObject2(ret);
      }
      /**
      */
      constructor() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.typstrendererbuilder_new(retptr);
          var r0 = getInt32Memory02()[retptr / 4 + 0];
          var r1 = getInt32Memory02()[retptr / 4 + 1];
          var r2 = getInt32Memory02()[retptr / 4 + 2];
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @returns {Promise<TypstRenderer>}
      */
      build() {
        if (this.__wbg_ptr == 0)
          throw new Error("Attempt to use a moved value");
        const ptr = this.__destroy_into_raw();
        _assertNum(ptr);
        const ret = wasm2.typstrendererbuilder_build(ptr);
        return takeObject2(ret);
      }
    };
    typst_ts_renderer_default = __wbg_init2;
    importWasmModule2 = async function(wasm_name, url) {
      throw new Error("Cannot import wasm module without importer: " + wasm_name + " " + url);
    };
  }
});

// ../renderer/pkg/wasm-pack-shim.mjs
var wasm_pack_shim_exports2 = {};
__export(wasm_pack_shim_exports2, {
  CreateSessionOptions: () => CreateSessionOptions,
  IncrDomDocClient: () => IncrDomDocClient,
  PageInfo: () => PageInfo,
  PagesInfo: () => PagesInfo,
  RenderPageImageOptions: () => RenderPageImageOptions,
  RenderSession: () => RenderSession,
  RenderSessionOptions: () => RenderSessionOptions,
  TypstRenderer: () => TypstRenderer,
  TypstRendererBuilder: () => TypstRendererBuilder,
  default: () => wasm_pack_shim_default2,
  initSync: () => initSync2,
  renderer_build_info: () => renderer_build_info,
  setImportWasmModule: () => setImportWasmModule2
});
var wasm_pack_shim_default2, nodeJsImportWasmModule2, isNode2;
var init_wasm_pack_shim2 = __esm({
  "../renderer/pkg/wasm-pack-shim.mjs"() {
    init_typst_ts_renderer();
    init_typst_ts_renderer();
    init_typst_ts_renderer();
    wasm_pack_shim_default2 = typst_ts_renderer_default;
    nodeJsImportWasmModule2 = async function(wasm_name, url) {
      const escapeImport = new Function("m", "return import(m)");
      const path = await escapeImport("path");
      const { readFileSync } = await escapeImport("fs");
      const wasmPath = new URL(path.join(path.dirname(url), wasm_name));
      return await readFileSync(wasmPath).buffer;
    };
    isNode2 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
    if (isNode2) {
      setImportWasmModule2(nodeJsImportWasmModule2);
    }
  }
});

// dist/esm/renderer.mjs
var renderer_exports = {};
__export(renderer_exports, {
  RenderSession: () => RenderSession2,
  TypstRendererDriver: () => TypstRendererDriver,
  createTypstRenderer: () => createTypstRenderer,
  createTypstSvgRenderer: () => createTypstSvgRenderer,
  rendererBuildInfo: () => rendererBuildInfo
});
function createTypstRenderer() {
  return new TypstRendererDriver();
}
function createTypstSvgRenderer() {
  return new TypstRendererDriver();
}
async function rendererBuildInfo() {
  const renderModule = await Promise.resolve().then(() => (init_wasm_pack_shim2(), wasm_pack_shim_exports2));
  return renderModule.renderer_build_info();
}
var RenderSession2, gRendererModule, warnOnceCanvasSet, TypstRendererDriver;
var init_renderer = __esm({
  "dist/esm/renderer.mjs"() {
    init_internal_types();
    init_view();
    init_wasm();
    init_init();
    init_dom();
    RenderSession2 = class {
      /**
       * @internal
       */
      constructor(plugin, o) {
        this.plugin = plugin;
        this[kObject] = o;
      }
      /**
       * Set the background color of the Typst document.
       * @param {string} t - The background color in format of `^#?[0-9a-f]{6}$`
       *
       * Note: Default to `#ffffff`.
       *
       * Note: Only available in canvas rendering mode.
       */
      set backgroundColor(t) {
        if (t !== void 0) {
          this[kObject].background_color = t;
        }
      }
      /**
       * Get the background color of the Typst document.
       *
       * Note: Default to `#ffffff`.
       *
       * Note: Only available in canvas rendering mode.
       */
      get backgroundColor() {
        return this[kObject].background_color;
      }
      /**
       * Set the pixel per point scale up the canvas panel.
       *
       * Note: Default to `3`.
       *
       * Note: Only available in canvas rendering mode.
       */
      set pixelPerPt(t) {
        if (t !== void 0) {
          this[kObject].pixel_per_pt = t;
        }
      }
      /**
       * Get the pixel per point scale up the canvas panel.
       *
       * Note: Default to `3`.
       *
       * Note: Only available in canvas rendering mode.
       */
      get pixelPerPt() {
        return this[kObject].pixel_per_pt;
      }
      /**
       * Reset state
       */
      reset() {
        this.plugin.resetSession(this);
      }
      /**
       * @deprecated
       * use {@link docWidth} instead
       */
      get doc_width() {
        return this[kObject].doc_width;
      }
      get docWidth() {
        return this[kObject].doc_width;
      }
      /**
       * @deprecated
       * use {@link docHeight} instead
       */
      get doc_height() {
        return this[kObject].doc_height;
      }
      get docHeight() {
        return this[kObject].doc_height;
      }
      retrievePagesInfo() {
        const pages_info = this[kObject].pages_info;
        const pageInfos = [];
        const pageCount = pages_info.page_count;
        for (let i = 0; i < pageCount; i++) {
          const pageAst = pages_info.page(i);
          pageInfos.push({
            pageOffset: pageAst.page_off,
            width: pageAst.width_pt,
            height: pageAst.height_pt
          });
        }
        return pageInfos;
      }
      getSourceLoc(path) {
        return this[kObject].source_span(path);
      }
      /**
       * See {@link TypstRenderer#renderSvg} for more details.
       */
      renderSvg(options) {
        return this.plugin.renderSvg({
          renderSession: this,
          ...options
        });
      }
      /**
       * See {@link TypstRenderer#renderToSvg} for more details.
       */
      renderToSvg(options) {
        return this.plugin.renderToSvg({
          renderSession: this,
          ...options
        });
      }
      /**
       * See {@link TypstRenderer#renderCanvas} for more details.
       */
      renderCanvas(options) {
        return this.plugin.renderCanvas({
          renderSession: this,
          ...options
        });
      }
      /**
       * See {@link TypstRenderer#manipulateData} for more details.
       */
      manipulateData(opts) {
        this.plugin.manipulateData({
          renderSession: this,
          ...opts
        });
      }
      /**
       * See {@link TypstRenderer#renderSvgDiff} for more details.
       */
      renderSvgDiff(opts) {
        return this.plugin.renderSvgDiff({
          renderSession: this,
          ...opts
        });
      }
      /**
       * @deprecated
       * use {@link getSourceLoc} instead
       */
      get_source_loc(path) {
        return this[kObject].source_span(path);
      }
      /**
       * @deprecated
       * use {@link renderSvgDiff} instead
       */
      render_in_window(rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y) {
        return this[kObject].render_in_window(rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y);
      }
      /**
       * @deprecated
       * use {@link manipulateData} instead
       */
      merge_delta(data) {
        this.plugin.manipulateData({
          renderSession: this,
          action: "merge",
          data
        });
      }
    };
    gRendererModule = new LazyWasmModule(async (bin) => {
      const module2 = await Promise.resolve().then(() => (init_wasm_pack_shim2(), wasm_pack_shim_exports2));
      return await module2.default(bin);
    });
    warnOnceCanvasSet = true;
    TypstRendererDriver = class {
      constructor() {
      }
      async init(options) {
        this.rendererJs = await Promise.resolve().then(() => (init_wasm_pack_shim2(), wasm_pack_shim_exports2));
        const TypstRendererBuilder2 = this.rendererJs.TypstRendererBuilder;
        this.renderer = await buildComponent(options, gRendererModule, TypstRendererBuilder2, {});
      }
      loadGlyphPack(_pack) {
        return Promise.resolve();
      }
      createOptionsToRust(options) {
        const rustOptions = new this.rendererJs.CreateSessionOptions();
        if (options.format !== void 0) {
          rustOptions.format = options.format;
        }
        if (options.artifactContent !== void 0) {
          rustOptions.artifact_content = options.artifactContent;
        }
        return rustOptions;
      }
      retrievePagesInfoFromSession(session) {
        return session.retrievePagesInfo();
      }
      /**
       * Render a Typst document to canvas.
       */
      renderCanvas(options) {
        return this.withinOptionSession(options, async (sessionRef) => {
          const rustOptions = new this.rendererJs.RenderPageImageOptions();
          if (options.pageOffset !== void 0) {
            rustOptions.page_off = options.pageOffset;
          }
          if (options.cacheKey !== void 0) {
            rustOptions.cache_key = options.cacheKey;
          }
          if (options.dataSelection !== void 0) {
            let encoded = 0;
            if (options.dataSelection.body) {
              encoded |= 1 << 0;
            } else if (options.canvas && warnOnceCanvasSet) {
              warnOnceCanvasSet = false;
              console.warn("dataSelection.body is not set but providing canvas for body");
            }
            if (options.dataSelection.text || options.dataSelection.annotation) {
              console.error("dataSelection.text and dataSelection.annotation are deprecated");
            }
            if (options.dataSelection.semantics) {
              encoded |= 1 << 3;
            }
            rustOptions.data_selection = encoded;
          }
          return this.renderer.render_page_to_canvas(sessionRef[kObject], options.canvas || void 0, rustOptions);
        });
      }
      // async renderPdf(artifactContent: string): Promise<Uint8Array> {
      // return this.renderer.render_to_pdf(artifactContent);
      // }
      async inAnimationFrame(fn) {
        return new Promise((resolve, reject) => {
          requestAnimationFrame(() => {
            try {
              resolve(fn());
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async renderDisplayLayer(session, container, canvasList, options) {
        const pages_info = session[kObject].pages_info;
        const page_count = pages_info.page_count;
        const doRender = async (i, page_off) => {
          const canvas = canvasList[i];
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            throw new Error("canvas context is null");
          }
          return await this.renderCanvas({
            canvas: ctx,
            renderSession: session,
            pageOffset: page_off
          });
        };
        return this.inAnimationFrame(async () => {
          const t = performance.now();
          const textContentList = (await Promise.all(
            //   canvasList.map(async (canvas, i) => {
            //     await this.renderImageInSession(session, {
            //       page_off: i,
            //     });
            //     console.log(cyrb53(renderResult.data));
            //     let ctx = canvas.getContext('2d');
            //     if (ctx) {
            //       ctx.putImageData(renderResult, 0, 0);
            //     }
            //     return {
            //       width: renderResult.width,
            //       height: renderResult.height,
            //     };
            //   }),
            // )
            /// seq
            [
              (async () => {
                const results = [];
                for (let i = 0; i < page_count; i++) {
                  results.push(await doRender(i, i));
                }
                return results;
              })()
            ]
          ))[0];
          const t3 = performance.now();
          console.log(`display layer used: render = ${(t3 - t).toFixed(1)}ms`);
          return textContentList;
        });
      }
      renderTextLayer(layerList, textSourceList) {
        const t2 = performance.now();
        layerList.forEach((layer, i) => {
          layer.innerHTML = textSourceList[i].htmlSemantics[0];
        });
        const t3 = performance.now();
        console.log(`text layer used: render = ${(t3 - t2).toFixed(1)}ms`);
      }
      async render(options) {
        if ("format" in options) {
          if (options.format !== "vector") {
            const artifactFormats = ["serde_json", "js", "ir"];
            if (artifactFormats.includes(options.format)) {
              throw new Error(`deprecated format ${options.format}, please use vector format`);
            }
          }
        }
        return this.renderToCanvas(options);
      }
      async renderDom(options) {
        if ("format" in options) {
          if (options.format !== "vector") {
            const artifactFormats = ["serde_json", "js", "ir"];
            if (artifactFormats.includes(options.format)) {
              throw new Error(`deprecated format ${options.format}, please use vector format`);
            }
          }
        }
        return this.withinOptionSession(options, async (sessionRef) => {
          const t = new TypstDomDocument({
            ...options,
            renderMode: "dom",
            hookedElem: options.container,
            kModule: sessionRef,
            renderer: this
          });
          t;
          await t.impl.mountDom(options.pixelPerPt);
          return t;
        });
      }
      async renderToCanvas(options) {
        let session;
        let renderPageResults;
        const mountContainer = options.container;
        mountContainer.style.visibility = "hidden";
        const doRenderDisplayLayer = async (canvasList, resetLayout) => {
          try {
            renderPageResults = await this.renderDisplayLayer(session, mountContainer, canvasList, options);
            resetLayout();
          } finally {
            mountContainer.style.visibility = "visible";
          }
        };
        return this.withinOptionSession(options, async (sessionRef) => {
          session = sessionRef;
          if (session[kObject].pages_info.page_count === 0) {
            throw new Error(`No page found in session`);
          }
          if (options.pixelPerPt !== void 0 && options.pixelPerPt <= 0) {
            throw new Error("Invalid typst.RenderOptions.pixelPerPt, should be a positive number " + options.pixelPerPt);
          }
          let backgroundColor = options.backgroundColor;
          if (backgroundColor !== void 0) {
            if (!/^#[0-9a-f]{6}$/.test(backgroundColor)) {
              throw new Error("Invalid typst.backgroundColor color for matching ^#?[0-9a-f]{6}$ " + backgroundColor);
            }
          }
          session.pixelPerPt = options.pixelPerPt ?? TypstDefaultParams.PIXEL_PER_PT;
          session.backgroundColor = backgroundColor ?? "#ffffff";
          const t = performance.now();
          const pageView = new RenderView(this.retrievePagesInfoFromSession(session), mountContainer, options);
          const t2 = performance.now();
          console.log(`layer used: retieve = ${(t2 - t).toFixed(1)}ms`);
          await doRenderDisplayLayer(pageView.canvasList, () => pageView.resetLayout());
          this.renderTextLayer(pageView.textLayerList, renderPageResults);
          return;
        });
      }
      createModule(b) {
        return Promise.resolve(new RenderSession2(this, this.renderer.create_session(b && this.createOptionsToRust({
          format: "vector",
          artifactContent: b
        }))));
      }
      renderSvg(options, container) {
        if (options instanceof RenderSession2 || container) {
          throw new Error("removed api, please use renderToSvg({ renderSession, container }) instead");
        }
        return this.withinOptionSession(options, async (sessionRef) => {
          let parts = void 0;
          if (options.data_selection) {
            parts = 0;
            if (options.data_selection.body) {
              parts |= 1 << 0;
            }
            if (options.data_selection.defs) {
              parts |= 1 << 1;
            }
            if (options.data_selection.css) {
              parts |= 1 << 2;
            }
            if (options.data_selection.js) {
              parts |= 1 << 3;
            }
          }
          return Promise.resolve(this.renderer.svg_data(sessionRef[kObject], parts));
        });
      }
      renderSvgDiff(options) {
        if (!options.window) {
          return this.renderer.render_svg_diff(options.renderSession[kObject], 0, 0, 1e33, 1e33);
        }
        return this.renderer.render_svg_diff(options.renderSession[kObject], options.window.lo.x, options.window.lo.y, options.window.hi.x, options.window.hi.y);
      }
      renderToSvg(options) {
        return this.withinOptionSession(options, async (sessionRef) => {
          return Promise.resolve(this.renderer.render_svg(sessionRef[kObject], options.container));
        });
      }
      getCustomV1(options) {
        return Promise.resolve(this.renderer.get_customs(options.renderSession[kObject]));
      }
      resetSession(session) {
        return this.renderer.reset(session[kObject]);
      }
      manipulateData(opts) {
        return this.renderer.manipulate_data(opts.renderSession[kObject], opts.action ?? "reset", opts.data);
      }
      withinOptionSession(options, fn) {
        function isRenderByContentOption(options2) {
          return "artifactContent" in options2;
        }
        if ("renderSession" in options) {
          return fn(options.renderSession);
        }
        if (isRenderByContentOption(options)) {
          return this.runWithSession(options, fn);
        }
        throw new Error("Invalid render options, should be one of RenderByContentOptions|RenderBySessionOptions");
      }
      async runWithSession(arg1, arg2) {
        let options = arg1;
        let fn = arg2;
        if (!arg2) {
          options = void 0;
          fn = arg1;
        }
        const session = this.renderer.create_session(
          /* moved */
          options && this.createOptionsToRust(options)
        );
        try {
          const res = await fn(new RenderSession2(this, session));
          session.free();
          return res;
        } catch (e) {
          session.free();
          throw e;
        }
      }
    };
  }
});

// src/contrib/all-in-one-lite.mts
var all_in_one_lite_exports = {};
__export(all_in_one_lite_exports, {
  $typst: () => $typst,
  FetchAccessModel: () => FetchAccessModel,
  FetchPackageRegistry: () => FetchPackageRegistry,
  TypstSnippet: () => TypstSnippet,
  createTypstCompiler: () => createTypstCompiler2,
  createTypstRenderer: () => createTypstRenderer2,
  createTypstSvgRenderer: () => createTypstSvgRenderer2,
  preloadRemoteFonts: () => preloadRemoteFonts,
  preloadSystemFonts: () => preloadSystemFonts,
  rendererBuildInfo: () => rendererBuildInfo2
});
module.exports = __toCommonJS(all_in_one_lite_exports);

// src/options.init.mts
var BeforeBuildSymbol = Symbol("beforeBuild");
var _textFonts = [
  "LinLibertine_R.ttf",
  "LinLibertine_RB.ttf",
  "LinLibertine_RBI.ttf",
  "LinLibertine_RI.ttf",
  "NewCMMath-Book.otf",
  "NewCMMath-Regular.otf",
  "NewCM10-Regular.otf",
  "NewCM10-Bold.otf",
  "NewCM10-Italic.otf",
  "NewCM10-BoldItalic.otf",
  "DejaVuSansMono.ttf",
  "DejaVuSansMono-Bold.ttf",
  "DejaVuSansMono-Oblique.ttf",
  "DejaVuSansMono-BoldOblique.ttf"
];
var _cjkFonts = [
  "InriaSerif-Bold.ttf",
  "InriaSerif-BoldItalic.ttf",
  "InriaSerif-Italic.ttf",
  "InriaSerif-Regular.ttf",
  "Roboto-Regular.ttf",
  "NotoSerifCJKsc-Regular.otf"
];
var _emojiFonts = ["TwitterColorEmoji.ttf", "NotoColorEmoji.ttf"];
function preloadRemoteFonts(userFonts, options) {
  const fonts = [...userFonts];
  if (options && options?.assets !== false && options?.assets?.length && options?.assets?.length > 0) {
    let assetUrlPrefix = options.assetUrlPrefix ?? "https://raw.githubusercontent.com/Myriad-Dreamin/typst/assets-fonts";
    if (assetUrlPrefix[assetUrlPrefix.length - 1] !== "/") {
      assetUrlPrefix += "/";
    }
    const prefix = (f) => f.map((font) => assetUrlPrefix + font);
    for (const asset of options.assets) {
      switch (asset) {
        case "text":
          fonts.push(...prefix(_textFonts));
          break;
        case "cjk":
          fonts.push(...prefix(_cjkFonts));
          break;
        case "emoji":
          fonts.push(...prefix(_emojiFonts));
          break;
      }
    }
  }
  const loader = async (_, { ref, builder }) => {
    if (options?.fetcher) {
      ref.setFetcher(options.fetcher);
    }
    await ref.loadFonts(builder, fonts);
  };
  loader._preloadRemoteFontOptions = options;
  return loader;
}
function preloadSystemFonts({ byFamily }) {
  return async (_, { builder }) => {
    const t = performance.now();
    if ("queryLocalFonts" in window) {
      const fonts = await window.queryLocalFonts();
      byFamily = byFamily ?? [];
      for (const font of fonts) {
        if (!byFamily.includes(font.family)) {
          continue;
        }
        const data = await (await font.blob()).arrayBuffer();
        await builder.add_raw_font(new Uint8Array(data));
      }
    }
    const t2 = performance.now();
    console.log("preload system font time used:", t2 - t);
  };
}
function withPackageRegistry(packageRegistry) {
  return async (_, { builder }) => {
    return new Promise((resolve) => {
      builder.set_package_registry(packageRegistry, function(spec) {
        return packageRegistry.resolve(spec, this);
      });
      resolve();
    });
  };
}
function withAccessModel(accessModel) {
  return async (_, ctx) => {
    if (ctx.alreadySetAccessModel) {
      throw new Error(
        `already set some assess model before: ${ctx.alreadySetAccessModel.constructor?.name}(${ctx.alreadySetAccessModel})`
      );
    }
    ctx.alreadySetAccessModel = accessModel;
    return new Promise((resolve) => {
      ctx.builder.set_access_model(
        accessModel,
        (path) => {
          const lastModified = accessModel.getMTime(path);
          if (lastModified) {
            return lastModified.getTime();
          }
          return 0;
        },
        (path) => {
          return accessModel.isFile(path) || false;
        },
        (path) => {
          return accessModel.getRealPath(path) || path;
        },
        (path) => {
          return accessModel.readAll(path);
        }
      );
      resolve();
    });
  };
}

// src/fs/fetch.mts
var FetchAccessModel = class {
  constructor(root, options) {
    this.root = root;
    this.mTimes = /* @__PURE__ */ new Map();
    this.mRealPaths = /* @__PURE__ */ new Map();
    this.mData = /* @__PURE__ */ new Map();
    if (root.endsWith("/")) {
      this.root = this.root.slice(0, this.root.length - 1);
    }
    if (options?.polyfillHeadRequest) {
    }
    this.fullyCached = !!options?.fullyCached;
  }
  reset() {
    this.mTimes.clear();
    this.mRealPaths.clear();
    this.mData.clear();
  }
  resolvePath(path) {
    return this.root + path;
  }
  insertFile(path, data, mtime) {
    this.mTimes.set(path, mtime);
    this.mData.set(path, data);
  }
  removeFile(path) {
    this.mTimes.delete(path);
    this.mData.delete(path);
  }
  async getPreloadScript() {
    const snapshot = [];
    snapshot.push("((async () => {");
    snapshot.push(
      `const snapshot = {  root: '', mTimes: new Map(),  mRealPaths: new Map(),  mData: [],};`
    );
    snapshot.push(`const runFetch = async (path) => {`);
    snapshot.push(`  const res = await fetch(snapshot.root + path);`);
    snapshot.push(`  const buffer = await res.arrayBuffer();`);
    snapshot.push(`  return [path, new Uint8Array(buffer)];`);
    snapshot.push(`};`);
    snapshot.push(`snapshot.root = ${JSON.stringify(this.root)};`);
    snapshot.push(
      `snapshot.mTimes = new Map([${[...this.mTimes.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${v?.getTime() || "undefined"}]`).join(", ")}]);`
    );
    snapshot.push(
      `snapshot.mRealPaths = new Map([${[...this.mRealPaths.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${JSON.stringify(v)}]`).join(", ")}]);`
    );
    const dataEntries = await Promise.all(
      [...this.mData.entries()].map(async ([k, v]) => {
        k = JSON.stringify(k);
        return v ? `runFetch(${k})` : `Promise.resolve([${k}, undefined])`;
      })
    );
    snapshot.push(`snapshot.mData = await Promise.all([${dataEntries.join(", ")}]);`);
    snapshot.push(`return snapshot;`);
    snapshot.push("})())");
    return snapshot.join("\n");
  }
  getLastModified(path) {
    const request = new XMLHttpRequest();
    request.open("HEAD", path, false);
    request.send(null);
    if (request.status === 200) {
      return request.getResponseHeader("Last-Modified");
    }
    return null;
  }
  getMTimeInternal(path) {
    const lastModified = this.getLastModified(this.resolvePath(path));
    if (lastModified) {
      return new Date(lastModified);
    }
    return void 0;
  }
  getMTime(path) {
    if (path.startsWith("/@memory/")) {
      if (this.mTimes.has(path)) {
        return this.mTimes.get(path);
      }
      return void 0;
    }
    if (!this.fullyCached) {
      return this.getMTimeInternal(path);
    }
    if (this.mTimes.has(path)) {
      return this.mTimes.get(path);
    }
    const mTime = this.getMTimeInternal(path);
    this.mTimes.set(path, mTime);
    return mTime;
  }
  // todo: isFile
  isFile() {
    return true;
  }
  // todo: getRealPath
  getRealPath(path) {
    return path;
  }
  readAllInternal(path) {
    const request = new XMLHttpRequest();
    request.overrideMimeType("text/plain; charset=x-user-defined");
    request.open("GET", this.resolvePath(path), false);
    request.send(null);
    if (request.status === 200 && (request.response instanceof String || typeof request.response === "string")) {
      return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
    }
    return void 0;
  }
  readAll(path) {
    if (path.startsWith("/@memory/")) {
      if (this.mData.has(path)) {
        return this.mData.get(path);
      }
      return void 0;
    }
    if (!this.fullyCached) {
      return this.readAllInternal(path);
    }
    if (this.mData.has(path)) {
      return this.mData.get(path);
    }
    const data = this.readAllInternal(path);
    this.mData.set(path, data);
    return data;
  }
};

// src/fs/memory.mts
var MemoryAccessModel = class {
  constructor() {
    this.mTimes = /* @__PURE__ */ new Map();
    this.mData = /* @__PURE__ */ new Map();
  }
  reset() {
    this.mTimes.clear();
    this.mData.clear();
  }
  insertFile(path, data, mtime) {
    this.mTimes.set(path, mtime);
    this.mData.set(path, data);
  }
  removeFile(path) {
    this.mTimes.delete(path);
    this.mData.delete(path);
  }
  getMTime(path) {
    if (!path.startsWith("/@memory/")) {
      return void 0;
    }
    if (this.mTimes.has(path)) {
      return this.mTimes.get(path);
    }
    return void 0;
  }
  isFile() {
    return true;
  }
  getRealPath(path) {
    return path;
  }
  readAll(path) {
    if (!path.startsWith("/@memory/")) {
      return void 0;
    }
    if (this.mData.has(path)) {
      return this.mData.get(path);
    }
    return void 0;
  }
};

// src/fs/package.mts
var FetchPackageRegistry = class {
  constructor(am) {
    this.am = am;
    this.cache = /* @__PURE__ */ new Map();
  }
  resolvePath(path) {
    return `https://packages.typst.org/preview/${path.name}-${path.version}.tar.gz`;
  }
  pullPackageData(path) {
    const request = new XMLHttpRequest();
    request.overrideMimeType("text/plain; charset=x-user-defined");
    request.open("GET", this.resolvePath(path), false);
    request.send(null);
    if (request.status === 200 && (request.response instanceof String || typeof request.response === "string")) {
      return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
    }
    return void 0;
  }
  resolve(spec, context) {
    if (spec.namespace !== "preview") {
      return void 0;
    }
    const path = this.resolvePath(spec);
    if (this.cache.has(path)) {
      return this.cache.get(path)();
    }
    const data = this.pullPackageData(spec);
    if (!data) {
      return void 0;
    }
    const previewDir = `/@memory/fetch/packages/preview/${spec.namespace}/${spec.name}/${spec.version}`;
    const entries = [];
    context.untar(data, (path2, data2, mtime) => {
      entries.push([previewDir + "/" + path2, data2, new Date(mtime)]);
    });
    const cacheClosure = () => {
      for (const [path2, data2, mtime] of entries) {
        this.am.insertFile(path2, data2, mtime);
      }
      return previewDir;
    };
    this.cache.set(path, cacheClosure);
    return cacheClosure();
  }
};

// src/utils.mts
function randstr(prefix) {
  return Math.random().toString(36).replace("0.", prefix || "");
}

// src/contrib/snippet.mts
var isNode3 = (
  // @ts-ignore
  typeof process !== "undefined" && process.versions != null && process.versions.node != null
);
var TypstSnippet = class {
  /**
   * Create a new instance of {@link TypstSnippet}.
   * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
   * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
   *
   * @example
   *
   * Passes a global shared compiler instance that get initialized lazily:
   * ```typescript
   * const $typst = new TypstSnippet(() => {
   *  return createGlobalCompiler(createTypstCompiler, initOptions);
   * });
   *
   */
  constructor(options) {
    this.cc = options?.compiler;
    this.ex = options?.renderer;
    this.mainFilePath = "/main.typ";
    this.providers = [];
  }
  /**
   * Set lazy initialized compiler instance for the utility instance.
   * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
   */
  setCompiler(cc) {
    this.cc = cc;
  }
  /**
   * Get an initialized compiler instance from the utility instance.
   */
  async getCompiler() {
    return typeof this.cc === "function" ? this.cc = await this.cc() : this.cc;
  }
  /**
   * Set lazy initialized renderer instance for the utility instance.
   * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
   */
  setRenderer(ex) {
    this.ex = ex;
  }
  /**
   * Get an initialized renderer instance from the utility instance.
   */
  async getRenderer() {
    return typeof this.ex === "function" ? this.ex = await this.ex() : this.ex;
  }
  /**
   * add providers for bullding the compiler or renderer component.
   */
  use(...providers) {
    if (!this.providers) {
      throw new Error("already prepare uses for instances");
    }
    this.providers.push(...providers);
  }
  /**
   * Set accessl model for the compiler instance
   * @example
   *
   * use memory access model
   *
   * ```typescript
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m));
   * ```
   */
  static withAccessModel(accessModel) {
    return {
      key: "access-model",
      forRoles: ["compiler"],
      provides: [withAccessModel(accessModel)]
    };
  }
  /**
   * Set package registry for the compiler instance
   * @example
   *
   * use a customized package registry
   *
   * ```typescript
   * const n = new NodeFetchPackageRegistry();
   * $typst.use(TypstSnippet.withPackageRegistry(n));
   * ```
   */
  static withPackageRegistry(registry) {
    return {
      key: "package-registry",
      forRoles: ["compiler"],
      provides: [withPackageRegistry(registry)]
    };
  }
  /**
   * Retrieve an access model to store the data of fetched files.
   * Provide a PackageRegistry instance for the compiler instance.
   *
   * @example
   *
   * use default (memory) access model
   *
   * ```typescript
   * $typst.use(await TypstSnippet.fetchPackageRegistry());
   * ```
   *
   * @example
   *
   * use external access model
   *
   * ```typescript
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
   * ```
   */
  static fetchPackageRegistry(accessModel) {
    const m = accessModel || new MemoryAccessModel();
    const provides = [
      ...accessModel ? [] : [withAccessModel(m)],
      withPackageRegistry(new FetchPackageRegistry(m))
    ];
    return {
      key: "package-registry$fetch",
      forRoles: ["compiler"],
      provides
    };
  }
  /**
   * Retrieve a fetcher for fetching package data.
   * Provide a PackageRegistry instance for the compiler instance.
   * @example
   *
   * use a customized fetcher
   *
   * ```typescript
   * import request from 'sync-request-curl';
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
   *   const response = request('GET', this.resolvePath(path), {
   *     insecure: true,
   *   });
   *
   *   if (response.statusCode === 200) {
   *     return response.getBody(undefined);
   *   }
   *   return undefined;
   * }));
   * ```
   */
  static fetchPackageBy(accessModel, fetcher) {
    class HttpPackageRegistry extends FetchPackageRegistry {
      pullPackageData(path) {
        return fetcher(path, this.resolvePath(path));
      }
    }
    return {
      key: "package-registry$lambda",
      forRoles: ["compiler"],
      provides: [withPackageRegistry(new HttpPackageRegistry(accessModel))]
    };
  }
  /**
   * Set compiler init options for initializing global instance {@link $typst}.
   * See {@link InitOptions}.
   */
  setCompilerInitOptions(options) {
    this.requireIsUninitialized("compiler", this.cc, TypstSnippet.$buildC);
    this.ccOptions = options;
  }
  /**
   * Set renderer init options for initializing global instance {@link $typst}.
   * See {@link InitOptions}.
   */
  setRendererInitOptions(options) {
    this.requireIsUninitialized("renderer", this.ex, TypstSnippet.$buildR);
    this.exOptions = options;
  }
  /**
   * Set shared main file path.
   */
  setMainFilePath(path) {
    this.mainFilePath = path;
  }
  /**
   * Get shared main file path.
   */
  getMainFilePath() {
    return this.mainFilePath;
  }
  removeTmp(opts) {
    if (opts.mainFilePath.startsWith("/tmp/")) {
      return this.unmapShadow(opts.mainFilePath);
    }
    return Promise.resolve();
  }
  /**
   * Add a source file to the compiler.
   * See {@link TypstCompiler#addSource}.
   */
  async addSource(path, content) {
    (await this.getCompiler()).addSource(path, content);
  }
  /**
   * Reset the shadow files.
   * Note: this function is independent to the {@link reset} function.
   * See {@link TypstCompiler#resetShadow}.
   */
  async resetShadow() {
    (await this.getCompiler()).resetShadow();
  }
  /**
   * Add a shadow file to the compiler.
   * See {@link TypstCompiler#mapShadow}.
   */
  async mapShadow(path, content) {
    (await this.getCompiler()).mapShadow(path, content);
  }
  /**
   * Remove a shadow file from the compiler.
   * See {@link TypstCompiler#unmapShadow}.
   */
  async unmapShadow(path) {
    (await this.getCompiler()).unmapShadow(path);
  }
  /**
   * Compile the document to vector (IR) format.
   * See {@link SweetCompileOptions}.
   */
  async vector(o) {
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).compile(opts).then((res) => res.result).finally(() => this.removeTmp(opts));
  }
  /**
   * Compile the document to PDF format.
   * See {@link SweetCompileOptions}.
   */
  async pdf(o) {
    const opts = await this.getCompileOptions(o);
    opts.format = "pdf";
    return (await this.getCompiler()).compile(opts).then((res) => res.result).finally(() => this.removeTmp(opts));
  }
  /**
   * Compile the document to SVG format.
   * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
   */
  async svg(o) {
    return this.transientRender(
      o,
      (renderer, renderSession) => renderer.renderSvg({
        ...o,
        renderSession
      })
    );
  }
  /**
   * Compile the document to canvas operations.
   * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
   */
  async canvas(container, o) {
    return this.transientRender(
      o,
      (renderer, renderSession) => renderer.renderToCanvas({
        container,
        ...o,
        renderSession
      })
    );
  }
  /**
   * Get semantic tokens for the document.
   */
  async query(o) {
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).query({
      ...o,
      ...opts
    }).finally(() => this.removeTmp(opts));
  }
  /**
   * Get token legend for semantic tokens.
   */
  async getSemanticTokenLegend() {
    return (await this.getCompiler()).getSemanticTokenLegend();
  }
  /**
   * Get semantic tokens for the document.
   * See {@link SweetCompileOptions}.
   * See {@link TypstCompiler#getSemanticTokens}.
   */
  async getSemanticTokens(o) {
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).getSemanticTokens({
      mainFilePath: opts.mainFilePath,
      resultId: o.resultId
    }).finally(() => this.removeTmp(opts));
  }
  async getCompileOptions(opts) {
    if (opts === void 0) {
      return { mainFilePath: this.mainFilePath, diagnostics: "none" };
    } else if (typeof opts === "string") {
      throw new Error(`please specify opts as {mainContent: '...'} or {mainFilePath: '...'}`);
    } else if ("mainFilePath" in opts) {
      return { ...opts, diagnostics: "none" };
    } else {
      const destFile = `/tmp/${randstr()}.typ`;
      await this.addSource(destFile, opts.mainContent);
      return { mainFilePath: destFile, diagnostics: "none" };
    }
  }
  async getVector(o) {
    if (o && "vectorData" in o) {
      return o.vectorData;
    }
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).compile(opts).then((res) => res.result).finally(() => this.removeTmp(opts));
  }
  async transientRender(opts, f) {
    const rr = await this.getRenderer();
    if (!rr) {
      throw new Error("does not provide renderer instance");
    }
    const data = await this.getVector(opts);
    return await rr.runWithSession(async (session) => {
      rr.manipulateData({
        renderSession: session,
        action: "reset",
        data
      });
      return f(rr, session);
    });
  }
  async prepareUse() {
    if (!this.providers) {
      return;
    }
    const providers = await Promise.all(
      this.providers.map((p) => typeof p === "function" ? p() : p)
    );
    this.providers = [];
    if ($typst == this && !providers.some((p) => p.key.includes("package-registry") || p.key.includes("access-model"))) {
      if (isNode3) {
        const escapeImport = new Function("m", "return import(m)");
        try {
          const m = new MemoryAccessModel();
          const { default: request } = await escapeImport("sync-request");
          $typst.use(
            TypstSnippet.withAccessModel(m),
            TypstSnippet.fetchPackageBy(m, (_, path) => {
              const response = request("GET", path);
              if (response.statusCode === 200) {
                return response.getBody(void 0);
              }
              return void 0;
            })
          );
        } catch (e) {
        }
      } else {
        $typst.use(TypstSnippet.fetchPackageRegistry());
      }
    }
    const providers2 = await Promise.all(
      this.providers.map((p) => typeof p === "function" ? p() : p)
    );
    const ccOptions = this.ccOptions || (this.ccOptions = {});
    const ccBeforeBuild = ccOptions.beforeBuild || (ccOptions.beforeBuild = []);
    const exOptions = this.exOptions || (this.exOptions = {});
    const exBeforeBuild = exOptions.beforeBuild || (exOptions.beforeBuild = []);
    for (const provider of [...providers, ...providers2]) {
      if (provider.forRoles.includes("compiler")) {
        this.requireIsUninitialized("compiler", this.cc, TypstSnippet.$buildC);
        ccBeforeBuild.push(...provider.provides);
      }
      if (provider.forRoles.includes("renderer")) {
        this.requireIsUninitialized("renderer", this.ex, TypstSnippet.$buildR);
        exBeforeBuild.push(...provider.provides);
      }
    }
    this.providers = void 0;
  }
  requireIsUninitialized(role, c, e) {
    if (typeof c !== "function") {
      throw new Error(`${role} has been initialized: ${c}`);
    }
    if (e && c != e) {
      throw new Error(`${role} instance is set to non default value`);
    }
  }
  /** @internal */
  static async $buildC() {
    const { createGlobalCompiler: createGlobalCompiler2 } = await Promise.resolve().then(() => (init_global_compiler(), global_compiler_exports));
    const { createTypstCompiler: createTypstCompiler3 } = await Promise.resolve().then(() => (init_compiler(), compiler_exports));
    await this.prepareUse();
    return createGlobalCompiler2(createTypstCompiler3, this.ccOptions);
  }
  /** @internal */
  static async $buildR() {
    const { createGlobalRenderer: createGlobalRenderer2 } = await Promise.resolve().then(() => (init_global_renderer(), global_renderer_exports));
    const { createTypstRenderer: createTypstRenderer3 } = await Promise.resolve().then(() => (init_renderer(), renderer_exports));
    await this.prepareUse();
    return createGlobalRenderer2(createTypstRenderer3, this.exOptions);
  }
};
var $typst = new TypstSnippet({
  compiler: TypstSnippet.$buildC,
  renderer: TypstSnippet.$buildR
});

// src/internal.types.mts
var kObject2 = Symbol.for("reflexo-obj");

// src/render/canvas/view.mts
var RenderView2 = class {
  constructor(pageInfos, container, options) {
    this.pageInfos = pageInfos;
    this.imageScaleFactor = options.pixelPerPt ?? 3 /* PIXEL_PER_PT */;
    container.innerHTML = "";
    container.style.width = "100%";
    this.container = container;
    this.canvasList = new Array(this.loadPageCount);
    this.textLayerList = new Array(this.loadPageCount);
    this.commonList = new Array(this.loadPageCount);
    this.textLayerParentList = new Array(this.loadPageCount);
    this.semanticLayerList = new Array(this.loadPageCount);
    const createOver = (i, pageAst, commonDiv) => {
      const width = Math.ceil(pageAst.width) * this.imageScaleFactor;
      const height = Math.ceil(pageAst.height) * this.imageScaleFactor;
      const canvas = this.canvasList[i] = document.createElement("canvas");
      const semanticLayer = this.semanticLayerList[i] = document.createElement("div");
      const textLayer = this.textLayerList[i] = document.createElement("div");
      const textLayerParent = this.textLayerParentList[i] = document.createElement("div");
      const ctx = canvas.getContext("2d");
      if (ctx) {
        const canvasDiv = document.createElement("div");
        canvas.width = width;
        canvas.height = height;
        canvasDiv.appendChild(canvas);
        commonDiv.appendChild(canvasDiv);
        canvasDiv.style.position = "absolute";
      }
      {
        textLayerParent.appendChild(textLayer);
        textLayerParent.className = "typst-html-semantics";
        const containerWidth = container.offsetWidth;
        const orignalScale = containerWidth / pageAst.width;
        textLayerParent.style.width = `${containerWidth}px`;
        textLayerParent.style.height = `${pageAst.height * orignalScale}px`;
        textLayerParent.style.setProperty("--data-text-width", `${orignalScale}px`);
        textLayerParent.style.setProperty("--data-text-height", `${orignalScale}px`);
        commonDiv.classList.add("typst-page");
        commonDiv.classList.add("canvas");
        commonDiv.style.width = `${containerWidth}px`;
        commonDiv.style.height = `${height * orignalScale}px`;
        commonDiv.style.position = "relative";
        semanticLayer.appendChild(textLayerParent);
        commonDiv.appendChild(semanticLayer);
      }
    };
    for (let i = 0; i < this.pageInfos.length; i++) {
      const pageAst = this.pageInfos[i];
      let commonDiv = void 0;
      commonDiv = this.commonList[i] = document.createElement("div");
      container.appendChild(commonDiv);
      createOver(i, pageAst, commonDiv);
    }
  }
  resetLayout() {
    for (let i = 0; i < this.pageInfos.length; i++) {
      const pageAst = this.pageInfos[i];
      const width = Math.ceil(pageAst.width) * this.imageScaleFactor;
      const height = Math.ceil(pageAst.height) * this.imageScaleFactor;
      const canvasDiv = this.canvasList[i].parentElement;
      if (!canvasDiv) {
        throw new Error(
          `canvasDiv is null for page ${i}, canvas list length ${this.canvasList.length}`
        );
      }
      const commonDiv = this.commonList[i];
      const textLayerParent = this.textLayerParentList[i];
      const containerWidth = this.container.offsetWidth;
      const orignalScale = containerWidth / width;
      textLayerParent.style.width = `${containerWidth}px`;
      textLayerParent.style.height = `${height * orignalScale}px`;
      commonDiv.style.width = `${containerWidth}px`;
      commonDiv.style.height = `${height * orignalScale}px`;
      const currentScale = this.container.offsetWidth / width;
      canvasDiv.style.transformOrigin = "0px 0px";
      canvasDiv.style.transform = `scale(${currentScale})`;
    }
  }
};

// src/wasm.mts
var once2 = (fn) => {
  let called = false;
  let res;
  return () => {
    if (called) {
      return res;
    }
    called = true;
    return res = fn();
  };
};
var LazyWasmModule2 = class {
  constructor(initFn) {
    if (typeof initFn !== "function") {
      throw new Error("initFn is not a function");
    }
    this.initOnce = once2(async () => {
      await initFn(this.wasmBin);
    });
  }
  async init(module2) {
    this.wasmBin = module2;
    await this.initOnce();
  }
};

// src/init.mts
init_build();
var ComponentBuilder2 = class {
  constructor() {
    this.loadedFonts = /* @__PURE__ */ new Set();
    this.fetcher = fetch;
  }
  setFetcher(fetcher) {
    this.fetcher = fetcher;
  }
  async loadFonts(builder, fonts) {
    const escapeImport = new Function("m", "return import(m)");
    const fetcher = this.fetcher || (this.fetcher = await async function() {
      const { fetchBuilder, FileSystemCache } = await escapeImport("node-fetch-cache");
      const cache = new FileSystemCache({
        /// By default, we don't have a complicated cache policy.
        cacheDirectory: ".cache/typst/fonts"
      });
      const cachedFetcher = fetchBuilder.withCache(cache);
      return function(input, init) {
        const timeout = setTimeout(() => {
          console.warn("font fetching is stucking:", input);
        }, 15e3);
        return cachedFetcher(input, init).finally(() => {
          clearTimeout(timeout);
        });
      };
    }());
    const fontsToLoad = fonts.filter((font) => {
      if (font instanceof Uint8Array) {
        return true;
      }
      if (this.loadedFonts.has(font)) {
        return false;
      }
      this.loadedFonts.add(font);
      return true;
    });
    const fontLists = await Promise.all(
      fontsToLoad.map(async (font) => {
        if (font instanceof Uint8Array) {
          await builder.add_raw_font(font);
          return;
        }
        return new Uint8Array(await (await fetcher(font)).arrayBuffer());
      })
    );
    for (const font of fontLists) {
      if (!font) {
        continue;
      }
      await builder.add_raw_font(font);
    }
  }
  async build(options, builder, hooks) {
    const buildCtx = { ref: this, builder, hooks };
    for (const fn of options?.beforeBuild ?? []) {
      await fn(void 0, buildCtx);
    }
    if (hooks.latelyBuild) {
      hooks.latelyBuild(buildCtx);
    }
    const component = await builder.build();
    return component;
  }
};
async function buildComponent2(options, gModule, Builder, hooks) {
  await gModule.init(options?.getModule?.());
  return await new ComponentBuilder2().build(options, new Builder(), hooks);
}

// src/contrib/dom/typst-doc.mts
var TypstDocumentContext2 = class {
  constructor(opts) {
    this.modes = [];
    /// Configuration fields
    /// enable partial rendering
    this.partialRendering = true;
    /// underlying renderer
    this.renderMode = "svg";
    this.r = void 0;
    /// preview mode
    this.previewMode = 0 /* Doc */;
    /// whether this is a content preview
    this.isContentPreview = false;
    /// whether this content preview will mix outline titles
    this.isMixinOutline = false;
    /// background color
    this.backgroundColor = "black";
    /// default page color (empty string means transparent)
    this.pageColor = "white";
    /// pixel per pt
    this.pixelPerPt = 3;
    /// State fields
    /// whether svg is updating (in triggerSvgUpdate)
    this.isRendering = false;
    /// whether kModule is initialized
    this.moduleInitialized = false;
    /// patch queue for updating data.
    this.patchQueue = [];
    /// resources to dispose
    this.disposeList = [];
    /// There are two scales in this class: The real scale is to adjust the size
    /// of `hookedElem` to fit the svg. The virtual scale (scale ratio) is to let
    /// user zoom in/out the svg. For example:
    /// + the default value of virtual scale is 1, which means the svg is totally
    ///   fit in `hookedElem`.
    /// + if user set virtual scale to 0.5, then the svg will be zoomed out to fit
    ///   in half width of `hookedElem`. "real" current scale of `hookedElem`
    this.currentRealScale = 1;
    /// "virtual" current scale of `hookedElem`
    this.currentScaleRatio = 1;
    /// timeout for delayed viewport change
    this.vpTimeout = void 0;
    /// sampled by last render time.
    this.sampledRenderTime = 0;
    /// page to partial render
    this.partialRenderPage = 0;
    /// outline data
    this.outline = void 0;
    /// cursor position in form of [page, x, y]
    this.cursorPosition = void 0;
    // id: number = rnd++;
    /// Cache fields
    /// cached state of container, default to retrieve state from `this.hookedElem`
    this.cachedDOMState = {
      width: 0,
      height: 0,
      window: {
        innerWidth: 0,
        innerHeight: 0
      },
      boundingRect: {
        left: 0,
        top: 0,
        right: 0
      }
    };
    this.hookedElem = opts.hookedElem;
    this.kModule = opts.kModule;
    this.opts = opts || {};
    {
      const { renderMode, previewMode, isContentPreview, retrieveDOMState } = opts || {};
      this.partialRendering = false;
      this.renderMode = renderMode ?? this.renderMode;
      this.previewMode = previewMode ?? this.previewMode;
      this.isContentPreview = isContentPreview || false;
      this.retrieveDOMState = retrieveDOMState ?? (() => {
        return {
          width: this.hookedElem.offsetWidth,
          height: this.hookedElem.offsetHeight,
          window: {
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight
          },
          boundingRect: this.hookedElem.getBoundingClientRect()
        };
      });
      this.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(
        "--typst-preview-background-color"
      );
    }
    this.hookedElem.classList.add("hide-scrollbar-x");
    this.hookedElem.parentElement?.classList.add("hide-scrollbar-x");
    if (this.previewMode === 1 /* Slide */) {
      this.hookedElem.classList.add("hide-scrollbar-y");
      this.hookedElem.parentElement?.classList.add("hide-scrollbar-y");
    }
    this.installCtrlWheelHandler();
  }
  reset() {
    this.kModule.reset();
    this.moduleInitialized = false;
  }
  dispose() {
    const disposeList = this.disposeList;
    this.disposeList = [];
    disposeList.forEach((x) => x());
  }
  static derive(ctx, mode) {
    return ["rescale", "rerender", "postRender"].reduce((acc, x) => {
      acc[x] = ctx[`${x}$${mode}`].bind(ctx);
      console.assert(acc[x] !== void 0, `${x}$${mode} is undefined`);
      return acc;
    }, {});
  }
  registerMode(mode) {
    const facade = TypstDocumentContext2.derive(this, mode);
    this.modes.push([mode, facade]);
    if (mode === this.renderMode) {
      this.r = facade;
    }
  }
  installCtrlWheelHandler() {
    const factors = [
      0.1,
      0.2,
      0.3,
      0.4,
      0.5,
      0.6,
      0.7,
      0.8,
      0.9,
      1,
      1.1,
      1.3,
      1.5,
      1.7,
      1.9,
      2.1,
      2.4,
      2.7,
      3,
      3.3,
      3.7,
      4.1,
      4.6,
      5.1,
      5.7,
      6.3,
      7,
      7.7,
      8.5,
      9.4,
      10
    ];
    const wheelEventHandler = (event) => {
      if (event.ctrlKey) {
        event.preventDefault();
        this.cachedDOMState = this.retrieveDOMState();
        if (window.onresize !== null) {
          window.onresize = null;
        }
        const prevScaleRatio = this.currentScaleRatio;
        if (event.deltaY < 0) {
          if (this.currentScaleRatio >= factors.at(-1)) {
            return;
          } else {
            this.currentScaleRatio = factors.filter((x) => x > this.currentScaleRatio).at(0);
          }
        } else if (event.deltaY > 0) {
          if (this.currentScaleRatio <= factors.at(0)) {
            return;
          } else {
            this.currentScaleRatio = factors.filter((x) => x < this.currentScaleRatio).at(-1);
          }
        } else {
          return;
        }
        const scrollFactor = this.currentScaleRatio / prevScaleRatio;
        const scrollX = event.pageX * (scrollFactor - 1);
        const scrollY = event.pageY * (scrollFactor - 1);
        if (Math.abs(this.currentScaleRatio - 1) < 1e-5) {
          this.hookedElem.classList.add("hide-scrollbar-x");
          this.hookedElem.parentElement?.classList.add("hide-scrollbar-x");
          if (this.previewMode === 1 /* Slide */) {
            this.hookedElem.classList.add("hide-scrollbar-y");
            this.hookedElem.parentElement?.classList.add("hide-scrollbar-y");
          }
        } else {
          this.hookedElem.classList.remove("hide-scrollbar-x");
          this.hookedElem.parentElement?.classList.remove("hide-scrollbar-x");
          if (this.previewMode === 1 /* Slide */) {
            this.hookedElem.classList.remove("hide-scrollbar-y");
            this.hookedElem.parentElement?.classList.remove("hide-scrollbar-y");
          }
        }
        const svg = this.hookedElem.firstElementChild;
        if (svg) {
          const scaleRatio = this.getSvgScaleRatio();
          const dataHeight = Number.parseFloat(svg.getAttribute("data-height"));
          const scaledHeight = Math.ceil(dataHeight * scaleRatio);
          this.hookedElem.style.height = `${scaledHeight * 2}px`;
        }
        window.scrollBy(scrollX, scrollY);
        this.addViewportChange();
        return false;
      }
    };
    if (this.renderMode !== "dom") {
      const vscodeAPI = typeof acquireVsCodeApi !== "undefined";
      if (vscodeAPI) {
        window.addEventListener("wheel", wheelEventHandler, {
          passive: false
        });
        this.disposeList.push(() => {
          window.removeEventListener("wheel", wheelEventHandler);
        });
      } else {
        document.body.addEventListener("wheel", wheelEventHandler, {
          passive: false
        });
        this.disposeList.push(() => {
          document.body.removeEventListener("wheel", wheelEventHandler);
        });
      }
    }
  }
  /// Get current scale from html to svg
  // Note: one should retrieve dom state before rescale
  getSvgScaleRatio() {
    const svg = this.hookedElem.firstElementChild;
    if (!svg) {
      return 0;
    }
    const container = this.cachedDOMState;
    const svgWidth = Number.parseFloat(
      svg.getAttribute("data-width") || svg.getAttribute("width") || "1"
    );
    const svgHeight = Number.parseFloat(
      svg.getAttribute("data-height") || svg.getAttribute("height") || "1"
    );
    this.currentRealScale = this.previewMode === 1 /* Slide */ ? Math.min(container.width / svgWidth, container.height / svgHeight) : container.width / svgWidth;
    return this.currentRealScale * this.currentScaleRatio;
  }
  processQueue(svgUpdateEvent) {
    const eventName = svgUpdateEvent[0];
    switch (eventName) {
      case "new":
      case "diff-v1": {
        if (eventName === "new") {
          this.reset();
        }
        this.kModule.manipulateData({
          action: "merge",
          data: svgUpdateEvent[1]
        });
        this.moduleInitialized = true;
        return true;
      }
      case "viewport-change": {
        if (!this.moduleInitialized) {
          console.log("viewport-change before initialization");
          return false;
        }
        return true;
      }
      default:
        console.log("svgUpdateEvent", svgUpdateEvent);
        return false;
    }
  }
  triggerUpdate() {
    if (this.isRendering) {
      return;
    }
    this.isRendering = true;
    const doUpdate = async () => {
      this.cachedDOMState = this.retrieveDOMState();
      if (this.patchQueue.length === 0) {
        this.isRendering = false;
        this.postprocessChanges();
        return;
      }
      try {
        let t0 = performance.now();
        const ctoken = this.canvasRenderCToken;
        if (ctoken) {
          await ctoken.cancel();
          await ctoken.wait();
          this.canvasRenderCToken = void 0;
          console.log("cancel canvas rendering");
        }
        let needRerender = false;
        while (this.patchQueue.length > 0) {
          needRerender = this.processQueue(this.patchQueue.shift()) || needRerender;
        }
        let t1 = performance.now();
        if (needRerender) {
          this.r.rescale();
          await this.r.rerender();
          this.r.rescale();
        }
        let t2 = performance.now();
        const d = (e, x, y) => `${e} ${(y - x).toFixed(2)} ms`;
        this.sampledRenderTime = t2 - t0;
        console.log([d("parse", t0, t1), d("rerender", t1, t2), d("total", t0, t2)].join(", "));
        requestAnimationFrame(doUpdate);
      } catch (e) {
        console.error(e);
        this.isRendering = false;
        this.postprocessChanges();
      }
    };
    requestAnimationFrame(doUpdate);
  }
  postprocessChanges() {
    this.r.postRender();
    if (this.previewMode === 1 /* Slide */) {
      document.querySelectorAll(".typst-page-number-indicator").forEach((x) => {
        x.textContent = `${this.kModule.retrievePagesInfo().length}`;
      });
    }
  }
  addChangement(change) {
    if (change[0] === "new") {
      this.patchQueue.splice(0, this.patchQueue.length);
    }
    const pushChange = () => {
      this.vpTimeout = void 0;
      this.patchQueue.push(change);
      this.triggerUpdate();
    };
    if (this.vpTimeout !== void 0) {
      clearTimeout(this.vpTimeout);
    }
    if (change[0] === "viewport-change" && this.isRendering) {
      this.vpTimeout = setTimeout(pushChange, this.sampledRenderTime || 100);
    } else {
      pushChange();
    }
  }
  addViewportChange() {
    this.addChangement(["viewport-change", ""]);
  }
};
function provideDoc2(Base) {
  return class TypstDocument {
    constructor(options) {
      if (options.isContentPreview) {
        options.renderMode = "canvas";
      }
      this.kModule = options.kModule;
      this.impl = new Base(options);
      if (!this.impl.r) {
        throw new Error(`mode is not supported, ${options?.renderMode}`);
      }
      if (options.isContentPreview) {
        this.impl.partialRendering = true;
        this.impl.pixelPerPt = 1;
        this.impl.isMixinOutline = true;
      }
    }
    dispose() {
      this.impl.dispose();
    }
    reset() {
      this.impl.reset();
    }
    addChangement(change) {
      this.impl.addChangement(change);
    }
    addViewportChange() {
      this.impl.addViewportChange();
    }
    setPageColor(color) {
      this.impl.pageColor = color;
      this.addViewportChange();
    }
    setPartialRendering(partialRendering) {
      this.impl.partialRendering = partialRendering;
    }
    setCursor(page, x, y) {
      this.impl.cursorPosition = [page, x, y];
    }
    setPartialPageNumber(page) {
      if (page <= 0 || page > this.kModule.retrievePagesInfo().length) {
        return false;
      }
      this.impl.partialRenderPage = page - 1;
      this.addViewportChange();
      return true;
    }
    getPartialPageNumber() {
      return this.impl.partialRenderPage + 1;
    }
    setOutineData(outline) {
      this.impl.outline = outline;
      this.addViewportChange();
    }
  };
}
function composeDoc2(Base, ...mixins) {
  return mixins.reduce((acc, mixin) => mixin(acc), Base);
}

// src/contrib/dom/typst-cancel.mts
var TypstCancellationToken2 = class {
  constructor() {
    this.isCancellationRequested = false;
    let resolveT = void 0;
    let resolveX = void 0;
    this._onCancelled = new Promise((resolve) => {
      resolveT = resolve;
      if (resolveX) {
        resolveX(resolve);
      }
    });
    this._onCancelledResolveResolved = new Promise((resolve) => {
      resolveX = resolve;
      if (resolveT) {
        resolve(resolveT);
      }
    });
  }
  async cancel() {
    await this._onCancelledResolveResolved;
    this.isCancellationRequested = true;
  }
  isCancelRequested() {
    return this.isCancellationRequested;
  }
  async consume() {
    (await this._onCancelledResolveResolved)();
  }
  wait() {
    return this._onCancelled;
  }
};

// src/dom.mts
var animationFrame2 = () => new Promise((resolve) => requestAnimationFrame(resolve));
function provideDomDoc2(Base) {
  return class DomDocument extends Base {
    constructor(...args) {
      super(...args);
      /// The template element for creating DOM by string.
      this.tmpl = document.createElement("template");
      /// The stub element for replacing an invisible element.
      this.stub = this.createElement("<stub></stub>");
      /// The element to track.
      this.resourceHeader = void 0;
      /// Expected exact state of the current DOM.
      /// Initially it is empty meaning no any page is rendered.
      this.pages = [];
      /// The virtual scale of the document.
      this.domScale = 1;
      /// Track mode.
      this.track_mode = 0 /* Doc */;
      /// Current executing task.
      this.current_task = void 0;
      this.registerMode("dom");
      this.disposeList.push(() => {
        this.dispose();
      });
      this.plugin = this.opts.renderer;
      if (this.opts.domScale !== void 0) {
        if (this.opts.domScale <= 0) {
          throw new Error("domScale must be positive");
        }
        this.domScale = this.opts.domScale;
      }
    }
    dispose() {
      for (const page of this.pages) {
        page.dispose();
      }
      if (this.docKernel) {
        this.docKernel.free();
      }
    }
    createElement(tmpl) {
      this.tmpl.innerHTML = tmpl;
      return this.tmpl.content.firstElementChild;
    }
    async mountDom(pixelPerPt) {
      console.log("mountDom", pixelPerPt);
      if (this.docKernel) {
        throw new Error("already mounted");
      }
      this.hookedElem.innerHTML = `<svg class="typst-svg-resources" viewBox="0 0 0 0" width="0" height="0" style="opacity: 0; position: absolute;"></svg>`;
      this.resourceHeader = this.hookedElem.querySelector(".typst-svg-resources");
      this.docKernel = await this.plugin.renderer.mount_dom(this.kModule[kObject2], this.hookedElem);
      this.docKernel.bind_functions({
        populateGlyphs: (data) => {
          let svg = this.createElement(data);
          console.log("populateGlyphs", svg);
          let content = svg.firstElementChild;
          this.resourceHeader.append(content);
        }
      });
    }
    async cancelAnyway$dom() {
      console.log("cancelAnyway$dom");
      if (this.current_task) {
        const task = this.current_task;
        this.current_task = void 0;
        await task.cancel();
      }
    }
    retrieveDOMPages() {
      return Array.from(this.hookedElem.querySelectorAll(".typst-dom-page"));
    }
    // doesn't need to postRender
    postRender$dom() {
    }
    // doesn't need to rescale
    rescale$dom() {
    }
    getDomViewport(cachedWindow, cachedBoundingRect) {
      const left = cachedBoundingRect.left;
      const top = -cachedBoundingRect.top;
      const right = cachedBoundingRect.right;
      const bottom = cachedWindow.innerHeight - cachedBoundingRect.top;
      const rect = {
        x: 0,
        y: top / this.domScale,
        width: Math.max(right - left, 0) / this.domScale,
        height: Math.max(bottom - top, 0) / this.domScale
      };
      if (rect.width <= 0 || rect.height <= 0) {
        rect.x = rect.y = rect.width = rect.height = 0;
      }
      return rect;
    }
    // fast mode
    async rerender$dom() {
      const domState = this.retrieveDOMState();
      const { x, y, width, height } = this.getDomViewport(domState.window, domState.boundingRect);
      let dirty = await this.docKernel.relayout(x, y, width, height);
      if (!dirty) {
        return;
      }
      const cancel = new TypstCancellationToken2();
      this.doRender$dom(cancel);
      this.current_task = cancel;
    }
    async doRender$dom(ctx) {
      const condOrExit = (needFrame, cb) => {
        if (needFrame && !ctx.isCancelRequested() && cb) {
          return cb();
        }
      };
      const pages = this.retrieveDOMPages().map((page) => {
        const { innerWidth, innerHeight } = window;
        const browserBBox = page.getBoundingClientRect();
        return {
          inWindow: !(browserBBox.left > innerWidth || browserBBox.right < 0 || browserBBox.top > innerHeight || browserBBox.bottom < 0),
          page
        };
      });
      const renderPage = async (i) => {
        await animationFrame2();
        if (ctx.isCancelRequested()) {
          console.log("cancel stage", 0 /* Layout */, i);
          return void 0;
        }
        const page = pages[i].page;
        const browserBBox = page.getBoundingClientRect();
        const v = this.getDomViewport(window, browserBBox);
        const needCalc = (stage) => this.docKernel.need_repaint(i, v.x, v.y, v.width, v.height, stage);
        const repaint = (stage) => this.docKernel.repaint(i, v.x, v.y, v.width, v.height, stage);
        const calc = (stage) => {
          if (ctx.isCancelRequested()) {
            return void 0;
          }
          return condOrExit(needCalc(stage), () => repaint(stage));
        };
        await calc(0 /* Layout */);
        const wScale = (browserBBox.width ? Number.parseFloat(page.getAttribute("data-width")) / browserBBox.width : 1) * this.domScale;
        const hScale = (browserBBox.height ? Number.parseFloat(page.getAttribute("data-height")) / browserBBox.height : 1) * this.domScale;
        v.x *= wScale;
        v.y *= hScale;
        v.y -= 100;
        v.width *= wScale;
        v.height *= hScale;
        v.height += 200;
        await calc(1 /* Svg */);
        await calc(2 /* Semantics */);
        if (ctx.isCancelRequested()) {
          console.log("cancel stage", 2 /* Semantics */, i);
          return void 0;
        }
        if (needCalc(3 /* PrepareCanvas */)) {
          const calcCanvasAfterPreparing = async () => {
            await repaint(3 /* PrepareCanvas */);
            if (ctx.isCancelRequested()) {
              return void 0;
            }
            return calc(4 /* Canvas */);
          };
          calcCanvasAfterPreparing();
        } else {
          await calc(4 /* Canvas */);
        }
      };
      const renderPages = async (inWindow) => {
        for (let idx = 0; idx < pages.length; ++idx) {
          if (ctx.isCancelRequested()) {
            console.log("cancel page", 0 /* Layout */, idx);
            return;
          }
          if (pages[idx].inWindow === inWindow) {
            await renderPage(idx);
          }
        }
      };
      this.cancelAnyway$dom();
      await renderPages(true);
      await renderPages(false);
      if (ctx.isCancelRequested()) {
        return;
      }
      console.log("finished", 0 /* Layout */);
    }
  };
}
var TypstDomDocument2 = class extends provideDoc2(
  composeDoc2(
    TypstDocumentContext2,
    provideDomDoc2
  )
) {
};

// src/renderer.mts
var RenderSession3 = class {
  /**
   * @internal
   */
  constructor(plugin, o) {
    this.plugin = plugin;
    this[kObject2] = o;
  }
  /**
   * Set the background color of the Typst document.
   * @param {string} t - The background color in format of `^#?[0-9a-f]{6}$`
   *
   * Note: Default to `#ffffff`.
   *
   * Note: Only available in canvas rendering mode.
   */
  set backgroundColor(t) {
    if (t !== void 0) {
      this[kObject2].background_color = t;
    }
  }
  /**
   * Get the background color of the Typst document.
   *
   * Note: Default to `#ffffff`.
   *
   * Note: Only available in canvas rendering mode.
   */
  get backgroundColor() {
    return this[kObject2].background_color;
  }
  /**
   * Set the pixel per point scale up the canvas panel.
   *
   * Note: Default to `3`.
   *
   * Note: Only available in canvas rendering mode.
   */
  set pixelPerPt(t) {
    if (t !== void 0) {
      this[kObject2].pixel_per_pt = t;
    }
  }
  /**
   * Get the pixel per point scale up the canvas panel.
   *
   * Note: Default to `3`.
   *
   * Note: Only available in canvas rendering mode.
   */
  get pixelPerPt() {
    return this[kObject2].pixel_per_pt;
  }
  /**
   * Reset state
   */
  reset() {
    this.plugin.resetSession(this);
  }
  /**
   * @deprecated
   * use {@link docWidth} instead
   */
  get doc_width() {
    return this[kObject2].doc_width;
  }
  get docWidth() {
    return this[kObject2].doc_width;
  }
  /**
   * @deprecated
   * use {@link docHeight} instead
   */
  get doc_height() {
    return this[kObject2].doc_height;
  }
  get docHeight() {
    return this[kObject2].doc_height;
  }
  retrievePagesInfo() {
    const pages_info = this[kObject2].pages_info;
    const pageInfos = [];
    const pageCount = pages_info.page_count;
    for (let i = 0; i < pageCount; i++) {
      const pageAst = pages_info.page(i);
      pageInfos.push({
        pageOffset: pageAst.page_off,
        width: pageAst.width_pt,
        height: pageAst.height_pt
      });
    }
    return pageInfos;
  }
  getSourceLoc(path) {
    return this[kObject2].source_span(path);
  }
  /**
   * See {@link TypstRenderer#renderSvg} for more details.
   */
  renderSvg(options) {
    return this.plugin.renderSvg({
      renderSession: this,
      ...options
    });
  }
  /**
   * See {@link TypstRenderer#renderToSvg} for more details.
   */
  renderToSvg(options) {
    return this.plugin.renderToSvg({
      renderSession: this,
      ...options
    });
  }
  /**
   * See {@link TypstRenderer#renderCanvas} for more details.
   */
  renderCanvas(options) {
    return this.plugin.renderCanvas({
      renderSession: this,
      ...options
    });
  }
  /**
   * See {@link TypstRenderer#manipulateData} for more details.
   */
  manipulateData(opts) {
    this.plugin.manipulateData({
      renderSession: this,
      ...opts
    });
  }
  /**
   * See {@link TypstRenderer#renderSvgDiff} for more details.
   */
  renderSvgDiff(opts) {
    return this.plugin.renderSvgDiff({
      renderSession: this,
      ...opts
    });
  }
  /**
   * @deprecated
   * use {@link getSourceLoc} instead
   */
  get_source_loc(path) {
    return this[kObject2].source_span(path);
  }
  /**
   * @deprecated
   * use {@link renderSvgDiff} instead
   */
  render_in_window(rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y) {
    return this[kObject2].render_in_window(rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y);
  }
  /**
   * @deprecated
   * use {@link manipulateData} instead
   */
  merge_delta(data) {
    this.plugin.manipulateData({
      renderSession: this,
      action: "merge",
      data
    });
  }
};
kObject2;
var gRendererModule2 = new LazyWasmModule2(async (bin) => {
  const module2 = await Promise.resolve().then(() => (init_wasm_pack_shim2(), wasm_pack_shim_exports2));
  return await module2.default(bin);
});
function createTypstRenderer2() {
  return new TypstRendererDriver2();
}
function createTypstSvgRenderer2() {
  return new TypstRendererDriver2();
}
async function rendererBuildInfo2() {
  const renderModule = await Promise.resolve().then(() => (init_wasm_pack_shim2(), wasm_pack_shim_exports2));
  return renderModule.renderer_build_info();
}
var warnOnceCanvasSet2 = true;
var TypstRendererDriver2 = class {
  constructor() {
  }
  async init(options) {
    this.rendererJs = await Promise.resolve().then(() => (init_wasm_pack_shim2(), wasm_pack_shim_exports2));
    const TypstRendererBuilder2 = this.rendererJs.TypstRendererBuilder;
    this.renderer = await buildComponent2(options, gRendererModule2, TypstRendererBuilder2, {});
  }
  loadGlyphPack(_pack) {
    return Promise.resolve();
  }
  createOptionsToRust(options) {
    const rustOptions = new this.rendererJs.CreateSessionOptions();
    if (options.format !== void 0) {
      rustOptions.format = options.format;
    }
    if (options.artifactContent !== void 0) {
      rustOptions.artifact_content = options.artifactContent;
    }
    return rustOptions;
  }
  retrievePagesInfoFromSession(session) {
    return session.retrievePagesInfo();
  }
  /**
   * Render a Typst document to canvas.
   */
  renderCanvas(options) {
    return this.withinOptionSession(options, async (sessionRef) => {
      const rustOptions = new this.rendererJs.RenderPageImageOptions();
      if (options.pageOffset !== void 0) {
        rustOptions.page_off = options.pageOffset;
      }
      if (options.cacheKey !== void 0) {
        rustOptions.cache_key = options.cacheKey;
      }
      if (options.dataSelection !== void 0) {
        let encoded = 0;
        if (options.dataSelection.body) {
          encoded |= 1 << 0;
        } else if (options.canvas && warnOnceCanvasSet2) {
          warnOnceCanvasSet2 = false;
          console.warn("dataSelection.body is not set but providing canvas for body");
        }
        if (options.dataSelection.text || options.dataSelection.annotation) {
          console.error("dataSelection.text and dataSelection.annotation are deprecated");
        }
        if (options.dataSelection.semantics) {
          encoded |= 1 << 3;
        }
        rustOptions.data_selection = encoded;
      }
      return this.renderer.render_page_to_canvas(
        sessionRef[kObject2],
        options.canvas || void 0,
        rustOptions
      );
    });
  }
  // async renderPdf(artifactContent: string): Promise<Uint8Array> {
  // return this.renderer.render_to_pdf(artifactContent);
  // }
  async inAnimationFrame(fn) {
    return new Promise((resolve, reject) => {
      requestAnimationFrame(() => {
        try {
          resolve(fn());
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async renderDisplayLayer(session, container, canvasList, options) {
    const pages_info = session[kObject2].pages_info;
    const page_count = pages_info.page_count;
    const doRender = async (i, page_off) => {
      const canvas = canvasList[i];
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("canvas context is null");
      }
      return await this.renderCanvas({
        canvas: ctx,
        renderSession: session,
        pageOffset: page_off
      });
    };
    return this.inAnimationFrame(async () => {
      const t = performance.now();
      const textContentList = (await Promise.all(
        //   canvasList.map(async (canvas, i) => {
        //     await this.renderImageInSession(session, {
        //       page_off: i,
        //     });
        //     console.log(cyrb53(renderResult.data));
        //     let ctx = canvas.getContext('2d');
        //     if (ctx) {
        //       ctx.putImageData(renderResult, 0, 0);
        //     }
        //     return {
        //       width: renderResult.width,
        //       height: renderResult.height,
        //     };
        //   }),
        // )
        /// seq
        [
          (async () => {
            const results = [];
            for (let i = 0; i < page_count; i++) {
              results.push(await doRender(i, i));
            }
            return results;
          })()
        ]
      ))[0];
      const t3 = performance.now();
      console.log(`display layer used: render = ${(t3 - t).toFixed(1)}ms`);
      return textContentList;
    });
  }
  renderTextLayer(layerList, textSourceList) {
    const t2 = performance.now();
    layerList.forEach((layer, i) => {
      layer.innerHTML = textSourceList[i].htmlSemantics[0];
    });
    const t3 = performance.now();
    console.log(`text layer used: render = ${(t3 - t2).toFixed(1)}ms`);
  }
  async render(options) {
    if ("format" in options) {
      if (options.format !== "vector") {
        const artifactFormats = ["serde_json", "js", "ir"];
        if (artifactFormats.includes(options.format)) {
          throw new Error(`deprecated format ${options.format}, please use vector format`);
        }
      }
    }
    return this.renderToCanvas(options);
  }
  async renderDom(options) {
    if ("format" in options) {
      if (options.format !== "vector") {
        const artifactFormats = ["serde_json", "js", "ir"];
        if (artifactFormats.includes(options.format)) {
          throw new Error(`deprecated format ${options.format}, please use vector format`);
        }
      }
    }
    return this.withinOptionSession(options, async (sessionRef) => {
      const t = new TypstDomDocument2({
        ...options,
        renderMode: "dom",
        hookedElem: options.container,
        kModule: sessionRef,
        renderer: this
      });
      t;
      await t.impl.mountDom(options.pixelPerPt);
      return t;
    });
  }
  async renderToCanvas(options) {
    let session;
    let renderPageResults;
    const mountContainer = options.container;
    mountContainer.style.visibility = "hidden";
    const doRenderDisplayLayer = async (canvasList, resetLayout) => {
      try {
        renderPageResults = await this.renderDisplayLayer(
          session,
          mountContainer,
          canvasList,
          options
        );
        resetLayout();
      } finally {
        mountContainer.style.visibility = "visible";
      }
    };
    return this.withinOptionSession(options, async (sessionRef) => {
      session = sessionRef;
      if (session[kObject2].pages_info.page_count === 0) {
        throw new Error(`No page found in session`);
      }
      if (options.pixelPerPt !== void 0 && options.pixelPerPt <= 0) {
        throw new Error(
          "Invalid typst.RenderOptions.pixelPerPt, should be a positive number " + options.pixelPerPt
        );
      }
      let backgroundColor = options.backgroundColor;
      if (backgroundColor !== void 0) {
        if (!/^#[0-9a-f]{6}$/.test(backgroundColor)) {
          throw new Error(
            "Invalid typst.backgroundColor color for matching ^#?[0-9a-f]{6}$ " + backgroundColor
          );
        }
      }
      session.pixelPerPt = options.pixelPerPt ?? 3 /* PIXEL_PER_PT */;
      session.backgroundColor = backgroundColor ?? "#ffffff";
      const t = performance.now();
      const pageView = new RenderView2(
        this.retrievePagesInfoFromSession(session),
        mountContainer,
        options
      );
      const t2 = performance.now();
      console.log(`layer used: retieve = ${(t2 - t).toFixed(1)}ms`);
      await doRenderDisplayLayer(pageView.canvasList, () => pageView.resetLayout());
      this.renderTextLayer(pageView.textLayerList, renderPageResults);
      return;
    });
  }
  createModule(b) {
    return Promise.resolve(
      new RenderSession3(
        this,
        this.renderer.create_session(
          b && this.createOptionsToRust({
            format: "vector",
            artifactContent: b
          })
        )
      )
    );
  }
  renderSvg(options, container) {
    if (options instanceof RenderSession3 || container) {
      throw new Error("removed api, please use renderToSvg({ renderSession, container }) instead");
    }
    return this.withinOptionSession(options, async (sessionRef) => {
      let parts = void 0;
      if (options.data_selection) {
        parts = 0;
        if (options.data_selection.body) {
          parts |= 1 << 0;
        }
        if (options.data_selection.defs) {
          parts |= 1 << 1;
        }
        if (options.data_selection.css) {
          parts |= 1 << 2;
        }
        if (options.data_selection.js) {
          parts |= 1 << 3;
        }
      }
      return Promise.resolve(this.renderer.svg_data(sessionRef[kObject2], parts));
    });
  }
  renderSvgDiff(options) {
    if (!options.window) {
      return this.renderer.render_svg_diff(
        options.renderSession[kObject2],
        0,
        0,
        1e33,
        1e33
      );
    }
    return this.renderer.render_svg_diff(
      options.renderSession[kObject2],
      options.window.lo.x,
      options.window.lo.y,
      options.window.hi.x,
      options.window.hi.y
    );
  }
  renderToSvg(options) {
    return this.withinOptionSession(options, async (sessionRef) => {
      return Promise.resolve(this.renderer.render_svg(sessionRef[kObject2], options.container));
    });
  }
  getCustomV1(options) {
    return Promise.resolve(this.renderer.get_customs(options.renderSession[kObject2]));
  }
  resetSession(session) {
    return this.renderer.reset(session[kObject2]);
  }
  manipulateData(opts) {
    return this.renderer.manipulate_data(
      opts.renderSession[kObject2],
      opts.action ?? "reset",
      opts.data
    );
  }
  withinOptionSession(options, fn) {
    function isRenderByContentOption(options2) {
      return "artifactContent" in options2;
    }
    if ("renderSession" in options) {
      return fn(options.renderSession);
    }
    if (isRenderByContentOption(options)) {
      return this.runWithSession(options, fn);
    }
    throw new Error(
      "Invalid render options, should be one of RenderByContentOptions|RenderBySessionOptions"
    );
  }
  async runWithSession(arg1, arg2) {
    let options = arg1;
    let fn = arg2;
    if (!arg2) {
      options = void 0;
      fn = arg1;
    }
    const session = this.renderer.create_session(
      /* moved */
      options && this.createOptionsToRust(options)
    );
    try {
      const res = await fn(new RenderSession3(this, session));
      session.free();
      return res;
    } catch (e) {
      session.free();
      throw e;
    }
  }
};

// src/compiler.mts
var IncrementalServer2 = class {
  /**
   * @internal
   */
  constructor(s) {
    this[kObject2] = s;
  }
  /**
   * Reset the incremental server to the initial state.
   */
  reset() {
    this[kObject2].reset();
  }
  /**
   * Return current result.
   */
  current() {
    return this[kObject2].current();
  }
  /**
   * Also attach the debug info to the result.
   */
  setAttachDebugInfo(enable) {
    this[kObject2].set_attach_debug_info(enable);
  }
};
kObject2;
var gCompilerModule2 = new LazyWasmModule2(async (bin) => {
  const module2 = await Promise.resolve().then(() => (init_wasm_pack_shim(), wasm_pack_shim_exports));
  return await module2.default(bin);
});
function createTypstCompiler2() {
  return new TypstCompilerDriver2();
}
var TypstCompilerDriver2 = class {
  constructor() {
  }
  async init(options) {
    this.compilerJs = await Promise.resolve().then(() => (init_wasm_pack_shim(), wasm_pack_shim_exports));
    const TypstCompilerBuilder2 = this.compilerJs.TypstCompilerBuilder;
    const compilerOptions = { ...options || {} };
    const hasPreloadRemoteFonts = compilerOptions.beforeBuild?.some(
      (fn) => fn._preloadRemoteFontOptions !== void 0
    );
    const hasSpecifiedAssets = compilerOptions.beforeBuild?.some(
      (fn) => fn._preloadRemoteFontOptions?.assets !== void 0
    );
    const hasDisableAssets = compilerOptions.beforeBuild?.some(
      (fn) => fn._preloadRemoteFontOptions?.assets === false
    );
    if (!hasPreloadRemoteFonts || !hasSpecifiedAssets && !hasDisableAssets) {
      compilerOptions.beforeBuild?.push(
        preloadRemoteFonts([], {
          assets: ["text"]
        })
      );
    }
    this.compiler = await buildComponent2(options, gCompilerModule2, TypstCompilerBuilder2, {});
  }
  compile(options) {
    return new Promise((resolve) => {
      if ("incrementalServer" in options) {
        resolve(
          this.compiler.incr_compile(
            options.mainFilePath,
            options.incrementalServer[kObject2],
            getDiagnosticsArg2(options.diagnostics)
          )
        );
        return;
      }
      resolve(
        this.compiler.compile(
          options.mainFilePath,
          options.format || "vector",
          getDiagnosticsArg2(options.diagnostics)
        )
      );
    });
  }
  query(options) {
    return new Promise((resolve) => {
      resolve(
        JSON.parse(this.compiler.query(options.mainFilePath, options.selector, options.field))
      );
    });
  }
  getSemanticTokenLegend() {
    return new Promise((resolve) => {
      resolve(this.compiler.get_semantic_token_legend());
    });
  }
  getSemanticTokens(opts) {
    return new Promise((resolve) => {
      this.compiler.reset();
      resolve(
        this.compiler.get_semantic_tokens(
          opts.offsetEncoding || "utf-16",
          opts.mainFilePath,
          opts.resultId
        )
      );
    });
  }
  async withIncrementalServer(f) {
    const srv = new IncrementalServer2(this.compiler.create_incr_server());
    try {
      return await f(srv);
    } finally {
      srv[kObject2].free();
    }
  }
  async getAst(mainFilePath) {
    return this.compiler.get_ast(mainFilePath);
  }
  async reset() {
    await new Promise((resolve) => {
      this.compiler.reset();
      resolve(void 0);
    });
  }
  addSource(path, source) {
    if (arguments.length > 2) {
      throw new Error(
        "use of addSource(path, source, isMain) is deprecated, please use addSource(path, source) instead"
      );
    }
    this.compiler.add_source(path, source);
  }
  mapShadow(path, content) {
    this.compiler.map_shadow(path, content);
  }
  unmapShadow(path) {
    this.compiler.unmap_shadow(path);
  }
  resetShadow() {
    this.compiler.reset_shadow();
  }
  renderPageToCanvas() {
    throw new Error("Please use the api TypstRenderer.renderToCanvas in v0.4.0");
  }
};
function getDiagnosticsArg2(diagnostics) {
  switch (diagnostics) {
    case "none":
      return 1;
    case "unix":
      return 2;
    case "full":
      return 3;
    default:
      return 0;
  }
}

// src/main.mts
if (window) {
  window.TypstRenderModule = {
    RenderView: RenderView2,
    createTypstRenderer: createTypstRenderer2,
    createTypstSvgRenderer: createTypstRenderer2,
    preloadRemoteFonts,
    preloadSystemFonts
  };
  window.TypstCompileModule = {
    createTypstCompiler: createTypstCompiler2,
    preloadRemoteFonts,
    preloadSystemFonts,
    FetchAccessModel,
    MemoryAccessModel,
    FetchPackageRegistry,
    withAccessModel,
    withPackageRegistry
  };
}

// src/contrib/all-in-one-lite.mts
window.$typst = $typst;
window.TypstSnippet = TypstSnippet;
