"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$typst = exports.TypstSnippet = void 0;
const options_init_mjs_1 = require("../options.init.cjs");
const index_mjs_1 = require("../fs/index.cjs");
const package_mjs_1 = require("../fs/package.cjs");
const utils_mjs_1 = require("../utils.cjs");
const isNode = 
// @ts-ignore
typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
/**
 * Convenient util class for compiling documents, which is a wrapper of the
 * {@link TypstCompiler} and {@link TypstRenderer}.
 *
 * Note: the interface of this class is less stable than {@link TypstCompiler}
 * and {@link TypstRenderer}.
 *
 * @example
 * Use the *global shared* compiler instance:
 *
 * ```typescript
 * import { $typst } from "@myriaddreamin/typst.ts/dist/esm/contrib/snippet.cjs";
 * ```
 *
 * Note: if you want to compile multiple documents, you should create a new
 * instance for each compilation work or maintain the shared state on the
 * utility instance `$typst` carefully, because the compilation process will
 * change the state of that.
 *
 * @example
 * Create an instance of utility:
 *
 * ```typescript
 * const $typst = new TypstSnippet({
 *   // optional renderer instance
 *   renderer: enableRendering ?? (() => {
 *     return createGlobalRenderer(createTypstRenderer,
 *       undefined, initOptions);
 *   }),
 *   compiler() => {
 *     return createGlobalCompiler(createTypstCompiler,
 *       initOptions);
 *   }
 * });
 * ```
 */
class TypstSnippet {
    /** @internal */
    mainFilePath;
    /** @internal */
    cc;
    /** @internal */
    ex;
    /**
     * Create a new instance of {@link TypstSnippet}.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     *
     * @example
     *
     * Passes a global shared compiler instance that get initialized lazily:
     * ```typescript
     * const $typst = new TypstSnippet(() => {
     *  return createGlobalCompiler(createTypstCompiler, initOptions);
     * });
     *
     */
    constructor(options) {
        this.cc = options?.compiler;
        this.ex = options?.renderer;
        this.mainFilePath = '/main.typ';
        this.providers = [];
    }
    /**
     * Set lazy initialized compiler instance for the utility instance.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     */
    setCompiler(cc) {
        this.cc = cc;
    }
    /**
     * Get an initialized compiler instance from the utility instance.
     */
    async getCompiler() {
        return (typeof this.cc === 'function' ? (this.cc = await this.cc()) : this.cc);
    }
    /**
     * Set lazy initialized renderer instance for the utility instance.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     */
    setRenderer(ex) {
        this.ex = ex;
    }
    /**
     * Get an initialized renderer instance from the utility instance.
     */
    async getRenderer() {
        return typeof this.ex === 'function' ? (this.ex = await this.ex()) : this.ex;
    }
    providers;
    /**
     * add providers for bullding the compiler or renderer component.
     */
    use(...providers) {
        if (!this.providers) {
            throw new Error('already prepare uses for instances');
        }
        this.providers.push(...providers);
    }
    /**
     * Set accessl model for the compiler instance
     * @example
     *
     * use memory access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m));
     * ```
     */
    static withAccessModel(accessModel) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [(0, options_init_mjs_1.withAccessModel)(accessModel)],
        };
    }
    /**
     * Set package registry for the compiler instance
     * @example
     *
     * use a customized package registry
     *
     * ```typescript
     * const n = new NodeFetchPackageRegistry();
     * $typst.use(TypstSnippet.withPackageRegistry(n));
     * ```
     */
    static withPackageRegistry(registry) {
        return {
            key: 'package-registry',
            forRoles: ['compiler'],
            provides: [(0, options_init_mjs_1.withPackageRegistry)(registry)],
        };
    }
    /**
     * Retrieve an access model to store the data of fetched files.
     * Provide a PackageRegistry instance for the compiler instance.
     *
     * @example
     *
     * use default (memory) access model
     *
     * ```typescript
     * $typst.use(await TypstSnippet.fetchPackageRegistry());
     * ```
     *
     * @example
     *
     * use external access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
     * ```
     */
    static fetchPackageRegistry(accessModel) {
        const m = accessModel || new index_mjs_1.MemoryAccessModel();
        const provides = [
            ...(accessModel ? [] : [(0, options_init_mjs_1.withAccessModel)(m)]),
            (0, options_init_mjs_1.withPackageRegistry)(new package_mjs_1.FetchPackageRegistry(m)),
        ];
        return {
            key: 'package-registry$fetch',
            forRoles: ['compiler'],
            provides,
        };
    }
    /**
     * Retrieve a fetcher for fetching package data.
     * Provide a PackageRegistry instance for the compiler instance.
     * @example
     *
     * use a customized fetcher
     *
     * ```typescript
     * import request from 'sync-request-curl';
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
     *   const response = request('GET', this.resolvePath(path), {
     *     insecure: true,
     *   });
     *
     *   if (response.statusCode === 200) {
     *     return response.getBody(undefined);
     *   }
     *   return undefined;
     * }));
     * ```
     */
    static fetchPackageBy(accessModel, fetcher) {
        class HttpPackageRegistry extends package_mjs_1.FetchPackageRegistry {
            pullPackageData(path) {
                return fetcher(path, this.resolvePath(path));
            }
        }
        return {
            key: 'package-registry$lambda',
            forRoles: ['compiler'],
            provides: [(0, options_init_mjs_1.withPackageRegistry)(new HttpPackageRegistry(accessModel))],
        };
    }
    /** @internal */
    ccOptions;
    /**
     * Set compiler init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setCompilerInitOptions(options) {
        this.requireIsUninitialized('compiler', this.cc, TypstSnippet.$buildC);
        this.ccOptions = options;
    }
    /** @internal */
    exOptions;
    /**
     * Set renderer init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setRendererInitOptions(options) {
        this.requireIsUninitialized('renderer', this.ex, TypstSnippet.$buildR);
        this.exOptions = options;
    }
    /**
     * Set shared main file path.
     */
    setMainFilePath(path) {
        this.mainFilePath = path;
    }
    /**
     * Get shared main file path.
     */
    getMainFilePath() {
        return this.mainFilePath;
    }
    removeTmp(opts) {
        if (opts.mainFilePath.startsWith('/tmp/')) {
            return this.unmapShadow(opts.mainFilePath);
        }
        return Promise.resolve();
    }
    /**
     * Add a source file to the compiler.
     * See {@link TypstCompiler#addSource}.
     */
    async addSource(path, content) {
        (await this.getCompiler()).addSource(path, content);
    }
    /**
     * Reset the shadow files.
     * Note: this function is independent to the {@link reset} function.
     * See {@link TypstCompiler#resetShadow}.
     */
    async resetShadow() {
        (await this.getCompiler()).resetShadow();
    }
    /**
     * Add a shadow file to the compiler.
     * See {@link TypstCompiler#mapShadow}.
     */
    async mapShadow(path, content) {
        (await this.getCompiler()).mapShadow(path, content);
    }
    /**
     * Remove a shadow file from the compiler.
     * See {@link TypstCompiler#unmapShadow}.
     */
    async unmapShadow(path) {
        (await this.getCompiler()).unmapShadow(path);
    }
    /**
     * Compile the document to vector (IR) format.
     * See {@link SweetCompileOptions}.
     */
    async vector(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to PDF format.
     * See {@link SweetCompileOptions}.
     */
    async pdf(o) {
        const opts = await this.getCompileOptions(o);
        opts.format = 'pdf';
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to SVG format.
     * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
     */
    async svg(o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderSvg({
            ...o,
            renderSession,
        }));
    }
    /**
     * Compile the document to canvas operations.
     * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
     */
    async canvas(container, o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderToCanvas({
            container,
            ...o,
            renderSession,
        }));
    }
    /**
     * Get semantic tokens for the document.
     */
    async query(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .query({
            ...o,
            ...opts,
        })
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Get token legend for semantic tokens.
     */
    async getSemanticTokenLegend() {
        return (await this.getCompiler()).getSemanticTokenLegend();
    }
    /**
     * Get semantic tokens for the document.
     * See {@link SweetCompileOptions}.
     * See {@link TypstCompiler#getSemanticTokens}.
     */
    async getSemanticTokens(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .getSemanticTokens({
            mainFilePath: opts.mainFilePath,
            resultId: o.resultId,
        })
            .finally(() => this.removeTmp(opts));
    }
    async getCompileOptions(opts) {
        if (opts === undefined) {
            return { mainFilePath: this.mainFilePath, diagnostics: 'none' };
        }
        else if (typeof opts === 'string') {
            throw new Error(`please specify opts as {mainContent: '...'} or {mainFilePath: '...'}`);
        }
        else if ('mainFilePath' in opts) {
            return { ...opts, diagnostics: 'none' };
        }
        else {
            const destFile = `/tmp/${(0, utils_mjs_1.randstr)()}.typ`;
            await this.addSource(destFile, opts.mainContent);
            return { mainFilePath: destFile, inputs: opts.inputs, diagnostics: 'none' };
        }
    }
    async getVector(o) {
        if (o && 'vectorData' in o) {
            return o.vectorData;
        }
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    async transientRender(opts, f) {
        const rr = await this.getRenderer();
        if (!rr) {
            throw new Error('does not provide renderer instance');
        }
        const data = await this.getVector(opts);
        return await rr.runWithSession(async (session) => {
            rr.manipulateData({
                renderSession: session,
                action: 'reset',
                data,
            });
            return f(rr, session);
        });
    }
    async prepareUse() {
        if (!this.providers) {
            return;
        }
        const providers = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        this.providers = [];
        if (exports.$typst == this &&
            !providers.some(p => p.key.includes('package-registry') || p.key.includes('access-model'))) {
            // Note: the default fetch backend always adds a withAccessModel(mem)
            if (isNode) {
                const escapeImport = new Function('m', 'return import(m)');
                try {
                    const m = new index_mjs_1.MemoryAccessModel();
                    const { default: request } = await escapeImport('sync-request');
                    exports.$typst.use(TypstSnippet.withAccessModel(m), TypstSnippet.fetchPackageBy(m, (_, path) => {
                        const response = request('GET', path);
                        if (response.statusCode === 200) {
                            return response.getBody(undefined);
                        }
                        return undefined;
                    }));
                }
                catch (e) { }
            }
            else {
                exports.$typst.use(TypstSnippet.fetchPackageRegistry());
            }
        }
        const providers2 = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        const ccOptions = (this.ccOptions ||= {});
        const ccBeforeBuild = (ccOptions.beforeBuild ||= []);
        const exOptions = (this.exOptions ||= {});
        const exBeforeBuild = (exOptions.beforeBuild ||= []);
        for (const provider of [...providers, ...providers2]) {
            if (provider.forRoles.includes('compiler')) {
                this.requireIsUninitialized('compiler', this.cc, TypstSnippet.$buildC);
                ccBeforeBuild.push(...provider.provides);
            }
            if (provider.forRoles.includes('renderer')) {
                this.requireIsUninitialized('renderer', this.ex, TypstSnippet.$buildR);
                exBeforeBuild.push(...provider.provides);
            }
        }
        this.providers = undefined;
    }
    requireIsUninitialized(role, c, e) {
        if (typeof c !== 'function') {
            throw new Error(`${role} has been initialized: ${c}`);
        }
        if (e && c != e) {
            throw new Error(`${role} instance is set to non default value`);
        }
    }
    /** @internal */
    static async $buildC() {
        // lazy import compile module
        const { createGlobalCompiler } = (await import('@myriaddreamin/typst.ts/dist/esm/contrib/global-compiler.mjs'));
        const { createTypstCompiler } = (await import('@myriaddreamin/typst.ts/dist/esm/compiler.mjs'));
        await this.prepareUse();
        return createGlobalCompiler(createTypstCompiler, this.ccOptions);
    }
    /** @internal */
    static async $buildR() {
        // lazy import renderer module
        const { createGlobalRenderer } = (await import('@myriaddreamin/typst.ts/dist/esm/contrib/global-renderer.mjs'));
        const { createTypstRenderer } = (await import('@myriaddreamin/typst.ts/dist/esm/renderer.mjs'));
        await this.prepareUse();
        return createGlobalRenderer(createTypstRenderer, this.exOptions);
    }
}
exports.TypstSnippet = TypstSnippet;
/**
 * The lazy initialized global shared instance of {@link TypstSnippet}. See
 * {@link TypstSnippet} for more details.
 */
exports.$typst = new TypstSnippet({
    compiler: TypstSnippet.$buildC,
    renderer: TypstSnippet.$buildR,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25pcHBldC5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJpYi9zbmlwcGV0Lm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwwREFNNkI7QUFHN0IsK0NBQThFO0FBQzlFLG1EQUF5RDtBQU96RCw0Q0FBdUM7QUErRHZDLE1BQU0sTUFBTTtBQUNWLGFBQWE7QUFDYixPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLFFBQVEsSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO0FBRTlGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1DRztBQUNILE1BQWEsWUFBWTtJQUN2QixnQkFBZ0I7SUFDUixZQUFZLENBQVM7SUFDN0IsZ0JBQWdCO0lBQ1IsRUFBRSxDQUE4QjtJQUN4QyxnQkFBZ0I7SUFDUixFQUFFLENBQThCO0lBRXhDOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxZQUFZLE9BR1g7UUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHLE9BQU8sRUFBRSxRQUFRLENBQUM7UUFDNUIsSUFBSSxDQUFDLEVBQUUsR0FBRyxPQUFPLEVBQUUsUUFBUSxDQUFDO1FBQzVCLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXLENBQUMsRUFBOEI7UUFDeEMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsV0FBVztRQUNmLE9BQU8sQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBRSxDQUFDO0lBQ2xGLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXLENBQUMsRUFBOEI7UUFDeEMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsV0FBVztRQUNmLE9BQU8sT0FBTyxJQUFJLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDL0UsQ0FBQztJQUVPLFNBQVMsQ0FBdUM7SUFDeEQ7O09BRUc7SUFDSCxHQUFHLENBQUMsR0FBRyxTQUE4QztRQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7U0FDdkQ7UUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxDQUFDLGVBQWUsQ0FBQyxXQUFnQztRQUNyRCxPQUFPO1lBQ0wsR0FBRyxFQUFFLGNBQWM7WUFDbkIsUUFBUSxFQUFFLENBQUMsVUFBVSxDQUFDO1lBQ3RCLFFBQVEsRUFBRSxDQUFDLElBQUEsa0NBQWUsRUFBQyxXQUFXLENBQUMsQ0FBQztTQUN6QyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBeUI7UUFDbEQsT0FBTztZQUNMLEdBQUcsRUFBRSxrQkFBa0I7WUFDdkIsUUFBUSxFQUFFLENBQUMsVUFBVSxDQUFDO1lBQ3RCLFFBQVEsRUFBRSxDQUFDLElBQUEsc0NBQW1CLEVBQUMsUUFBUSxDQUFDLENBQUM7U0FDMUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkc7SUFDSCxNQUFNLENBQUMsb0JBQW9CLENBQUMsV0FBaUM7UUFDM0QsTUFBTSxDQUFDLEdBQUcsV0FBVyxJQUFJLElBQUksNkJBQWlCLEVBQUUsQ0FBQztRQUNqRCxNQUFNLFFBQVEsR0FBRztZQUNmLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFBLGtDQUFlLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFBLHNDQUFtQixFQUFDLElBQUksa0NBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQsQ0FBQztRQUNGLE9BQU87WUFDTCxHQUFHLEVBQUUsd0JBQXdCO1lBQzdCLFFBQVEsRUFBRSxDQUFDLFVBQVUsQ0FBQztZQUN0QixRQUFRO1NBQ1QsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJHO0lBQ0gsTUFBTSxDQUFDLGNBQWMsQ0FDbkIsV0FBZ0MsRUFDaEMsT0FBOEU7UUFFOUUsTUFBTSxtQkFBb0IsU0FBUSxrQ0FBb0I7WUFDcEQsZUFBZSxDQUFDLElBQWlCO2dCQUMvQixPQUFPLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQy9DLENBQUM7U0FDRjtRQUNELE9BQU87WUFDTCxHQUFHLEVBQUUseUJBQXlCO1lBQzlCLFFBQVEsRUFBRSxDQUFDLFVBQVUsQ0FBQztZQUN0QixRQUFRLEVBQUUsQ0FBQyxJQUFBLHNDQUFtQixFQUFDLElBQUksbUJBQW1CLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztTQUN0RSxDQUFDO0lBQ0osQ0FBQztJQUVELGdCQUFnQjtJQUNoQixTQUFTLENBQXVCO0lBQ2hDOzs7T0FHRztJQUNILHNCQUFzQixDQUFDLE9BQTZCO1FBQ2xELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkUsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUVELGdCQUFnQjtJQUNoQixTQUFTLENBQXVCO0lBQ2hDOzs7T0FHRztJQUNILHNCQUFzQixDQUFDLE9BQTZCO1FBQ2xELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkUsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZUFBZSxDQUFDLElBQVk7UUFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBRUQsU0FBUyxDQUFDLElBQW9CO1FBQzVCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDekMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUM1QztRQUVELE9BQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFDLElBQVksRUFBRSxPQUFlO1FBQzNDLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFdBQVc7UUFDZixDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBWSxFQUFFLE9BQW1CO1FBQy9DLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFDLElBQVk7UUFDNUIsQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUF1QjtRQUNsQyxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QyxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDOUIsT0FBTyxDQUFDLElBQUksQ0FBQzthQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7YUFDdkIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUF1QjtRQUMvQixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDOUIsT0FBTyxDQUFDLElBQUksQ0FBQzthQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7YUFDdkIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUF5QztRQUNqRCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLGFBQWEsRUFBRSxFQUFFLENBQ3pELFFBQVEsQ0FBQyxTQUFTLENBQUM7WUFDakIsR0FBRyxDQUFDO1lBQ0osYUFBYTtTQUNkLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQ1YsU0FBc0IsRUFDdEIsQ0FBaUU7UUFFakUsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxhQUFhLEVBQUUsRUFBRSxDQUN6RCxRQUFRLENBQUMsY0FBYyxDQUFDO1lBQ3RCLFNBQVM7WUFDVCxHQUFHLENBQUM7WUFDSixhQUFhO1NBQ2QsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsS0FBSyxDQUFJLENBQTZEO1FBQzFFLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUM5QixLQUFLLENBQUk7WUFDUixHQUFHLENBQUM7WUFDSixHQUFHLElBQUk7U0FDUixDQUFDO2FBQ0QsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsc0JBQXNCO1FBQzFCLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLHNCQUFzQixFQUFFLENBQUM7SUFDN0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBOEM7UUFDcEUsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzlCLGlCQUFpQixDQUFDO1lBQ2pCLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWTtZQUMvQixRQUFRLEVBQUUsQ0FBQyxDQUFDLFFBQVE7U0FDckIsQ0FBQzthQUNELE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVPLEtBQUssQ0FBQyxpQkFBaUIsQ0FDN0IsSUFBMEI7UUFFMUIsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ3RCLE9BQU8sRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLENBQUM7U0FDakU7YUFBTSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7YUFBTSxJQUFJLGNBQWMsSUFBSSxJQUFJLEVBQUU7WUFDakMsT0FBTyxFQUFFLEdBQUcsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUN6QzthQUFNO1lBQ0wsTUFBTSxRQUFRLEdBQUcsUUFBUSxJQUFBLG1CQUFPLEdBQUUsTUFBTSxDQUFDO1lBQ3pDLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ2pELE9BQU8sRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUM3RTtJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQXNCO1FBQzVDLElBQUksQ0FBQyxJQUFJLFlBQVksSUFBSSxDQUFDLEVBQUU7WUFDMUIsT0FBTyxDQUFDLENBQUMsVUFBVSxDQUFDO1NBQ3JCO1FBRUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUM7YUFDYixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTyxDQUFDO2FBQ3hCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVPLEtBQUssQ0FBQyxlQUFlLENBQzNCLElBQW9DLEVBQ3BDLENBQW1EO1FBRW5ELE1BQU0sRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDUCxNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7U0FDdkQ7UUFDRCxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEMsT0FBTyxNQUFNLEVBQUUsQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFDLE9BQU8sRUFBQyxFQUFFO1lBQzdDLEVBQUUsQ0FBQyxjQUFjLENBQUM7Z0JBQ2hCLGFBQWEsRUFBRSxPQUFPO2dCQUN0QixNQUFNLEVBQUUsT0FBTztnQkFDZixJQUFJO2FBQ0wsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3hCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLEtBQUssQ0FBQyxVQUFVO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ25CLE9BQU87U0FDUjtRQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDakMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzdELENBQUM7UUFDRixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVwQixJQUNFLGNBQU0sSUFBSSxJQUFJO1lBQ2QsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUMxRjtZQUNBLHFFQUFxRTtZQUNyRSxJQUFJLE1BQU0sRUFBRTtnQkFDVixNQUFNLFlBQVksR0FBRyxJQUFJLFFBQVEsQ0FBQyxHQUFHLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztnQkFDM0QsSUFBSTtvQkFDRixNQUFNLENBQUMsR0FBRyxJQUFJLDZCQUFpQixFQUFFLENBQUM7b0JBQ2xDLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsTUFBTSxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBRWhFLGNBQU0sQ0FBQyxHQUFHLENBQ1IsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFDL0IsWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFVLEVBQUUsSUFBWSxFQUFFLEVBQUU7d0JBQzFELE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7d0JBRXRDLElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxHQUFHLEVBQUU7NEJBQy9CLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzt5QkFDcEM7d0JBQ0QsT0FBTyxTQUFTLENBQUM7b0JBQ25CLENBQUMsQ0FBQyxDQUNILENBQUM7aUJBQ0g7Z0JBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRTthQUNmO2lCQUFNO2dCQUNMLGNBQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLG9CQUFvQixFQUFFLENBQUMsQ0FBQzthQUNqRDtTQUNGO1FBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDN0QsQ0FBQztRQUVGLE1BQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUMxQyxNQUFNLGFBQWEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFckQsTUFBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQzFDLE1BQU0sYUFBYSxHQUFHLENBQUMsU0FBUyxDQUFDLFdBQVcsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUVyRCxLQUFLLE1BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLEVBQUUsR0FBRyxVQUFVLENBQUMsRUFBRTtZQUNwRCxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUMxQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN2RSxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzFDO1lBQ0QsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDMUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDdkUsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMxQztTQUNGO1FBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7SUFDN0IsQ0FBQztJQUVPLHNCQUFzQixDQUFJLElBQVksRUFBRSxDQUFpQixFQUFFLENBQWtCO1FBQ25GLElBQUksT0FBTyxDQUFDLEtBQUssVUFBVSxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZEO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLHVDQUF1QyxDQUFDLENBQUM7U0FDakU7SUFDSCxDQUFDO0lBRUQsZ0JBQWdCO0lBQ2hCLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTztRQUNsQiw2QkFBNkI7UUFDN0IsTUFBTSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsQ0FBQyxNQUFNLE1BQU0sQ0FDNUMsOERBQThELENBQy9ELENBQWtELENBQUM7UUFDcEQsTUFBTSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsQ0FBQyxNQUFNLE1BQU0sQ0FDM0MsK0NBQStDLENBQ2hELENBQTRDLENBQUM7UUFFOUMsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDeEIsT0FBTyxvQkFBb0IsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVELGdCQUFnQjtJQUNoQixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU87UUFDbEIsOEJBQThCO1FBQzlCLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQzVDLDhEQUE4RCxDQUMvRCxDQUFrRCxDQUFDO1FBQ3BELE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQzNDLCtDQUErQyxDQUNoRCxDQUE0QyxDQUFDO1FBRTlDLE1BQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sb0JBQW9CLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7Q0FDRjtBQTllRCxvQ0E4ZUM7QUFFRDs7O0dBR0c7QUFDVSxRQUFBLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQztJQUNyQyxRQUFRLEVBQUUsWUFBWSxDQUFDLE9BQU87SUFDOUIsUUFBUSxFQUFFLFlBQVksQ0FBQyxPQUFPO0NBQy9CLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ29tcGlsZU9wdGlvbnMsIFR5cHN0Q29tcGlsZXIgfSBmcm9tICcuLi9jb21waWxlci5tanMnO1xyXG5pbXBvcnQge1xyXG4gIHdpdGhQYWNrYWdlUmVnaXN0cnksXHJcbiAgd2l0aEFjY2Vzc01vZGVsLFxyXG4gIHR5cGUgQmVmb3JlQnVpbGRGbixcclxuICB0eXBlIEluaXRPcHRpb25zLFxyXG4gIHByZWxvYWRGb250QXNzZXRzLFxyXG59IGZyb20gJy4uL29wdGlvbnMuaW5pdC5tanMnO1xyXG5pbXBvcnQgdHlwZSB7IFR5cHN0UmVuZGVyZXIsIFJlbmRlclNlc3Npb24gfSBmcm9tICcuLi9yZW5kZXJlci5tanMnO1xyXG5pbXBvcnQgdHlwZSB7IFJlbmRlclRvQ2FudmFzT3B0aW9ucywgUmVuZGVyU3ZnT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMucmVuZGVyLm1qcyc7XHJcbmltcG9ydCB7IE1lbW9yeUFjY2Vzc01vZGVsLCB0eXBlIFdyaXRhYmxlQWNjZXNzTW9kZWwgfSBmcm9tICcuLi9mcy9pbmRleC5tanMnO1xyXG5pbXBvcnQgeyBGZXRjaFBhY2thZ2VSZWdpc3RyeSB9IGZyb20gJy4uL2ZzL3BhY2thZ2UubWpzJztcclxuaW1wb3J0IHtcclxuICBQYWNrYWdlUmVnaXN0cnksXHJcbiAgUGFja2FnZVNwZWMsXHJcbiAgU2VtYW50aWNUb2tlbnMsXHJcbiAgU2VtYW50aWNUb2tlbnNMZWdlbmQsXHJcbn0gZnJvbSAnLi4vaW50ZXJuYWwudHlwZXMubWpzJztcclxuaW1wb3J0IHsgcmFuZHN0ciB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XHJcblxyXG4vKipcclxuICogU29tZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIG9mIHZhbHVlIG9yIGp1c3QgdGhhdCB2YWx1ZS5cclxuICovXHJcbnR5cGUgUHJvbWlzZUp1c3Q8VD4gPSAoKCkgPT4gUHJvbWlzZTxUPikgfCBUO1xyXG5cclxuaW50ZXJmYWNlIENvbXBpbGVPcHRpb25zQ29tbW9uIHtcclxuICAvKipcclxuICAgKiBBZGRzIGEgc3RyaW5nIGtleS12YWx1ZSBwYWlyIHZpc2libGUgdGhyb3VnaCBgc3lzLmlucHV0c2BcclxuICAgKlxyXG4gICAqIE5vdGU6IHBhc3MgYHt9YCB0byBjbGVhciBgc3lzLmlucHV0c2BcclxuICAgKlxyXG4gICAqIE5vdGU6IFdoZW4gcGFzc2luZyBgdW5kZWZpbmVkYCwgY29tcGlsZXIgd2lsbCB1c2UgbGFzdCBzZXQgYHN5cy5pbnB1dHNgLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBtZWFucyB5b3Ugc2hvdWxkIGFsd2F5cyBzcGVjaWZ5IGlucHV0cyB3aGVuIHVzaW5nIGNvbXBpbGVyIGZvciBjb25jdXJyZW50IHRhc2tzLlxyXG4gICAqL1xyXG4gIGlucHV0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgc3dlZXQgb3B0aW9ucyBmb3IgY29tcGlsaW5nIGFuZCByZW5kZXJpbmcgdGhlIGRvY3VtZW50LlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU3dlZXRDb21waWxlT3B0aW9ucyA9IChcclxuICB8IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBwYXRoIG9mIHRoZSBtYWluIGZpbGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBtYWluRmlsZVBhdGg6IHN0cmluZztcclxuICAgIH1cclxuICB8IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBzb3VyY2UgY29udGVudCBvZiB0aGUgbWFpbiBmaWxlLlxyXG4gICAgICAgKi9cclxuICAgICAgbWFpbkNvbnRlbnQ6IHN0cmluZztcclxuICAgIH1cclxuKSAmXHJcbiAgQ29tcGlsZU9wdGlvbnNDb21tb247XHJcblxyXG4vKipcclxuICogVGhlIHN3ZWV0IG9wdGlvbnMgZm9yIGNvbXBpbGluZyBhbmQgcmVuZGVyaW5nIHRoZSBkb2N1bWVudC5cclxuICovXHJcbmV4cG9ydCB0eXBlIFN3ZWV0UmVuZGVyT3B0aW9ucyA9XHJcbiAgfCBTd2VldENvbXBpbGVPcHRpb25zXHJcbiAgfCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgYXJ0aWZhY3QgZGF0YSBpbiB2ZWN0b3IgZm9ybWF0LlxyXG4gICAgICAgKi9cclxuICAgICAgdmVjdG9yRGF0YTogVWludDhBcnJheTtcclxuICAgIH07XHJcblxyXG50eXBlIFJvbGUgPSAnY29tcGlsZXInIHwgJ3JlbmRlcmVyJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgc3dlZXQgc25pcHBldCBwcm92aWRlciBmb3IgYnVsbGRpbmcgdGhlIGNvbXBpbGVyIG9yIHJlbmRlcmVyIGNvbXBvbmVudC5cclxuICogU2VlIHtAbGluayBUeXBzdFNuaXBwZXQjdXNlfSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgZm9yUm9sZXM6IFJvbGVbXTtcclxuICBwcm92aWRlczogQmVmb3JlQnVpbGRGbltdO1xyXG59XHJcblxyXG5jb25zdCBpc05vZGUgPVxyXG4gIC8vIEB0cy1pZ25vcmVcclxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlbmllbnQgdXRpbCBjbGFzcyBmb3IgY29tcGlsaW5nIGRvY3VtZW50cywgd2hpY2ggaXMgYSB3cmFwcGVyIG9mIHRoZVxyXG4gKiB7QGxpbmsgVHlwc3RDb21waWxlcn0gYW5kIHtAbGluayBUeXBzdFJlbmRlcmVyfS5cclxuICpcclxuICogTm90ZTogdGhlIGludGVyZmFjZSBvZiB0aGlzIGNsYXNzIGlzIGxlc3Mgc3RhYmxlIHRoYW4ge0BsaW5rIFR5cHN0Q29tcGlsZXJ9XHJcbiAqIGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFVzZSB0aGUgKmdsb2JhbCBzaGFyZWQqIGNvbXBpbGVyIGluc3RhbmNlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7ICR0eXBzdCB9IGZyb20gJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL2Rpc3QvZXNtL2NvbnRyaWIvc25pcHBldC5tanMnO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZTogaWYgeW91IHdhbnQgdG8gY29tcGlsZSBtdWx0aXBsZSBkb2N1bWVudHMsIHlvdSBzaG91bGQgY3JlYXRlIGEgbmV3XHJcbiAqIGluc3RhbmNlIGZvciBlYWNoIGNvbXBpbGF0aW9uIHdvcmsgb3IgbWFpbnRhaW4gdGhlIHNoYXJlZCBzdGF0ZSBvbiB0aGVcclxuICogdXRpbGl0eSBpbnN0YW5jZSBgJHR5cHN0YCBjYXJlZnVsbHksIGJlY2F1c2UgdGhlIGNvbXBpbGF0aW9uIHByb2Nlc3Mgd2lsbFxyXG4gKiBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoYXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB1dGlsaXR5OlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0ICR0eXBzdCA9IG5ldyBUeXBzdFNuaXBwZXQoe1xyXG4gKiAgIC8vIG9wdGlvbmFsIHJlbmRlcmVyIGluc3RhbmNlXHJcbiAqICAgcmVuZGVyZXI6IGVuYWJsZVJlbmRlcmluZyA/PyAoKCkgPT4ge1xyXG4gKiAgICAgcmV0dXJuIGNyZWF0ZUdsb2JhbFJlbmRlcmVyKGNyZWF0ZVR5cHN0UmVuZGVyZXIsXHJcbiAqICAgICAgIHVuZGVmaW5lZCwgaW5pdE9wdGlvbnMpO1xyXG4gKiAgIH0pLFxyXG4gKiAgIGNvbXBpbGVyKCkgPT4ge1xyXG4gKiAgICAgcmV0dXJuIGNyZWF0ZUdsb2JhbENvbXBpbGVyKGNyZWF0ZVR5cHN0Q29tcGlsZXIsXHJcbiAqICAgICAgIGluaXRPcHRpb25zKTtcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUeXBzdFNuaXBwZXQge1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwcml2YXRlIG1haW5GaWxlUGF0aDogc3RyaW5nO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwcml2YXRlIGNjPzogUHJvbWlzZUp1c3Q8VHlwc3RDb21waWxlcj47XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHByaXZhdGUgZXg/OiBQcm9taXNlSnVzdDxUeXBzdFJlbmRlcmVyPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUeXBzdFNuaXBwZXR9LlxyXG4gICAqIEBwYXJhbSBjYyB0aGUgY29tcGlsZXIgaW5zdGFuY2UsIHNlZSB7QGxpbmsgUHJvbWlzZUp1c3R9IGFuZCB7QGxpbmsgVHlwc3RDb21waWxlcn0uXHJcbiAgICogQHBhcmFtIGV4IHRoZSByZW5kZXJlciBpbnN0YW5jZSwgc2VlIHtAbGluayBQcm9taXNlSnVzdH0gYW5kIHtAbGluayBUeXBzdFJlbmRlcmVyfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBQYXNzZXMgYSBnbG9iYWwgc2hhcmVkIGNvbXBpbGVyIGluc3RhbmNlIHRoYXQgZ2V0IGluaXRpYWxpemVkIGxhemlseTpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgJHR5cHN0ID0gbmV3IFR5cHN0U25pcHBldCgoKSA9PiB7XHJcbiAgICogIHJldHVybiBjcmVhdGVHbG9iYWxDb21waWxlcihjcmVhdGVUeXBzdENvbXBpbGVyLCBpbml0T3B0aW9ucyk7XHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzoge1xyXG4gICAgY29tcGlsZXI/OiBQcm9taXNlSnVzdDxUeXBzdENvbXBpbGVyPjtcclxuICAgIHJlbmRlcmVyPzogUHJvbWlzZUp1c3Q8VHlwc3RSZW5kZXJlcj47XHJcbiAgfSkge1xyXG4gICAgdGhpcy5jYyA9IG9wdGlvbnM/LmNvbXBpbGVyO1xyXG4gICAgdGhpcy5leCA9IG9wdGlvbnM/LnJlbmRlcmVyO1xyXG4gICAgdGhpcy5tYWluRmlsZVBhdGggPSAnL21haW4udHlwJztcclxuICAgIHRoaXMucHJvdmlkZXJzID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgbGF6eSBpbml0aWFsaXplZCBjb21waWxlciBpbnN0YW5jZSBmb3IgdGhlIHV0aWxpdHkgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIGNjIHRoZSBjb21waWxlciBpbnN0YW5jZSwgc2VlIHtAbGluayBQcm9taXNlSnVzdH0gYW5kIHtAbGluayBUeXBzdENvbXBpbGVyfS5cclxuICAgKi9cclxuICBzZXRDb21waWxlcihjYzogUHJvbWlzZUp1c3Q8VHlwc3RDb21waWxlcj4pIHtcclxuICAgIHRoaXMuY2MgPSBjYztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBpbml0aWFsaXplZCBjb21waWxlciBpbnN0YW5jZSBmcm9tIHRoZSB1dGlsaXR5IGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGFzeW5jIGdldENvbXBpbGVyKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5jYyA9PT0gJ2Z1bmN0aW9uJyA/ICh0aGlzLmNjID0gYXdhaXQgdGhpcy5jYygpKSA6IHRoaXMuY2MpITtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBsYXp5IGluaXRpYWxpemVkIHJlbmRlcmVyIGluc3RhbmNlIGZvciB0aGUgdXRpbGl0eSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gZXggdGhlIHJlbmRlcmVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0UmVuZGVyZXJ9LlxyXG4gICAqL1xyXG4gIHNldFJlbmRlcmVyKGV4OiBQcm9taXNlSnVzdDxUeXBzdFJlbmRlcmVyPikge1xyXG4gICAgdGhpcy5leCA9IGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIGluaXRpYWxpemVkIHJlbmRlcmVyIGluc3RhbmNlIGZyb20gdGhlIHV0aWxpdHkgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0UmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZXggPT09ICdmdW5jdGlvbicgPyAodGhpcy5leCA9IGF3YWl0IHRoaXMuZXgoKSkgOiB0aGlzLmV4O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwcm92aWRlcnM/OiBQcm9taXNlSnVzdDxUeXBzdFNuaXBwZXRQcm92aWRlcj5bXTtcclxuICAvKipcclxuICAgKiBhZGQgcHJvdmlkZXJzIGZvciBidWxsZGluZyB0aGUgY29tcGlsZXIgb3IgcmVuZGVyZXIgY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIHVzZSguLi5wcm92aWRlcnM6IFByb21pc2VKdXN0PFR5cHN0U25pcHBldFByb3ZpZGVyPltdKSB7XHJcbiAgICBpZiAoIXRoaXMucHJvdmlkZXJzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBwcmVwYXJlIHVzZXMgZm9yIGluc3RhbmNlcycpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wcm92aWRlcnMucHVzaCguLi5wcm92aWRlcnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFjY2Vzc2wgbW9kZWwgZm9yIHRoZSBjb21waWxlciBpbnN0YW5jZVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiB1c2UgbWVtb3J5IGFjY2VzcyBtb2RlbFxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IG0gPSBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgKiAkdHlwc3QudXNlKFR5cHN0U25pcHBldC53aXRoQWNjZXNzTW9kZWwobSkpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIHN0YXRpYyB3aXRoQWNjZXNzTW9kZWwoYWNjZXNzTW9kZWw6IFdyaXRhYmxlQWNjZXNzTW9kZWwpOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdhY2Nlc3MtbW9kZWwnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3dpdGhBY2Nlc3NNb2RlbChhY2Nlc3NNb2RlbCldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwYWNrYWdlIHJlZ2lzdHJ5IGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2VcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIGEgY3VzdG9taXplZCBwYWNrYWdlIHJlZ2lzdHJ5XHJcbiAgICpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgbiA9IG5ldyBOb2RlRmV0Y2hQYWNrYWdlUmVnaXN0cnkoKTtcclxuICAgKiAkdHlwc3QudXNlKFR5cHN0U25pcHBldC53aXRoUGFja2FnZVJlZ2lzdHJ5KG4pKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBzdGF0aWMgd2l0aFBhY2thZ2VSZWdpc3RyeShyZWdpc3RyeTogUGFja2FnZVJlZ2lzdHJ5KTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiAncGFja2FnZS1yZWdpc3RyeScsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzOiBbd2l0aFBhY2thZ2VSZWdpc3RyeShyZWdpc3RyeSldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIGFuIGFjY2VzcyBtb2RlbCB0byBzdG9yZSB0aGUgZGF0YSBvZiBmZXRjaGVkIGZpbGVzLlxyXG4gICAqIFByb3ZpZGUgYSBQYWNrYWdlUmVnaXN0cnkgaW5zdGFuY2UgZm9yIHRoZSBjb21waWxlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiB1c2UgZGVmYXVsdCAobWVtb3J5KSBhY2Nlc3MgbW9kZWxcclxuICAgKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiAkdHlwc3QudXNlKGF3YWl0IFR5cHN0U25pcHBldC5mZXRjaFBhY2thZ2VSZWdpc3RyeSgpKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiB1c2UgZXh0ZXJuYWwgYWNjZXNzIG1vZGVsXHJcbiAgICpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgbSA9IG5ldyBNZW1vcnlBY2Nlc3NNb2RlbCgpO1xyXG4gICAqICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LndpdGhBY2Nlc3NNb2RlbChtKSwgYXdhaXQgVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZVJlZ2lzdHJ5KG0pKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBzdGF0aWMgZmV0Y2hQYWNrYWdlUmVnaXN0cnkoYWNjZXNzTW9kZWw/OiBXcml0YWJsZUFjY2Vzc01vZGVsKTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgY29uc3QgbSA9IGFjY2Vzc01vZGVsIHx8IG5ldyBNZW1vcnlBY2Nlc3NNb2RlbCgpO1xyXG4gICAgY29uc3QgcHJvdmlkZXMgPSBbXHJcbiAgICAgIC4uLihhY2Nlc3NNb2RlbCA/IFtdIDogW3dpdGhBY2Nlc3NNb2RlbChtKV0pLFxyXG4gICAgICB3aXRoUGFja2FnZVJlZ2lzdHJ5KG5ldyBGZXRjaFBhY2thZ2VSZWdpc3RyeShtKSksXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiAncGFja2FnZS1yZWdpc3RyeSRmZXRjaCcsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIGEgZmV0Y2hlciBmb3IgZmV0Y2hpbmcgcGFja2FnZSBkYXRhLlxyXG4gICAqIFByb3ZpZGUgYSBQYWNrYWdlUmVnaXN0cnkgaW5zdGFuY2UgZm9yIHRoZSBjb21waWxlciBpbnN0YW5jZS5cclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIGEgY3VzdG9taXplZCBmZXRjaGVyXHJcbiAgICpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IHJlcXVlc3QgZnJvbSAnc3luYy1yZXF1ZXN0LWN1cmwnO1xyXG4gICAqIGNvbnN0IG0gPSBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgKiAkdHlwc3QudXNlKFR5cHN0U25pcHBldC53aXRoQWNjZXNzTW9kZWwobSksIGF3YWl0IFR5cHN0U25pcHBldC5mZXRjaFBhY2thZ2VCeShtLCAoXywgaHR0cFVybCkgPT4ge1xyXG4gICAqICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0KCdHRVQnLCB0aGlzLnJlc29sdmVQYXRoKHBhdGgpLCB7XHJcbiAgICogICAgIGluc2VjdXJlOiB0cnVlLFxyXG4gICAqICAgfSk7XHJcbiAgICpcclxuICAgKiAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcclxuICAgKiAgICAgcmV0dXJuIHJlc3BvbnNlLmdldEJvZHkodW5kZWZpbmVkKTtcclxuICAgKiAgIH1cclxuICAgKiAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICogfSkpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIHN0YXRpYyBmZXRjaFBhY2thZ2VCeShcclxuICAgIGFjY2Vzc01vZGVsOiBXcml0YWJsZUFjY2Vzc01vZGVsLFxyXG4gICAgZmV0Y2hlcjogKHBhdGg6IFBhY2thZ2VTcGVjLCBkZWZhdWx0SHR0cFVybDogc3RyaW5nKSA9PiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxyXG4gICk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIGNsYXNzIEh0dHBQYWNrYWdlUmVnaXN0cnkgZXh0ZW5kcyBGZXRjaFBhY2thZ2VSZWdpc3RyeSB7XHJcbiAgICAgIHB1bGxQYWNrYWdlRGF0YShwYXRoOiBQYWNrYWdlU3BlYyk6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIHJldHVybiBmZXRjaGVyKHBhdGgsIHRoaXMucmVzb2x2ZVBhdGgocGF0aCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdwYWNrYWdlLXJlZ2lzdHJ5JGxhbWJkYScsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzOiBbd2l0aFBhY2thZ2VSZWdpc3RyeShuZXcgSHR0cFBhY2thZ2VSZWdpc3RyeShhY2Nlc3NNb2RlbCkpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgY2NPcHRpb25zOiBQYXJ0aWFsPEluaXRPcHRpb25zPjtcclxuICAvKipcclxuICAgKiBTZXQgY29tcGlsZXIgaW5pdCBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgZ2xvYmFsIGluc3RhbmNlIHtAbGluayAkdHlwc3R9LlxyXG4gICAqIFNlZSB7QGxpbmsgSW5pdE9wdGlvbnN9LlxyXG4gICAqL1xyXG4gIHNldENvbXBpbGVySW5pdE9wdGlvbnMob3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz4pIHtcclxuICAgIHRoaXMucmVxdWlyZUlzVW5pbml0aWFsaXplZCgnY29tcGlsZXInLCB0aGlzLmNjLCBUeXBzdFNuaXBwZXQuJGJ1aWxkQyk7XHJcbiAgICB0aGlzLmNjT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgZXhPcHRpb25zOiBQYXJ0aWFsPEluaXRPcHRpb25zPjtcclxuICAvKipcclxuICAgKiBTZXQgcmVuZGVyZXIgaW5pdCBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgZ2xvYmFsIGluc3RhbmNlIHtAbGluayAkdHlwc3R9LlxyXG4gICAqIFNlZSB7QGxpbmsgSW5pdE9wdGlvbnN9LlxyXG4gICAqL1xyXG4gIHNldFJlbmRlcmVySW5pdE9wdGlvbnMob3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz4pIHtcclxuICAgIHRoaXMucmVxdWlyZUlzVW5pbml0aWFsaXplZCgncmVuZGVyZXInLCB0aGlzLmV4LCBUeXBzdFNuaXBwZXQuJGJ1aWxkUik7XHJcbiAgICB0aGlzLmV4T3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgc2hhcmVkIG1haW4gZmlsZSBwYXRoLlxyXG4gICAqL1xyXG4gIHNldE1haW5GaWxlUGF0aChwYXRoOiBzdHJpbmcpIHtcclxuICAgIHRoaXMubWFpbkZpbGVQYXRoID0gcGF0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzaGFyZWQgbWFpbiBmaWxlIHBhdGguXHJcbiAgICovXHJcbiAgZ2V0TWFpbkZpbGVQYXRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFpbkZpbGVQYXRoO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlVG1wKG9wdHM6IENvbXBpbGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAob3B0cy5tYWluRmlsZVBhdGguc3RhcnRzV2l0aCgnL3RtcC8nKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy51bm1hcFNoYWRvdyhvcHRzLm1haW5GaWxlUGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc291cmNlIGZpbGUgdG8gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNhZGRTb3VyY2V9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGFkZFNvdXJjZShwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSkuYWRkU291cmNlKHBhdGgsIGNvbnRlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHNoYWRvdyBmaWxlcy5cclxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIGluZGVwZW5kZW50IHRvIHRoZSB7QGxpbmsgcmVzZXR9IGZ1bmN0aW9uLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNyZXNldFNoYWRvd30uXHJcbiAgICovXHJcbiAgYXN5bmMgcmVzZXRTaGFkb3coKSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS5yZXNldFNoYWRvdygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2hhZG93IGZpbGUgdG8gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNtYXBTaGFkb3d9LlxyXG4gICAqL1xyXG4gIGFzeW5jIG1hcFNoYWRvdyhwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IFVpbnQ4QXJyYXkpIHtcclxuICAgIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpLm1hcFNoYWRvdyhwYXRoLCBjb250ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIHNoYWRvdyBmaWxlIGZyb20gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciN1bm1hcFNoYWRvd30uXHJcbiAgICovXHJcbiAgYXN5bmMgdW5tYXBTaGFkb3cocGF0aDogc3RyaW5nKSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS51bm1hcFNoYWRvdyhwYXRoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgdGhlIGRvY3VtZW50IHRvIHZlY3RvciAoSVIpIGZvcm1hdC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0Q29tcGlsZU9wdGlvbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIHZlY3RvcihvPzogU3dlZXRDb21waWxlT3B0aW9ucykge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLmNvbXBpbGUob3B0cylcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5yZXN1bHQpXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgdGhlIGRvY3VtZW50IHRvIFBERiBmb3JtYXQuXHJcbiAgICogU2VlIHtAbGluayBTd2VldENvbXBpbGVPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyBwZGYobz86IFN3ZWV0Q29tcGlsZU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgb3B0cy5mb3JtYXQgPSAncGRmJztcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKVxyXG4gICAgICAuY29tcGlsZShvcHRzKVxyXG4gICAgICAudGhlbihyZXMgPT4gcmVzLnJlc3VsdClcclxuICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5yZW1vdmVUbXAob3B0cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZSB0aGUgZG9jdW1lbnQgdG8gU1ZHIGZvcm1hdC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0UmVuZGVyT3B0aW9uc30gYW5kIHtAbGluayBSZW5kZXJTdmdPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyBzdmcobz86IFN3ZWV0UmVuZGVyT3B0aW9ucyAmIFJlbmRlclN2Z09wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaWVudFJlbmRlcihvLCAocmVuZGVyZXIsIHJlbmRlclNlc3Npb24pID0+XHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlclN2Zyh7XHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICByZW5kZXJTZXNzaW9uLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlIHRoZSBkb2N1bWVudCB0byBjYW52YXMgb3BlcmF0aW9ucy5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0UmVuZGVyT3B0aW9uc30gYW5kIHtAbGluayBSZW5kZXJUb0NhbnZhc09wdGlvbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGNhbnZhcyhcclxuICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXHJcbiAgICBvPzogU3dlZXRSZW5kZXJPcHRpb25zICYgT21pdDxSZW5kZXJUb0NhbnZhc09wdGlvbnMsICdjb250YWluZXInPixcclxuICApIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaWVudFJlbmRlcihvLCAocmVuZGVyZXIsIHJlbmRlclNlc3Npb24pID0+XHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRvQ2FudmFzKHtcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICByZW5kZXJTZXNzaW9uLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc2VtYW50aWMgdG9rZW5zIGZvciB0aGUgZG9jdW1lbnQuXHJcbiAgICovXHJcbiAgYXN5bmMgcXVlcnk8VD4obzogU3dlZXRDb21waWxlT3B0aW9ucyAmIHsgc2VsZWN0b3I6IHN0cmluZzsgZmllbGQ/OiBzdHJpbmcgfSk6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLnF1ZXJ5PFQ+KHtcclxuICAgICAgICAuLi5vLFxyXG4gICAgICAgIC4uLm9wdHMsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0b2tlbiBsZWdlbmQgZm9yIHNlbWFudGljIHRva2Vucy5cclxuICAgKi9cclxuICBhc3luYyBnZXRTZW1hbnRpY1Rva2VuTGVnZW5kKCk6IFByb21pc2U8U2VtYW50aWNUb2tlbnNMZWdlbmQ+IHtcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS5nZXRTZW1hbnRpY1Rva2VuTGVnZW5kKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc2VtYW50aWMgdG9rZW5zIGZvciB0aGUgZG9jdW1lbnQuXHJcbiAgICogU2VlIHtAbGluayBTd2VldENvbXBpbGVPcHRpb25zfS5cclxuICAgKiBTZWUge0BsaW5rIFR5cHN0Q29tcGlsZXIjZ2V0U2VtYW50aWNUb2tlbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFNlbWFudGljVG9rZW5zKG86IFN3ZWV0Q29tcGlsZU9wdGlvbnMgJiB7IHJlc3VsdElkPzogc3RyaW5nIH0pOiBQcm9taXNlPFNlbWFudGljVG9rZW5zPiB7XHJcbiAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRDb21waWxlT3B0aW9ucyhvKTtcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKVxyXG4gICAgICAuZ2V0U2VtYW50aWNUb2tlbnMoe1xyXG4gICAgICAgIG1haW5GaWxlUGF0aDogb3B0cy5tYWluRmlsZVBhdGgsXHJcbiAgICAgICAgcmVzdWx0SWQ6IG8ucmVzdWx0SWQsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q29tcGlsZU9wdGlvbnMoXHJcbiAgICBvcHRzPzogU3dlZXRDb21waWxlT3B0aW9ucyxcclxuICApOiBQcm9taXNlPENvbXBpbGVPcHRpb25zPGFueSwgJ25vbmUnPj4ge1xyXG4gICAgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4geyBtYWluRmlsZVBhdGg6IHRoaXMubWFpbkZpbGVQYXRoLCBkaWFnbm9zdGljczogJ25vbmUnIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBsZWFzZSBzcGVjaWZ5IG9wdHMgYXMge21haW5Db250ZW50OiAnLi4uJ30gb3Ige21haW5GaWxlUGF0aDogJy4uLid9YCk7XHJcbiAgICB9IGVsc2UgaWYgKCdtYWluRmlsZVBhdGgnIGluIG9wdHMpIHtcclxuICAgICAgcmV0dXJuIHsgLi4ub3B0cywgZGlhZ25vc3RpY3M6ICdub25lJyB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgZGVzdEZpbGUgPSBgL3RtcC8ke3JhbmRzdHIoKX0udHlwYDtcclxuICAgICAgYXdhaXQgdGhpcy5hZGRTb3VyY2UoZGVzdEZpbGUsIG9wdHMubWFpbkNvbnRlbnQpO1xyXG4gICAgICByZXR1cm4geyBtYWluRmlsZVBhdGg6IGRlc3RGaWxlLCBpbnB1dHM6IG9wdHMuaW5wdXRzLCBkaWFnbm9zdGljczogJ25vbmUnIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldFZlY3RvcihvPzogU3dlZXRSZW5kZXJPcHRpb25zKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICBpZiAobyAmJiAndmVjdG9yRGF0YScgaW4gbykge1xyXG4gICAgICByZXR1cm4gby52ZWN0b3JEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpXHJcbiAgICAgIC5jb21waWxlKG9wdHMpXHJcbiAgICAgIC50aGVuKHJlcyA9PiByZXMucmVzdWx0ISlcclxuICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5yZW1vdmVUbXAob3B0cykpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyB0cmFuc2llbnRSZW5kZXI8VD4oXHJcbiAgICBvcHRzOiBTd2VldFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQsXHJcbiAgICBmOiAocnI6IFR5cHN0UmVuZGVyZXIsIHNlc3Npb246IFJlbmRlclNlc3Npb24pID0+IFQsXHJcbiAgKTogUHJvbWlzZTxUPiB7XHJcbiAgICBjb25zdCByciA9IGF3YWl0IHRoaXMuZ2V0UmVuZGVyZXIoKTtcclxuICAgIGlmICghcnIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb2VzIG5vdCBwcm92aWRlIHJlbmRlcmVyIGluc3RhbmNlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRWZWN0b3Iob3B0cyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcnIucnVuV2l0aFNlc3Npb24oYXN5bmMgc2Vzc2lvbiA9PiB7XHJcbiAgICAgIHJyLm1hbmlwdWxhdGVEYXRhKHtcclxuICAgICAgICByZW5kZXJTZXNzaW9uOiBzZXNzaW9uLFxyXG4gICAgICAgIGFjdGlvbjogJ3Jlc2V0JyxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGYocnIsIHNlc3Npb24pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHByZXBhcmVVc2UoKSB7XHJcbiAgICBpZiAoIXRoaXMucHJvdmlkZXJzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwcm92aWRlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgdGhpcy5wcm92aWRlcnMubWFwKHAgPT4gKHR5cGVvZiBwID09PSAnZnVuY3Rpb24nID8gcCgpIDogcCkpLFxyXG4gICAgKTtcclxuICAgIHRoaXMucHJvdmlkZXJzID0gW107XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAkdHlwc3QgPT0gdGhpcyAmJlxyXG4gICAgICAhcHJvdmlkZXJzLnNvbWUocCA9PiBwLmtleS5pbmNsdWRlcygncGFja2FnZS1yZWdpc3RyeScpIHx8IHAua2V5LmluY2x1ZGVzKCdhY2Nlc3MtbW9kZWwnKSlcclxuICAgICkge1xyXG4gICAgICAvLyBOb3RlOiB0aGUgZGVmYXVsdCBmZXRjaCBiYWNrZW5kIGFsd2F5cyBhZGRzIGEgd2l0aEFjY2Vzc01vZGVsKG1lbSlcclxuICAgICAgaWYgKGlzTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGVzY2FwZUltcG9ydCA9IG5ldyBGdW5jdGlvbignbScsICdyZXR1cm4gaW1wb3J0KG0pJyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogcmVxdWVzdCB9ID0gYXdhaXQgZXNjYXBlSW1wb3J0KCdzeW5jLXJlcXVlc3QnKTtcclxuXHJcbiAgICAgICAgICAkdHlwc3QudXNlKFxyXG4gICAgICAgICAgICBUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pLFxyXG4gICAgICAgICAgICBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlQnkobSwgKF86IHVua25vd24sIHBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdCgnR0VUJywgcGF0aCk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5nZXRCb2R5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZVJlZ2lzdHJ5KCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvdmlkZXJzMiA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICB0aGlzLnByb3ZpZGVycy5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdmdW5jdGlvbicgPyBwKCkgOiBwKSksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNjT3B0aW9ucyA9ICh0aGlzLmNjT3B0aW9ucyB8fD0ge30pO1xyXG4gICAgY29uc3QgY2NCZWZvcmVCdWlsZCA9IChjY09wdGlvbnMuYmVmb3JlQnVpbGQgfHw9IFtdKTtcclxuXHJcbiAgICBjb25zdCBleE9wdGlvbnMgPSAodGhpcy5leE9wdGlvbnMgfHw9IHt9KTtcclxuICAgIGNvbnN0IGV4QmVmb3JlQnVpbGQgPSAoZXhPcHRpb25zLmJlZm9yZUJ1aWxkIHx8PSBbXSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBbLi4ucHJvdmlkZXJzLCAuLi5wcm92aWRlcnMyXSkge1xyXG4gICAgICBpZiAocHJvdmlkZXIuZm9yUm9sZXMuaW5jbHVkZXMoJ2NvbXBpbGVyJykpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ2NvbXBpbGVyJywgdGhpcy5jYywgVHlwc3RTbmlwcGV0LiRidWlsZEMpO1xyXG4gICAgICAgIGNjQmVmb3JlQnVpbGQucHVzaCguLi5wcm92aWRlci5wcm92aWRlcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3ZpZGVyLmZvclJvbGVzLmluY2x1ZGVzKCdyZW5kZXJlcicpKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1aXJlSXNVbmluaXRpYWxpemVkKCdyZW5kZXJlcicsIHRoaXMuZXgsIFR5cHN0U25pcHBldC4kYnVpbGRSKTtcclxuICAgICAgICBleEJlZm9yZUJ1aWxkLnB1c2goLi4ucHJvdmlkZXIucHJvdmlkZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnByb3ZpZGVycyA9IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVxdWlyZUlzVW5pbml0aWFsaXplZDxUPihyb2xlOiBzdHJpbmcsIGM6IFByb21pc2VKdXN0PFQ+LCBlPzogUHJvbWlzZUp1c3Q8VD4pIHtcclxuICAgIGlmICh0eXBlb2YgYyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cm9sZX0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQ6ICR7Y31gKTtcclxuICAgIH1cclxuICAgIGlmIChlICYmIGMgIT0gZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cm9sZX0gaW5zdGFuY2UgaXMgc2V0IHRvIG5vbiBkZWZhdWx0IHZhbHVlYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc3RhdGljIGFzeW5jICRidWlsZEModGhpczogVHlwc3RTbmlwcGV0KSB7XHJcbiAgICAvLyBsYXp5IGltcG9ydCBjb21waWxlIG1vZHVsZVxyXG4gICAgY29uc3QgeyBjcmVhdGVHbG9iYWxDb21waWxlciB9ID0gKGF3YWl0IGltcG9ydChcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL2Rpc3QvZXNtL2NvbnRyaWIvZ2xvYmFsLWNvbXBpbGVyLm1qcydcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuL2dsb2JhbC1jb21waWxlci5tanMnKTtcclxuICAgIGNvbnN0IHsgY3JlYXRlVHlwc3RDb21waWxlciB9ID0gKGF3YWl0IGltcG9ydChcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL2Rpc3QvZXNtL2NvbXBpbGVyLm1qcydcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9jb21waWxlci5tanMnKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnByZXBhcmVVc2UoKTtcclxuICAgIHJldHVybiBjcmVhdGVHbG9iYWxDb21waWxlcihjcmVhdGVUeXBzdENvbXBpbGVyLCB0aGlzLmNjT3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc3RhdGljIGFzeW5jICRidWlsZFIodGhpczogVHlwc3RTbmlwcGV0KSB7XHJcbiAgICAvLyBsYXp5IGltcG9ydCByZW5kZXJlciBtb2R1bGVcclxuICAgIGNvbnN0IHsgY3JlYXRlR2xvYmFsUmVuZGVyZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9kaXN0L2VzbS9jb250cmliL2dsb2JhbC1yZW5kZXJlci5tanMnXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi9nbG9iYWwtcmVuZGVyZXIubWpzJyk7XHJcbiAgICBjb25zdCB7IGNyZWF0ZVR5cHN0UmVuZGVyZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9kaXN0L2VzbS9yZW5kZXJlci5tanMnXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi4vcmVuZGVyZXIubWpzJyk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlVXNlKCk7XHJcbiAgICByZXR1cm4gY3JlYXRlR2xvYmFsUmVuZGVyZXIoY3JlYXRlVHlwc3RSZW5kZXJlciwgdGhpcy5leE9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsYXp5IGluaXRpYWxpemVkIGdsb2JhbCBzaGFyZWQgaW5zdGFuY2Ugb2Yge0BsaW5rIFR5cHN0U25pcHBldH0uIFNlZVxyXG4gKiB7QGxpbmsgVHlwc3RTbmlwcGV0fSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0ICR0eXBzdCA9IG5ldyBUeXBzdFNuaXBwZXQoe1xyXG4gIGNvbXBpbGVyOiBUeXBzdFNuaXBwZXQuJGJ1aWxkQyxcclxuICByZW5kZXJlcjogVHlwc3RTbmlwcGV0LiRidWlsZFIsXHJcbn0pO1xyXG4iXX0=